export module iplusplus:core;

import std.core;

namespace core
{
    export struct system_time
    {
        unsigned short year;
        unsigned short month;
        unsigned short day_of_week;
        unsigned short day;
        unsigned short hour;
        unsigned short minute;
        unsigned short second;
        unsigned short millisecond;
    };

    export typedef wchar_t character;

    export template <class t>
        struct less
    {
        bool operator()(const t& a, const t& b) const { return a < b; }
    };

    export template<class t>
        struct compare
    {
        int operator()(const t& a, const t& b) const
        {
            if (a < b) return -1;
            if (b < a) return 1;
            return 0;
        }
    };

    export inline unsigned long long Power2(unsigned long long c)
    {
        unsigned long long level = 0;
        while (c % 2 != 1)
        {
            c /= 2;
            level++;
        }
        return level;
    }

    typedef unsigned char uchar;
    typedef unsigned short ushort;

    export struct direction
    {
        enum { from_left, from_right };
    };

    export struct state
    {
        enum
        {
            header,
            balanced,
            left_high,
            right_high
        };
    };

    extern "C" unsigned GetCurrentThreadId();

    extern "C" void Sleep(unsigned milliseconds = 0);

    extern "C" long __cdecl _InterlockedCompareExchange(long volatile* Destination, long exchange, long comparand);

    extern "C" bool __cdecl VirtFree(void* Destination);

    extern "C" bool __cdecl VirtFree(void * Destination);

    export extern "C" void* __stdcall VirtAlloc(void* address,
        unsigned long long size,
        unsigned type,
        unsigned protection);

#pragma intrinsic(_InterlockedCompareExchange)

    export struct semaphore
    {
        long busy;
        unsigned thread;

        semaphore() : busy(0), thread(0) {}

        inline void request()
        {
            unsigned identity = GetCurrentThreadId();

            for (;;)
                if (_InterlockedCompareExchange(&busy, 1, 0))
                {
                    if (identity == thread)
                    {
                        busy++;
                        break;
                    }
                    else
                    {
                        Sleep(0);
                    }
                }
                else
                {
                    thread = identity;
                    break;
                }
        }

        inline bool release()
        {
            if (busy)
            {
                unsigned identity = GetCurrentThreadId();
                if (identity == thread)
                {
                    if (busy == 1) thread = 0;
                    busy--;
                    return true;
                }
                else
                    return false;  // Not semaphore owner
            }
            else
                return false;  // Semaphore unowned
        }
    };

    export struct wait
    {
        semaphore& s;
        wait(const semaphore& s_in) : s((semaphore&)s_in) { s.request(); }
        ~wait() { s.release(); }
    };


    static unsigned boundaries[] = { 0,8,16,24,32,40,56,88,120,160,184,216,256,304,352,400,472,600,728,984,1496,2008,2520,3032,3544,4056,4568,5080,5592,6104,6616,7128,7640,8152 };

    enum { number_of_pools = sizeof(boundaries) / sizeof(unsigned), leading = 16 };
    enum { block_size = 65536 };

    inline unsigned long long quantum_from_size(unsigned long long size)
    {
        unsigned long long i = 0;
        while (size > boundaries[i] + leading && i < number_of_pools) i++;
        return i;
    }

    inline unsigned long long quantum_size(unsigned long long size) { return boundaries[size]; }

    inline unsigned long long round_up(unsigned long long value,
        unsigned long long base)
    {
        if (value < base)
            return base;
        else if (value % base)
            return value + (base - (value % base));
        else
            return value;
    }

    export struct pointer_status
    {
        enum
        {
            not_in_heap,
            not_aligned,
            identity_invalid,
            free,
            allocated
        };
    };

    enum
    {
        small_unit_overhead = 8,
        large_unit_overhead = 48,
        block_overhead = 40
    };

    struct pool_node
    {
        uchar identity;
        char is_block;
        ushort units;
        char balance;
        pool_node* left;
        pool_node* right;
        pool_node* parent;

        bool is_header() { return balance == (char)core::state::header; }
    };

    inline void rotate_left(pool_node*& root)
    {
        pool_node* parent = root->parent;
        pool_node* x = root->right;
        root->parent = x;
        x->parent = parent;
        if (x->left) x->left->parent = root;
        root->right = x->left;
        x->left = root;
        root = x;
    }

    inline void rotate_right(pool_node*& root)
    {
        pool_node* parent = root->parent;
        pool_node* x = root->left;
        root->parent = x;
        x->parent = parent;
        if (x->right) x->right->parent = root;
        root->left = x->right;
        x->right = root;
        root = x;
    }

    inline void balance_left(pool_node*& root)
    {
        pool_node* left = root->left; // left Subtree of root pool_node

        switch (left->balance)
        {
        case core::state::left_high:
            root->balance = core::state::balanced;
            left->balance = core::state::balanced;
            rotate_right(root);
            break;

        case core::state::right_high:
        {
            pool_node* subright = left->right;  // right subtree of left
            switch (subright->balance)
            {
            case core::state::balanced:
                root->balance = core::state::balanced;
                left->balance = core::state::balanced;
                break;

            case core::state::right_high:
                root->balance = core::state::balanced;
                left->balance = core::state::left_high;
                break;

            case core::state::left_high:
                root->balance = core::state::right_high;
                left->balance = core::state::balanced;
                break;
            }
            subright->balance = core::state::balanced;
            rotate_left(left);
            root->left = left;
            rotate_right(root);
        }
        break;

        case core::state::balanced:
            root->balance = core::state::left_high;
            left->balance = core::state::right_high;
            rotate_right(root);
            break;
        }
    }

    inline void balance_right(pool_node*& root)
    {
        pool_node* right = root->right; // right Subtree of root pool_node

        switch (right->balance)
        {
        case core::state::right_high:
            root->balance = core::state::balanced;
            right->balance = core::state::balanced;
            rotate_left(root);
            break;

        case core::state::left_high:
        {
            pool_node* subleft = right->left; // left Subtree of right
            switch (subleft->balance)
            {
            case core::state::balanced:
                root->balance = core::state::balanced;
                right->balance = core::state::balanced;
                break;

            case core::state::left_high:
                root->balance = core::state::balanced;
                right->balance = core::state::right_high;
                break;

            case core::state::right_high:
                root->balance = core::state::left_high;
                right->balance = core::state::balanced;
                break;
            }
            subleft->balance = core::state::balanced;
            rotate_right(right);
            root->right = right;
            rotate_left(root);
        }
        break;

        case core::state::balanced:
            root->balance = core::state::right_high;
            right->balance = core::state::left_high;
            rotate_left(root);
            break;
        }
    }

    inline void balance_tree(pool_node* root, unsigned long long from)
    {
        bool taller = true;

        while (taller)
        {
            pool_node* parent = root->parent;
            unsigned long long next_from = (parent->left == root) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    if (parent->is_header())
                        balance_left(parent->parent);
                    else if (parent->left == root)
                        balance_left(parent->left);
                    else
                        balance_left(parent->right);
                    taller = false;
                    break;

                case core::state::balanced:
                    root->balance = core::state::left_high;
                    taller = true;
                    break;

                case core::state::right_high:
                    root->balance = core::state::balanced;
                    taller = false;
                    break;
                }
            }
            else
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    root->balance = core::state::balanced;
                    taller = false;
                    break;

                case core::state::balanced:
                    root->balance = core::state::right_high;
                    taller = true;
                    break;

                case core::state::right_high:
                    if (parent->is_header())
                        balance_right(parent->parent);
                    else if (parent->left == root)
                        balance_right(parent->left);
                    else
                        balance_right(parent->right);
                    taller = false;
                    break;
                }
            }

            if (taller) // skip up a level
            {
                if (parent->is_header())
                    taller = false;
                else
                {
                    root = parent;
                    from = next_from;
                }
            }
        }
    }

    inline void balance_tree_remove(pool_node* root, unsigned long long from)
    {
        if (root->is_header()) return;

        bool shorter = true;

        while (shorter)
        {
            pool_node* parent = root->parent;
            unsigned long long next_from = (parent->left == root) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    root->balance = core::state::balanced;
                    shorter = true;
                    break;

                case core::state::balanced:
                    root->balance = core::state::right_high;
                    shorter = false;
                    break;

                case core::state::right_high:
                    if (root->right->balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;
                    if (parent->is_header())
                        balance_right(parent->parent);
                    else if (parent->left == root)
                        balance_right(parent->left);
                    else
                        balance_right(parent->right);
                    break;
                }
            }
            else
            {
                switch (root->balance)
                {
                case core::state::right_high:
                    root->balance = core::state::balanced;
                    shorter = true;
                    break;

                case core::state::balanced:
                    root->balance = core::state::left_high;
                    shorter = false;
                    break;

                case core::state::left_high:
                    if (root->left->balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;
                    if (parent->is_header())
                        balance_left(parent->parent);
                    else if (parent->left == root)
                        balance_left(parent->left);
                    else
                        balance_left(parent->right);
                    break;
                }
            }

            if (shorter)
            {
                if (parent->is_header())
                    shorter = false;
                else
                {
                    from = next_from;
                    root = parent;
                }
            }
        }
    }

    inline void swap_pool_node_reference(pool_node*& first, pool_node*& second)
    {
        pool_node* temporary = first; first = second; second = temporary;
    }

    inline void left_pool_node_swap(pool_node* root, pool_node* replace)
    {
        if (replace->left) replace->left->parent = root;
        if (replace->right) replace->right->parent = root;

        if (root->right) root->right->parent = replace;

        if (replace == root->left)
        {
            replace->parent = root->parent;
            root->parent = replace;

            root->left = replace->left;
            replace->left = root;
        }
        else
        {
            root->left->parent = replace;

            if (replace->parent->left == replace)
                replace->parent->left = root;
            else
                replace->parent->right = root;

            swap_pool_node_reference(root->left, replace->left);
            swap_pool_node_reference(root->parent, replace->parent);
        }

        swap_pool_node_reference(root->right, replace->right);

        char balance = root->balance; root->balance = replace->balance; replace->balance = balance;
    }

    inline void swap_pool_nodes(pool_node* A, pool_node* B)
    {
        if (B == A->left)
        {
            if (B->left) B->left->parent = A;
            if (B->right) B->right->parent = A;

            if (A->right) A->right->parent = B;

            if (!A->parent->is_header())
            {
                if (A->parent->left == A)
                    A->parent->left = B;
                else
                    A->parent->right = B;
            }
            else A->parent->parent = B;

            B->parent = A->parent;
            A->parent = B;

            A->left = B->left;
            B->left = A;

            swap_pool_node_reference(A->right, B->right);
        }
        else if (B == A->right)
        {
            if (B->right) B->right->parent = A;
            if (B->left) B->left->parent = A;

            if (A->left) A->left->parent = B;

            if (!A->parent->is_header())
            {
                if (A->parent->left == A)
                    A->parent->left = B;
                else
                    A->parent->right = B;
            }
            else A->parent->parent = B;

            B->parent = A->parent;
            A->parent = B;

            A->right = B->right;
            B->right = A;

            swap_pool_node_reference(A->left, B->left);
        }
        else if (A == B->left)
        {
            if (A->left) A->left->parent = B;
            if (A->right) A->right->parent = B;

            if (B->right) B->right->parent = A;

            if (!B->parent->is_header())
            {
                if (B->parent->left == B)
                    B->parent->left = A;
                else
                    B->parent->right = A;
            }
            else B->parent->parent = A;

            A->parent = B->parent;
            B->parent = A;

            B->left = A->left;
            A->left = B;

            swap_pool_node_reference(A->right, B->right);
        }
        else if (A == B->right)
        {
            if (A->right) A->right->parent = B;
            if (A->left) A->left->parent = B;

            if (B->left) B->left->parent = A;

            if (!B->parent->is_header())
            {
                if (B->parent->left == B)
                    B->parent->left = A;
                else
                    B->parent->right = A;
            }
            else B->parent->parent = A;

            A->parent = B->parent;
            B->parent = A;

            B->right = A->right;
            A->right = B;

            swap_pool_node_reference(A->left, B->left);
        }
        else
        {
            if (A->parent == B->parent)
                swap_pool_node_reference(A->parent->left, A->parent->right);
            else
            {
                if (!A->parent->is_header())
                {
                    if (A->parent->left == A)
                        A->parent->left = B;
                    else
                        A->parent->right = B;
                }
                else A->parent->parent = B;

                if (!B->parent->is_header())
                {
                    if (B->parent->left == B)
                        B->parent->left = A;
                    else
                        B->parent->right = A;
                }
                else B->parent->parent = A;
            }

            if (B->left)  B->left->parent = A;
            if (B->right) B->right->parent = A;

            if (A->left)  A->left->parent = B;
            if (A->right) A->right->parent = B;

            swap_pool_node_reference(A->left, B->left);
            swap_pool_node_reference(A->right, B->right);
            swap_pool_node_reference(A->parent, B->parent);
        }

        char balance = A->balance; A->balance = B->balance; B->balance = balance;
    }

    inline pool_node* fast_reverse(pool_node* pn)
    {
        if (pn->is_header()) { return pn->right; }

        else if (pn->left != 0)
        {
            pool_node* y = pn->left;
            while (y->right != 0) y = y->right;
            pn = y;
        }
        else
        {
            pool_node* y = pn->parent;
            if (y->is_header()) return y;
            while (pn == y->left) { pn = y; y = y->parent; }
            pn = y;
        }
        return pn;
    }

    inline pool_node* fast_forward(pool_node* pn)
    {
        if (pn->is_header()) return pn->left;

        if (pn->right != 0)
        {
            pn = pn->right;
            while (pn->left != 0) pn = pn->left;
        }
        else
        {
            pool_node* y = pn->parent;
            if (y->is_header()) return y;
            while (pn == y->right) { pn = y; y = y->parent; }
            pn = y;
        }
        return pn;
    }

    inline int pool_comparer(pool_node* pn1, pool_node* pn2)
    {
        if (pn1 < pn2)
            return -1;
        else if (pn1 > pn2)
            return 1;
        else
            return 0;
    }

    struct heap_node
    {
        char balance;
        uchar identity;
        heap_node* left;
        heap_node* right;
        heap_node* parent;
        unsigned long long size;

        bool is_header() { return balance == (char)core::state::header; }
    };

    inline int heap_comparer(heap_node* hn1, heap_node* hn2)
    {
        if (hn1 < hn2)
            return -1;
        else if (hn1 > hn2)
            return 1;
        else
            return 0;
    }
    inline void rotate_left(heap_node*& root)
    {
        heap_node* parent = root->parent;
        heap_node* x = root->right;
        root->parent = x;
        x->parent = parent;
        if (x->left) x->left->parent = root;
        root->right = x->left;
        x->left = root;
        root = x;
    }

    inline void rotate_right(heap_node*& root)
    {
        heap_node* parent = root->parent;
        heap_node* x = root->left;
        root->parent = x;
        x->parent = parent;
        if (x->right) x->right->parent = root;
        root->left = x->right;
        x->right = root;
        root = x;
    }

    inline void balance_left(heap_node*& root)
    {
        heap_node* left = root->left; // left Subtree of root heap_node

        switch (left->balance)
        {
        case core::state::left_high:
            root->balance = core::state::balanced;
            left->balance = core::state::balanced;
            rotate_right(root);
            break;

        case core::state::right_high:
        {
            heap_node* subright = left->right;  // right subtree of left
            switch (subright->balance)
            {
            case core::state::balanced:
                root->balance = core::state::balanced;
                left->balance = core::state::balanced;
                break;

            case core::state::right_high:
                root->balance = core::state::balanced;
                left->balance = core::state::left_high;
                break;

            case core::state::left_high:
                root->balance = core::state::right_high;
                left->balance = core::state::balanced;
                break;
            }
            subright->balance = core::state::balanced;
            rotate_left(left);
            root->left = left;
            rotate_right(root);
        }
        break;

        case core::state::balanced:
            root->balance = core::state::left_high;
            left->balance = core::state::right_high;
            rotate_right(root);
            break;
        }
    }

    inline void balance_right(heap_node*& root)
    {
        heap_node* right = root->right; // right subtree of root node

        switch (right->balance)
        {
        case core::state::right_high:
            root->balance = core::state::balanced;
            right->balance = core::state::balanced;
            rotate_left(root);
            break;

        case core::state::left_high:
        {
            heap_node* subleft = right->left; // left subtree of right
            switch (subleft->balance)
            {
            case core::state::balanced:
                root->balance = core::state::balanced;
                right->balance = core::state::balanced;
                break;

            case core::state::left_high:
                root->balance = core::state::balanced;
                right->balance = core::state::right_high;
                break;

            case core::state::right_high:
                root->balance = core::state::left_high;
                right->balance = core::state::balanced;
                break;
            }
            subleft->balance = core::state::balanced;
            rotate_right(right);
            root->right = right;
            rotate_left(root);
        }
        break;

        case core::state::balanced:
            root->balance = core::state::right_high;
            right->balance = core::state::left_high;
            rotate_left(root);
            break;
        }
    }

    inline void balance_tree(heap_node* root, unsigned long long from)
    {
        bool taller = true;

        while (taller)
        {
            heap_node* parent = root->parent;
            unsigned long long next_from = (parent->left == root) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    if (parent->is_header())
                        balance_left(parent->parent);
                    else if (parent->left == root)
                        balance_left(parent->left);
                    else
                        balance_left(parent->right);
                    taller = false;
                    break;

                case core::state::balanced:
                    root->balance = core::state::left_high;
                    taller = true;
                    break;

                case core::state::right_high:
                    root->balance = core::state::balanced;
                    taller = false;
                    break;
                }
            }
            else
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    root->balance = core::state::balanced;
                    taller = false;
                    break;

                case core::state::balanced:
                    root->balance = core::state::right_high;
                    taller = true;
                    break;

                case core::state::right_high:
                    if (parent->is_header())
                        balance_right(parent->parent);
                    else if (parent->left == root)
                        balance_right(parent->left);
                    else
                        balance_right(parent->right);
                    taller = false;
                    break;
                }
            }

            if (taller) // skip up a level
            {
                if (parent->is_header())
                    taller = false;
                else
                {
                    root = parent;
                    from = next_from;
                }
            }
        }
    }

    inline void balance_tree_remove(heap_node* root, unsigned long long from)
    {
        if (root->is_header()) return;

        bool shorter = true;

        while (shorter)
        {
            heap_node* parent = root->parent;
            unsigned long long next_from = (parent->left == root) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    root->balance = core::state::balanced;
                    shorter = true;
                    break;

                case core::state::balanced:
                    root->balance = core::state::right_high;
                    shorter = false;
                    break;

                case core::state::right_high:
                    if (root->right->balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;
                    if (parent->is_header())
                        balance_right(parent->parent);
                    else if (parent->left == root)
                        balance_right(parent->left);
                    else
                        balance_right(parent->right);
                    break;
                }
            }
            else
            {
                switch (root->balance)
                {
                case core::state::right_high:
                    root->balance = core::state::balanced;
                    shorter = true;
                    break;

                case core::state::balanced:
                    root->balance = core::state::left_high;
                    shorter = false;
                    break;

                case core::state::left_high:
                    if (root->left->balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;
                    if (parent->is_header())
                        balance_left(parent->parent);
                    else if (parent->left == root)
                        balance_left(parent->left);
                    else
                        balance_left(parent->right);
                    break;
                }
            }

            if (shorter)
            {
                if (parent->is_header())
                    shorter = false;
                else
                {
                    from = next_from;
                    root = parent;
                }
            }
        }
    }

    inline void swap_heap_node_reference(heap_node*& first, heap_node*& second)
    {
        heap_node* temporary = first; first = second; second = temporary;
    }

    inline void swap_heap_nodes(heap_node* A, heap_node* B)
    {
        if (B == A->left)
        {
            if (B->left) B->left->parent = A;
            if (B->right) B->right->parent = A;

            if (A->right) A->right->parent = B;

            if (!A->parent->is_header())
            {
                if (A->parent->left == A)
                    A->parent->left = B;
                else
                    A->parent->right = B;
            }
            else A->parent->parent = B;

            B->parent = A->parent;
            A->parent = B;

            A->left = B->left;
            B->left = A;

            swap_heap_node_reference(A->right, B->right);
        }
        else if (B == A->right)
        {
            if (B->right) B->right->parent = A;
            if (B->left) B->left->parent = A;

            if (A->left) A->left->parent = B;

            if (!A->parent->is_header())
            {
                if (A->parent->left == A)
                    A->parent->left = B;
                else
                    A->parent->right = B;
            }
            else A->parent->parent = B;

            B->parent = A->parent;
            A->parent = B;

            A->right = B->right;
            B->right = A;

            swap_heap_node_reference(A->left, B->left);
        }
        else if (A == B->left)
        {
            if (A->left) A->left->parent = B;
            if (A->right) A->right->parent = B;

            if (B->right) B->right->parent = A;

            if (!B->parent->is_header())
            {
                if (B->parent->left == B)
                    B->parent->left = A;
                else
                    B->parent->right = A;
            }
            else B->parent->parent = A;

            A->parent = B->parent;
            B->parent = A;

            B->left = A->left;
            A->left = B;

            swap_heap_node_reference(A->right, B->right);
        }
        else if (A == B->right)
        {
            if (A->right) A->right->parent = B;
            if (A->left) A->left->parent = B;

            if (B->left) B->left->parent = A;

            if (!B->parent->is_header())
            {
                if (B->parent->left == B)
                    B->parent->left = A;
                else
                    B->parent->right = A;
            }
            else B->parent->parent = A;

            A->parent = B->parent;
            B->parent = A;

            B->right = A->right;
            A->right = B;

            swap_heap_node_reference(A->left, B->left);
        }
        else
        {
            if (A->parent == B->parent)
                swap_heap_node_reference(A->parent->left, A->parent->right);
            else
            {
                if (!A->parent->is_header())
                {
                    if (A->parent->left == A)
                        A->parent->left = B;
                    else
                        A->parent->right = B;
                }
                else A->parent->parent = B;

                if (!B->parent->is_header())
                {
                    if (B->parent->left == B)
                        B->parent->left = A;
                    else
                        B->parent->right = A;
                }
                else B->parent->parent = A;
            }

            if (B->left)  B->left->parent = A;
            if (B->right) B->right->parent = A;

            if (A->left)  A->left->parent = B;
            if (A->right) A->right->parent = B;

            swap_heap_node_reference(A->left, B->left);
            swap_heap_node_reference(A->right, B->right);
            swap_heap_node_reference(A->parent, B->parent);
        }

        char balance = A->balance; A->balance = B->balance; B->balance = balance;
    }

    inline heap_node* fast_forward(heap_node* HN)
    {
        if (HN->is_header()) return HN->left;

        if (HN->right != 0)
        {
            HN = HN->right;
            while (HN->left != 0) HN = HN->left;
        }
        else
        {
            heap_node* y = HN->parent;
            if (y->is_header()) return y;
            while (HN == y->right) { HN = y; y = y->parent; }
            HN = y;
        }
        return HN;
    }

    inline heap_node* fast_reverse(heap_node* HN)
    {
        if (HN->is_header()) { return HN->right; }

        else if (HN->left != 0)
        {
            heap_node* y = HN->left;
            while (y->right != 0) y = y->right;
            HN = y;
        }
        else
        {
            heap_node* y = HN->parent;
            if (y->is_header()) return y;
            while (HN == y->left) { HN = y; y = y->parent; }
            HN = y;
        }
        return HN;
    }

    struct heap_tree
    {
        heap_node header;
        unsigned long long nodes;

        heap_tree()
        {
            nodes = 0;
            header.left = &header;
            header.right = &header;
            header.parent = 0;
            header.balance = core::state::header;
        }

        void initialize()
        {
            nodes = 0;
            header.left = &header;
            header.right = &header;
            header.parent = 0;
        }

        heap_node* below_equals(void* address)
        {
            heap_node* y = &header;
            heap_node* x = header.parent;

            while (x != 0)
                if (address == x)
                {
                    y = x; break;
                }
                else if (address < x)
                    x = x->left;
                else
                {
                    y = x; x = x->right;
                }

            if (y == &header)
                return 0;
            else
                return y;
        }

        bool add(heap_node* new_node,
            unsigned long long size,
            unsigned long long identity = 0)
        {
            new_node->left = 0;
            new_node->right = 0;
            new_node->balance = core::state::balanced;
            new_node->size = size;
            new_node->identity = (unsigned char)identity;

            if (header.parent == 0)
            {
                new_node->parent = &header;
                header.parent = new_node;
                header.left = new_node;
                header.right = new_node;
                nodes++;
                return true;
            }
            else
            {
                heap_node* root = header.parent;

                for (; ; )
                {
                    int compare = heap_comparer(new_node, root);

                    if (compare == 0) // Item Exists
                    {
                        return false;
                    }

                    else if (compare < 0)
                    {
                        if (root->left != 0)
                            root = root->left;
                        else
                        {
                            root->left = new_node;

                            new_node->parent = root;

                            if (header.left == root) header.left = new_node;

                            balance_tree(root, direction::from_left);

                            nodes++;
                            return true;
                        }
                    }

                    else
                    {
                        if (root->right != 0)
                            root = root->right;
                        else
                        {
                            root->right = new_node;

                            new_node->parent = root;

                            if (header.right == root) header.right = new_node;

                            balance_tree(root, direction::from_right);

                            nodes++;
                            return true;
                        }
                    }
                }
            }
        }

        void remove(heap_node* root)
        {
            // If left and right subtrees exist find previous
            // inorder node, swap nodes and continue

            if (root->left != 0 && root->right != 0)
            {
                heap_node* replace = root->left;
                while (replace->right != 0)
                    replace = replace->right;

                swap_heap_nodes(root, replace);

                heap_node* parent = root->parent;

                unsigned long long from = (parent->left == root) ? direction::from_left : direction::from_right;

                if (header.left == root)
                {
                    heap_node* e = fast_forward(root);

                    if (e->is_header())
                    {
                        header.left = &header; header.right = &header;
                    }
                    else
                        header.left = e;
                }
                else if (header.right == root)
                {
                    heap_node* e = fast_reverse(root);

                    if (e->is_header())
                    {
                        header.left = &header; header.right = &header;
                    }
                    else
                        header.right = e;
                }

                if (root->left == 0)
                {
                    if (parent == &header)
                        header.parent = root->right;
                    else if (parent->left == root)
                        parent->left = root->right;
                    else
                        parent->right = root->right;

                    if (root->right != 0) root->right->parent = parent;
                }
                else
                {
                    if (parent == &header)
                        header.parent = root->left;
                    else if (parent->left == root)
                        parent->left = root->left;
                    else
                        parent->right = root->left;

                    if (root->left != 0) root->left->parent = parent;
                }

                balance_tree_remove(parent, from);
                nodes--;
            }

            else // Either left or right SubTree is 0
            {
                heap_node* parent = root->parent;

                unsigned long long from = (parent->left == root) ? direction::from_left : direction::from_right;

                if (header.left == root)
                {
                    heap_node* e = fast_forward(root);

                    if (e->is_header())
                    {
                        header.left = &header; header.right = &header;
                    }
                    else
                        header.left = e;
                }
                else if (header.right == root)
                {
                    heap_node* e = fast_reverse(root);

                    if (e->is_header())
                    {
                        header.left = &header; header.right = &header;
                    }
                    else
                        header.right = e;
                }

                if (root->left == 0)
                {
                    if (parent == &header)
                        header.parent = root->right;
                    else if (parent->left == root)
                        parent->left = root->right;
                    else
                        parent->right = root->right;

                    if (root->right != 0) root->right->parent = parent;
                }
                else
                {
                    if (parent == &header)
                        header.parent = root->left;
                    else if (parent->left == root)
                        parent->left = root->left;
                    else
                        parent->right = root->left;

                    if (root->left != 0) root->left->parent = parent;
                }

                balance_tree_remove(parent, from);
                nodes--;
            }
        }

        void destroy()
        {
            destroy(header.parent);
        }

        void destroy(heap_node* root);

        unsigned long long size()
        {
            return size(header.parent);
        }

        unsigned long long size(heap_node* root)
        {
            if (root)
            {
                unsigned long long allocationsize = root->size;

                if (root->left)
                    allocationsize += size(root->left);

                if (root->right)
                    allocationsize += size(root->right);

                return allocationsize;
            }
            else
                return 0;
        }
    };

    struct pool
    {
        pool_node header;
        unsigned long long nodes;
        unsigned long long units;
        unsigned long long blocks;
        unsigned long long unit_size;
        unsigned char identity;
        heap_tree* allocation_tree;

        pool() {}

        pool(unsigned char q)
        {
            unit_size = quantum_size(q);
            identity = q + 1;
            nodes = 0;
            units = 0;
            blocks = 0;
            header.left = &header;
            header.right = &header;
            header.parent = 0;
            header.balance = core::state::header;
        }

        pool& operator=(unsigned char q)
        {
            unit_size = quantum_size(q);
            identity = q + 1;
            nodes = 0;
            blocks = 0;
            units = 0;
            header.left = &header;
            header.right = &header;
            header.parent = 0;
            header.balance = core::state::header;
            return *this;
        }

        void initialize()
        {
            nodes = 0;
            blocks = 0;
            units = 0;
            header.left = &header;
            header.right = &header;
            header.parent = 0;
        }

        unsigned long long get_units()
        {
            return units;
        }

        unsigned long long get_unit_size()
        {
            return unit_size + leading;
        }

        unsigned long long get_external_unit_size()
        {
            return unit_size + sizeof(pool_node);
        }

        pool& operator=(heap_tree* pointer)
        {
            allocation_tree = pointer;
            return *this;
        }

        void* allocate()
        {
            if (header.parent != 0)
            {
                pool_node* allocation_block = header.left;
                unsigned long long external_size = sizeof(pool_node) + unit_size;

                char* buffer = (char*)allocation_block;
                char* out_pointer = buffer + (allocation_block->units - 1) * external_size;
                allocation_block->units--;

                pool_node* node_out = (pool_node*)out_pointer;
                if (allocation_block->units == 0)
                {
                    remove(allocation_block);
                }
                else
                    node_out->is_block = 0;

                node_out->units = 1;
                node_out->identity = identity;

                units++;

                return (void*)((char*)(node_out + 1) - leading);
            }
            else
            {
                heap_node* new_block = (heap_node*)VirtAlloc(0, block_size, 0x00001000, 0x00000004);
                if (!allocation_tree->add(new_block, block_size, identity))
                {
                    VirtFree((void*)new_block);
                    return 0;
                }

                pool_node* allocation_block = (pool_node*)(new_block + 1);
                if (!allocation_block) return 0;
                allocation_block->is_block = 1;
                unsigned long long external_size = sizeof(pool_node) + unit_size;
                allocation_block->units = (ushort)((block_size - sizeof(heap_node)) / external_size);
                blocks++;

                char* buffer = (char*)allocation_block;
                char* out_pointer = buffer + (allocation_block->units - 1) * external_size;
                allocation_block->units--;

                pool_node* node_out = (pool_node*)out_pointer;
                node_out->units = 1;
                node_out->identity = identity;
                node_out->is_block = 0;

                allocation_block->balance = core::state::balanced; // add to tree at root
                header.parent = allocation_block;
                header.parent->parent = &header;
                header.left = header.parent;
                header.right = header.parent;

                units++;
                return (void*)((char*)(node_out + 1) - leading);
            }
        }

        bool free(void* Memory) // Performs Synchronous Garbage Collection
        {
            unsigned long long external_size = sizeof(pool_node) + unit_size;

            pool_node* node_free = ((pool_node*)(((char*)Memory) + leading)) - 1;

            if (node_free->is_block == 1)
            {
                if (!add(node_free)) return false;

                pool_node* after = fast_forward(node_free);
                if (!after->is_header() && after->is_block != 1 && (char*)node_free + external_size == (char*)after)
                {
                    node_free->units += after->units;
                    remove(after);

                    if (node_free->units == (block_size - sizeof(heap_node)) / external_size)
                    {
                        remove(node_free);
                        allocation_tree->remove(((heap_node*)node_free) - 1);
                        if (!VirtFree((void*)(((heap_node*)node_free) - 1)))
                        {
                            blocks--; units--; return false;
                        }
                        blocks--;
                    }
                }
            }
            else
            {
                pool_node* before = below(node_free);

                if (before != &header && (char*)before + before->units * external_size > (char*)node_free)
                    return false; // Already in heap's free list

                if (before == &header || (char*)before + before->units * external_size != (char*)node_free)
                { // before is non-contiguous

                    pool_node* after = fast_forward(before);
                    if (after == &header)
                        add(node_free);
                    else
                    {
                        if (after->is_block != 1 && (char*)node_free + external_size == (char*)after)
                        {
                            node_free->units += after->units;
                            remove(after);
                        }

                        if (node_free->units != (block_size - sizeof(heap_node)) / external_size)
                            add(node_free);
                        else
                        {
                            allocation_tree->remove(((heap_node*)node_free) - 1);
                            if (!VirtFree((void*)(((heap_node*)node_free) - 1))) { blocks--; units--; return false; }
                            blocks--;
                        }
                    }
                }
                else // before is contiguous
                {
                    before->units++;
                    pool_node* after = fast_forward(before);
                    if (after != &header && after->is_block != 1 && (char*)before + external_size * before->units == (char*)after)
                    {
                        before->units += after->units;
                        remove(after);
                    }

                    if (before->units == (block_size - sizeof(heap_node)) / external_size)
                    {
                        remove(before);
                        allocation_tree->remove(((heap_node*)before) - 1);
                        if (!VirtFree((void*)(((heap_node*)before) - 1)))
                        {
                            blocks--; units--; return false;
                        }
                        blocks--;
                    }
                }
            }

            units--;
            return true;
        }

        bool is_allocated(void* Memory)
        {
            unsigned long long external_size = sizeof(pool_node) + unit_size;

            pool_node* node_free = ((pool_node*)(((char*)Memory) + leading)) - 1;

            if (node_free->is_block == 1)
                return true;
            else
            {
                pool_node* before = below(node_free);

                if (before != &header && (char*)before + before->units * external_size > (char*)node_free)
                    return false; // Already in heap's free list

            }

            return true;
        }

        pool_node* below(pool_node* search_node)
        {
            pool_node* y = &header;
            pool_node* x = header.parent;

            while (x != 0)
                if (pool_comparer(search_node, x) <= 0)
                    x = x->left;
                else
                {
                    y = x; x = x->right;
                }

            return y;
        }

        bool add(pool_node* new_node)
        {
            new_node->left = 0;
            new_node->right = 0;
            new_node->balance = core::state::balanced;

            pool_node* root = header.parent;

            if (header.parent == 0)
            {
                new_node->parent = &header;
                header.parent = new_node;
                header.left = new_node;
                header.right = new_node;
                nodes++;
                return true;
            }
            else
            {
                for (; ; ) // Normal out of order processing
                {
                    int compare = pool_comparer(new_node, root);

                    if (compare == 0) // Item Exists
                        return false;

                    else if (compare < 0)
                    {
                        if (root->left != 0)
                            root = root->left;
                        else
                        {
                            root->left = new_node;
                            new_node->parent = root;
                            if (header.left == root) header.left = new_node;
                            balance_tree(root, direction::from_left);
                            nodes++;
                            return true;
                        }
                    }

                    else
                    {
                        if (root->right != 0)
                            root = root->right;
                        else
                        {
                            root->right = new_node;
                            new_node->parent = root;
                            if (header.right == root) header.right = new_node;
                            balance_tree(root, direction::from_right);
                            nodes++;
                            return true;
                        }
                    }
                }
            }
        }

        void remove(pool_node* root)
        {
            // If left and right subtrees exist find previous
            // inorder node, swap nodes and continue

            if (root->left != 0 && root->right != 0)
            {
                pool_node* replace = root->left;
                while (replace->right != 0)
                    replace = replace->right;

                swap_pool_nodes(root, replace);

                pool_node* parent = root->parent;

                unsigned long long from = (parent->left == root) ? direction::from_left : direction::from_right;

                if (header.left == root)
                {
                    pool_node* e = fast_forward(root);

                    if (e->is_header())
                    {
                        header.left = &header; header.right = &header;
                    }
                    else
                        header.left = e;
                }
                else if (header.right == root)
                {
                    pool_node* e = fast_reverse(root);

                    if (e->is_header())
                    {
                        header.left = &header; header.right = &header;
                    }
                    else
                        header.right = e;
                }

                if (root->left == 0)
                {
                    if (parent == &header)
                        header.parent = root->right;
                    else if (parent->left == root)
                        parent->left = root->right;
                    else
                        parent->right = root->right;

                    if (root->right != 0) root->right->parent = parent;
                }
                else
                {
                    if (parent == &header)
                        header.parent = root->left;
                    else if (parent->left == root)
                        parent->left = root->left;
                    else
                        parent->right = root->left;

                    if (root->left != 0) root->left->parent = parent;
                }

                balance_tree_remove(parent, from);
                nodes--;
            }

            else // Either left or right SubTree is 0
            {
                pool_node* parent = root->parent;

                unsigned long long from = (parent->left == root) ? direction::from_left : direction::from_right;

                if (header.left == root)
                {
                    pool_node* e = fast_forward(root);

                    if (e->is_header())
                    {
                        header.left = &header; header.right = &header;
                    }
                    else
                        header.left = e;
                }
                else if (header.right == root)
                {
                    pool_node* e = fast_reverse(root);

                    if (e->is_header())
                    {
                        header.left = &header; header.right = &header;
                    }
                    else
                        header.right = e;
                }

                if (root->left == 0)
                {
                    if (parent == &header)
                        header.parent = root->right;
                    else if (parent->left == root)
                        parent->left = root->right;
                    else
                        parent->right = root->right;

                    if (root->right != 0) root->right->parent = parent;
                }
                else
                {
                    if (parent == &header)
                        header.parent = root->left;
                    else if (parent->left == root)
                        parent->left = root->left;
                    else
                        parent->right = root->left;

                    if (root->left != 0) root->left->parent = parent;
                }

                balance_tree_remove(parent, from);
                nodes--;
            }
        }

        unsigned long long free_overhead()
        {
            return free_overhead(header.parent);
        }

        unsigned long long free_overhead(pool_node* root)
        {
            if (root)
            {
                unsigned long long size = root->units * small_unit_overhead;

                if (root->left)
                    size += free_overhead(root->left);

                if (root->right)
                    size += free_overhead(root->right);

                return size;
            }
            else
                return 0;
        }

        unsigned long long block_overhead()
        {
            unsigned long long external_size = sizeof(pool_node) + unit_size;
            unsigned long long units_per_block = (block_size - sizeof(heap_node)) / external_size;
            unsigned long long O = blocks * ((block_size - sizeof(heap_node)) - (units_per_block * external_size));
            return O;
        }

        unsigned long long overhead()
        {
            unsigned long long O = get_units() * small_unit_overhead;
            O += free_overhead();
            O += block_overhead();
            return O;
        }

        unsigned long long free_space()
        {
            return free_space(header.parent);
        }

        unsigned long long free_space(pool_node* root)
        {
            if (root)
            {
                unsigned long long size = root->units * (unit_size + leading);
                if (root->left) size += free_space(root->left);
                if (root->right) size += free_space(root->right);
                return size;
            }
            else
                return 0;
        }
    };

    struct heap : public semaphore
    {
        pool pool_array[number_of_pools];
        heap_tree allocation_tree;
        unsigned long long units;

        heap()
        {
            units = 0;
            for (unsigned long long i = 0; i < number_of_pools; i++) pool_array[i] = (unsigned char)i;
            for (unsigned long long i = 0; i < number_of_pools; i++) pool_array[i] = &allocation_tree;
        }

        void* allocate(size_t amount)
        {
            if (!amount) return 0;

            request();

            if (amount > boundaries[number_of_pools - 1] + leading)
            {
                size_t new_size = (size_t)round_up(amount + sizeof(heap_node) + sizeof(pool_node) - leading, 4096);
                heap_node* heap_block = (heap_node*)VirtAlloc(0, new_size, 0x00001000, 0x00000004);
                allocation_tree.add(heap_block, new_size);
                pool_node* allocation_block = (pool_node*)(heap_block + 1);
                allocation_block->identity = 0;
                units++;
                release();
                return (void*)((char*)(allocation_block + 1) - leading);
            }
            else
            {
                unsigned long long Quantum = quantum_from_size(amount);
                void* allocated = pool_array[Quantum].allocate();
                release();
                return allocated;
            }
        }

        unsigned long long allocation()
        {
            request();
            unsigned long long allocation = allocation_tree.size() - overhead() - free_space();
            release();
            return allocation;
        }

        void destroy()
        {
            request();
            allocation_tree.destroy();
            release();
        }

        void empty()
        {
            request();
            allocation_tree.destroy();
            allocation_tree.initialize();
            for (unsigned long long i = 0; i < number_of_pools; i++) pool_array[i].initialize();
            units = 0;
            release();
        }

        bool free(void* pointer, bool bypass_checks = false)
        {
            if (pointer == 0) return true;

            if ((unsigned long long)pointer % 8 != 0) return false;  // Check for alignment

            request();

            pool_node* node = (pool_node*)((char*)pointer + leading) - 1;
            heap_node* hnode = ((heap_node*)node) - 1;

            // Perform Checking

            if (!bypass_checks)
            {
                heap_node* node_below = allocation_tree.below_equals(hnode);
                if (!node_below) { release(); return false; }
                if ((char*)node_below + node_below->size < pointer) { release(); return false; }
                if (node_below->identity != node->identity) { release(); return false; }
                if (node->identity == 0)
                {
                    if (node_below != hnode) { release(); return false; }
                }
                else
                {
                    unsigned long long external_size = pool_array[node->identity - 1].get_external_unit_size();
                    if (((char*)node - ((char*)node_below + sizeof(heap_node))) % external_size != 0) { release(); return false; }
                }
            }

            // Passed Checks - Now free

            bool success = false;

            if (node->identity == 0)
            {
                allocation_tree.remove(hnode);
                success = VirtFree((void*)hnode);
                units--;
            }
            else
                success = pool_array[node->identity - 1].free(pointer);

            release();
            return success;
        }

        unsigned long long free_space()
        {
            request();
            unsigned long long size = 0;
            for (unsigned long long i = 0; i < number_of_pools; i++) size += pool_array[i].free_space();
            release();
            return size;
        }

        unsigned long long get_units()
        {
            request();
            unsigned long long allocated_units = units;
            for (unsigned long long i = 0; i < number_of_pools; i++) allocated_units += pool_array[i].get_units();
            release();
            return allocated_units;
        }

        unsigned long long get_unit_size(void* pointer)
        {
            if (pointer == 0) return 0;

            request();

            pool_node* node = (pool_node*)((char*)pointer + leading) - 1;
            heap_node* hnode = ((heap_node*)node) - 1;

            // Perform Checking

            heap_node* node_below = allocation_tree.below_equals(hnode);
            if (!node_below) { release(); return 0; }
            if ((char*)node_below + node_below->size < pointer) { release(); return 0; }
            if (node_below->identity != node->identity) { release(); return 0; }
            if (node->identity == 0)
            {
                if (node_below != hnode) { release(); return 0; }
                unsigned long long size = hnode->size - sizeof(heap_node) - sizeof(pool_node) + leading;
                release();
                return size;
            }
            else
            {
                if (node->identity > number_of_pools) { release(); return 0; }
                unsigned long long external_size = pool_array[node->identity - 1].get_external_unit_size();
                if (((char*)node - ((char*)node_below + sizeof(heap_node))) % external_size != 0) { release(); return 0; }
            }

            unsigned long long size = pool_array[node->identity - 1].get_unit_size();
            release();
            return size;
        }

        unsigned long long overhead()
        {
            request();
            unsigned long long O = units * large_unit_overhead + (allocation_tree.nodes - units) * block_overhead;
            for (unsigned long long i = 0; i < number_of_pools; i++) O += pool_array[i].overhead();
            release();
            return O;
        }

        unsigned long long query_pointer(void* pointer)
        {
            if (pointer == 0) return pointer_status::not_in_heap;

            if ((unsigned long long)pointer % 8 != 0) return pointer_status::not_aligned;  // Check for alignment

            request();

            pool_node* node = (pool_node*)((char*)pointer + leading) - 1;
            heap_node* hnode = ((heap_node*)node) - 1;

            // Perform Checking

            heap_node* node_below = allocation_tree.below_equals(hnode);
            if (!node_below) { release(); return pointer_status::not_in_heap; }
            if ((char*)node_below + node_below->size < pointer) { release(); return pointer_status::not_in_heap; }
            if (node_below->identity != node->identity) { release(); return pointer_status::identity_invalid; }
            if (node->identity == 0)
            {
                if (node_below != hnode) { release(); return pointer_status::not_aligned; }
            }
            else
            {
                unsigned long long external_size = pool_array[node->identity - 1].get_external_unit_size();
                if (((char*)node - ((char*)node_below + sizeof(heap_node))) % external_size != 0) { release(); return pointer_status::not_aligned; }
            }

            bool allocated = pool_array[node->identity - 1].is_allocated(pointer);

            release();

            if (allocated) return pointer_status::allocated; else return pointer_status::free;
        }

        unsigned long long size()
        {
            request();
            unsigned long long size = allocation_tree.size();
            release();
            return size;
        }
    };

    heap global_heap;

    export unsigned long long get_heap_control_block_size()
    {
        return sizeof(heap);
    }

    export void request_heap()
    {
        global_heap.request();
    }

    export bool release_heap()
    {
        return global_heap.release();
    }

    export void* allocate_from_heap(unsigned long long size)
    {
        return global_heap.allocate(size);
    }

    export bool free_from_heap(void* Memory)
    {
        return global_heap.free(Memory);
    }

    export void set_heap_bit(void* memory_pointer, unsigned long long ophset)
    {
        long long* pointer_memory = (long long*)memory_pointer;
        long long word_ophset = ophset / 64;
        long long* pointer_word = pointer_memory + word_ophset;
        long long bit_ophset = ophset % 64;
        long long one = 1;
        one <<= bit_ophset;
        *pointer_word |= one;
    }

    export void clear_heap_bit(void* memory_pointer, unsigned long long ophset)
    {
        long long* pointer_memory = (long long*)memory_pointer;
        long long word_ophset = ophset / 64;
        long long* pointer_word = pointer_memory + word_ophset;
        long long bit_ophset = ophset % 64;
        long long one = 1;
        one <<= bit_ophset;
        long long mask = 0xffffffffffffffff;
        mask &= bit_ophset;
        *pointer_word ^= one;
    }

    export bool get_heap_bit(void* memory_pointer, unsigned long long ophset)
    {
        long long* pointer_memory = (long long*)memory_pointer;
        long long word_ophset = ophset / 64;
        long long* pointer_word = pointer_memory + word_ophset;
        long long bit_ophset = ophset % 64;
        long long one = 1;
        one <<= bit_ophset;
        long long mask = 0xffffffffffffffff;
        mask &= bit_ophset;
        return *pointer_word & one;
    }

    export unsigned long long query_heap_word(void* memory_pointer, unsigned long long ophset)
    {
        long long* pointer_memory = (long long*)memory_pointer;
        long long word_ophset = ophset / 64;
        long long* pointer_word = pointer_memory + word_ophset;
        return *pointer_word;
    }

    export bool fast_free_from_heap(void* Memory)
    {
        return global_heap.free(Memory, true);
    }

    export unsigned long long query_heap_pointer(void* Memory)
    {
        return global_heap.query_pointer(Memory);
    }

    export unsigned long long get_heap_size()
    {
        return global_heap.size();
    }

    export unsigned long long get_heap_free_space()
    {
        return global_heap.free_space();
    }

    export unsigned long long get_heap_units()
    {
        return global_heap.get_units();
    }

    export unsigned long long get_heap_overhead()
    {
        return global_heap.overhead();
    }

    export unsigned long long get_heap_allocation()
    {
        return global_heap.allocation();
    }

    export unsigned long long get_heap_unit_size(void* unit)
    {
        return global_heap.get_unit_size(unit);
    }

//    export template <class character>
//        inline int compare_strings(const character* p, const character* q)
//    {
//        while (*p && *p == *q) { p++; q++; }
//        if (*p < *q) return -1;
//        if (*q < *p) return 1;
//        return 0;
//    }

//    export template <class character>
//        inline character* copy_string(character* p, const character* q)
//    {
//        character* string = p;
//        while (*q)
//        {
//            *p = *q;
//            p++;
//            q++;
//        }
//        *p = 0;
//        return string;
//    }

//    export template <class character>
//        inline character* concatenate_strings(character* p, const character* q)
//    {
//        character* string = p; while (*p) p++; while (*p++ = *q++); return string;
//    }

//    export template <class character>
//        inline long long string_length(const character* string)
//    {
//        long long l = 0;
//        while (*string)
//        {
//            l++;
//            string++;
//        }
//        return l;
//    }

    export template <class character>
        inline void reverse_string(character* to_reverse)
    {
        if (to_reverse)
        {
            character* start = to_reverse;
            character* end = start + (string_length(to_reverse) - 1);

            while (end - start > 0)
            {
                character c(*start);
                *start = *end;
                *end = c;
                start++; end--;
            }
        }
    }

    export template <class character>
        struct gsubstring
    {
        long long l;
        character* p;

        gsubstring() : l(0), p(0) {}

        gsubstring(character* c) : p(c), l(c ? string_length(c) : 0) {}

        gsubstring(character* pointer, long long length) : l(length), p(pointer) {}

        gsubstring(character* base, long long first, long long last)
            : l(first <= last ? last - first + 1 : first - last + 1),
            p(first <= last ? base + first : base + last) {}

        character& operator[](long long i)
        {
            return *(p + i);
        }

        long long length() const { return l; }

        operator const character* () const { return p; }

        operator character* () { return p; }

        gsubstring operator()(long long first, long long last) { return gsubstring(p, first, last); }

        gsubstring& operator=(character c)
        {
            long long index = 0;
            while (index < length())
            {
                p[index] = c;
                index++;
            }
            return *this;
        }

        gsubstring& operator=(const character* a)
        {
            long long i = 0;
            while (i < l && a[i])
            {
                p[i] = a[i]; i++;
            }
            while (i < l)
            {
                p[i] = '\0'; i++;
            }
            return *this;
        }

        gsubstring& operator=(const gsubstring& a)
        {
            if (this != &a)
            {
                if (a.length() && length())
                {
                    long long l_minimum = a.length() < length() ?
                        a.length() : length();

                    if (p + l_minimum < a.p ||
                        p - l_minimum > a.p)
                    {
                        long long uindex = l_minimum;
                        while (uindex--) p[uindex] = a.p[uindex];
                    }
                    else // overlapping
                    {
                        character* NewString = new character[l_minimum];
                        long long uindex = l_minimum;
                        while (uindex--) NewString[uindex] = a.p[uindex];
                        uindex = l_minimum;
                        while (uindex--) p[uindex] = NewString[uindex];
                        delete[] NewString;
                    }
                }
            }
            return *this;
        }

        gsubstring& operator<<(const gsubstring& c) { l = c.length(); p = c.p; return *this; }
    };

    export template <class character>
        struct gstring_iterator
    {
        const character* str;

        gstring_iterator(const character* i) : str(i) {}

        character operator*() const { return *str; }

        gstring_iterator operator++()
        {
            str++;
            return *this;
        }

        gstring_iterator& operator++(int)
        {
            str++;
            return *this;
        }

        bool operator==(const gstring_iterator& si)
        {
            return str == si.str;
        }

        bool operator!=(const gstring_iterator& si)
        {
            return str != si.str;
        }
    };

    export template <class character>
        struct gstring
    {
        character* s;

        typedef gstring_iterator<character> iterator;

        void* operator new(size_t s) { return allocate_from_heap(s); }

        void operator delete(void* p) { free_from_heap(p); }

        gstring()
        {
            s = (character*)allocate_from_heap(2);
            *s = 0;
        }

        gstring(const char* copy)
        {
            s = (character*)0;
            if (copy)
            {
                int i = 0; while (copy[i]) i++;
                s = (character*)allocate_from_heap(sizeof(character) * (i + 1));
                for (int j = 0; j < i; j++) s[j] = copy[j];
                s[i] = 0;
            }
        }

        gstring(const wchar_t* copy)
        {
            s = (character*)0;
            if (copy)
            {
                int i = 0; while (copy[i]) i++;
                s = (character*)allocate_from_heap(sizeof(character) * (i + 1));
                for (int j = 0; j < i; j++) s[j] = copy[j];
                s[i] = 0;
            }
        }

        gstring(long long new_size) : s((character*)allocate_from_heap(sizeof(character)* (new_size + 1))) {}

        gstring(const gsubstring<character>& ss)
        {
            s = (character*)0;
            long long length = ss.length();
            if (length)
            {
                s = (character*)allocate_from_heap(sizeof(character) * (length + 1));
                for (int i = 0; i < length; i++) s[i] = ss.p[i];
                s[length] = '\0';
            }
        }

        gstring(const gstring& c)
        {
            s = 0;
            if (c.s)
            {
                s = (character*)allocate_from_heap(sizeof(character) * (string_length<character>(c.s) + 1));
                copy_string<character>(s, c.s);
            }
        }

        ~gstring() { if (s) free_from_heap(s); }

        long long length() const { if (s) return string_length<character>(s); else return 0; }

        gstring& operator=(const character* cs)
        {
            if (s) free_from_heap(s);
            s = 0;
            if (cs)
            {
                s = (character*)allocate_from_heap(sizeof(character) * (string_length(cs) + 1));
                copy_string(s, cs);
            }
            return *this;
        }

        gstring& operator=(long long n)
        {
            if (s) free_from_heap(s);
            s = (character*)allocate_from_heap(sizeof(character) * (n + 1));
            return *this;
        }

        iterator begin() const
        {
            return iterator(s);
        }

        iterator end() const
        {
            character* e = s;
            while (*e) e++;
            return iterator(e);
        }

        long long count(character c) const
        {
            long long co = 0;
            character* t = s;
            while (*t) { if (*t == c) co++; t++; }
            return co;
        }

        void push(character c)
        {
            character ch[2];
            ch[0] = c;
            ch[1] = 0;
            *this += ch;
        }

        gstring& operator+=(const character* cs)
        {
            long long lcs = string_length(cs);

            if (!lcs) return *this;

            long long ls = s ? string_length(s) : 0;
            character* ns = (character*)allocate_from_heap(sizeof(character) * (ls + lcs + 1));

            if (s)
            {
                copy_string(ns, s);
                concatenate_strings(ns, cs);
                free_from_heap(s);
            }
            else
                copy_string(ns, cs);

            s = ns;
            return *this;
        }

        character& operator[](long long index) const
        {
            return *(s + index);
        }

        operator character* () const { return s; }

        gstring& operator=(const gstring& a)
        {
            if (s) free_from_heap(s);
            s = 0;
            if (a)
            {
                s = (character*)allocate_from_heap(sizeof(character) * (a.length() + 1));
                copy_string<character>(s, a.s);
            }
            return *this;
        }

        void concat(const character* cs)
        {
            *this += cs;
        }

        void reverse()
        {
            reverse_string(s);
        }
    };

    export typedef gstring<wchar_t> string;
    export typedef gsubstring<wchar_t> substring;

    export typedef gsubstring<char> subseries;
    export typedef gstring<char> series;

    export template <class character>
        int compare_strings(const gstring<character>& a, const gstring<character>& b)
    {
        const character* p = a;
        const character* q = b;
        while (*p && *p == *q) { p++; q++; }
        if (*p < *q) return -1;
        if (*q < *p) return 1;
        return 0;
    }

    export template<class character> inline bool operator==(const gstring<character>& a, const gstring<character>& b) { return (bool)(compare_strings(a, b) == 0); }
    export template<class character> inline bool operator!=(const gstring<character>& a, const gstring<character>& b) { return (bool)(compare_strings(a, b) != 0); }

    export inline bool operator<(const string& a, const string& b) { return (bool)(compare_strings(a, b) < 0); }
    export inline bool operator<=(const string& a, const string& b) { return (bool)(compare_strings(a, b) <= 0); }
    export inline bool operator>(const string& a, const string& b) { return (bool)(compare_strings(a, b) > 0); }
    export inline bool operator>=(const string& a, const string& b) { return (bool)(compare_strings(a, b) >= 0); }

    export inline bool operator<(const series& a, const series& b) { return (bool)(compare_strings(a, b) < 0); }
    export inline bool operator<=(const series& a, const series& b) { return (bool)(compare_strings(a, b) <= 0); }
    export inline bool operator>(const series& a, const series& b) { return (bool)(compare_strings(a, b) > 0); }
    export inline bool operator>=(const series& a, const series& b) { return (bool)(compare_strings(a, b) >= 0); }

    export template <class character>
        gstring<character> operator+(const character* a, const gstring<character>& b)
    {
        long long lb = b.length();
        gstring<character> result(string_length(a) + lb);
        copy_string(result.s, a);
        if (lb) concatenate_strings<character>(result.s, b);
        return result;
    }

    export template <class character>
        gstring<character> operator+(const gstring<character>& a, const character* b)
    {
        long long la = a.length();
        gstring<character> result(la + string_length<character>(b));
        if (la)
        {
            copy_string<character>(result.s, a.s);
            concatenate_strings<character>(result.s, b);
        }
        else
            copy_string<character>(result.s, b);
        return result;
    }

    export template <class character>
        gstring<character> operator+(const gstring<character>& a, const gstring<character>& b)
    {
        long long la = a.length();
        long long lb = b.length();
        long long length = la + lb;
        if (length)
        {
            gstring<character> result(length);
            if (la)
            {
                copy_string<character>(result.s, a.s);
                if (lb) concatenate_strings<character>(result.s, b.s);
            }
            else
                copy_string<character>(result.s, b.s);
            return result;
        }
        else
            return gstring<character>((character*)"");
    }

    export struct standard_exception
    {
        string description;

        standard_exception(const string& sin) : description(sin) { }

        operator string() const { return description; }
    };

    export struct month_is_invalid_exception : public standard_exception
    {
        month_is_invalid_exception() : standard_exception((const character*)L"Month is invalid.") {}
    };

    export struct day_of_month_is_invalid_exception : public standard_exception
    {
        day_of_month_is_invalid_exception() : standard_exception((const character*)L"Day of month is invalid.") {}
    };

    export struct julian_day_is_invalid_exception : public standard_exception
    {
        julian_day_is_invalid_exception() : standard_exception((const character*)L"Julian day is invalid.") {}
    };

    export struct allocation_failed_exception : public standard_exception
    {
        allocation_failed_exception() : standard_exception((const character*)L"Memory allocation failed.") {}
    };

    export struct free_failed_exception : public standard_exception
    {
        free_failed_exception() : standard_exception((const character*)L"Memory freeing failed.") {}
    };

    export struct entry_already_exists_exception : public standard_exception
    {
        entry_already_exists_exception() : standard_exception((const character*)L"Entry already contains.") {}
    };

    export struct entry_not_found_exception : public standard_exception
    {
        entry_not_found_exception() : standard_exception((const character*)L"Entry not found.") {}
    };

    export struct invalid_set_operation_exception : public standard_exception
    {
        invalid_set_operation_exception() : standard_exception((const character*)L"The specified set operation is invalid for the function.") {}
    };

    export struct is_header_exception : public standard_exception
    {
        is_header_exception() : standard_exception((const character*)L"An invalid operation was atttempted on a header node.") {}
    };

    export struct bitset_length_exceeded_exception : public standard_exception
    {
        bitset_length_exceeded_exception() : standard_exception((const character*)L"The length of the bitset was exceeded.") {}
    };

    export struct bitset_length_mismatch_exception : public standard_exception
    {
        bitset_length_mismatch_exception() : standard_exception((const character*)L"The lengths of the bitsets were mismatched.") {}
    };

    export struct invalid_parameter_exception : public standard_exception
    {
        invalid_parameter_exception() : standard_exception((const character*)L"A paramter is invalid.") {}
    };

    export struct bitset_too_long_exception : public standard_exception
    {
        bitset_too_long_exception() : standard_exception((const character*)L"The bitset is too long.") {}
    };

    export struct is_list_tail_exception : public standard_exception
    {
        is_list_tail_exception() : standard_exception((const character*)L"Is the list tail.") {}
    };

    export struct node
    {
        node* left;
        node* right;
        node* parent;
        char balance;

        node()
        {
            balance = core::state::header;
            left = this;
            right = this;
            parent = 0;
        }

        node(node* parent_set)
        {
            balance = core::state::balanced;
            left = 0;
            right = 0;
            parent = parent_set;
        }

        bool is_header() const { return !balance; }

        void* operator new(size_t s) { return allocate_from_heap(s); }

        void operator delete(void* p) { free_from_heap(p); }
    };


    inline node* minimum(node* node)
    {
        while (node->left) node = node->left;
        return node;
    }

    inline node* maximum(node* node)
    {
        while (node->right) node = node->right;
        return node;
    }

    inline void swap_node_reference(node*& first, node*& second)
    {
        node* temporary = first; first = second; second = temporary;
    }

    inline void swap_nodes(node* A, node* B)
    {
        if (B == A->left)
        {
            if (B->left) B->left->parent = A;
            if (B->right) B->right->parent = A;

            if (A->right) A->right->parent = B;

            if (!A->parent->is_header())
            {
                if (A->parent->left == A)
                    A->parent->left = B;
                else
                    A->parent->right = B;
            }
            else A->parent->parent = B;

            B->parent = A->parent;
            A->parent = B;

            A->left = B->left;
            B->left = A;

            swap_node_reference(A->right, B->right);
        }
        else if (B == A->right)
        {
            if (B->right) B->right->parent = A;
            if (B->left) B->left->parent = A;

            if (A->left) A->left->parent = B;

            if (!A->parent->is_header())
            {
                if (A->parent->left == A)
                    A->parent->left = B;
                else
                    A->parent->right = B;
            }
            else A->parent->parent = B;

            B->parent = A->parent;
            A->parent = B;

            A->right = B->right;
            B->right = A;

            swap_node_reference(A->left, B->left);
        }
        else if (A == B->left)
        {
            if (A->left) A->left->parent = B;
            if (A->right) A->right->parent = B;

            if (B->right) B->right->parent = A;

            if (!B->parent->is_header())
            {
                if (B->parent->left == B)
                    B->parent->left = A;
                else
                    B->parent->right = A;
            }
            else B->parent->parent = A;

            A->parent = B->parent;
            B->parent = A;

            B->left = A->left;
            A->left = B;

            swap_node_reference(A->right, B->right);
        }
        else if (A == B->right)
        {
            if (A->right) A->right->parent = B;
            if (A->left) A->left->parent = B;

            if (B->left) B->left->parent = A;

            if (!B->parent->is_header())
            {
                if (B->parent->left == B)
                    B->parent->left = A;
                else
                    B->parent->right = A;
            }
            else B->parent->parent = A;

            A->parent = B->parent;
            B->parent = A;

            B->right = A->right;
            A->right = B;

            swap_node_reference(A->left, B->left);
        }
        else
        {
            if (A->parent == B->parent)
                swap_node_reference(A->parent->left, A->parent->right);
            else
            {
                if (!A->parent->is_header())
                {
                    if (A->parent->left == A)
                        A->parent->left = B;
                    else
                        A->parent->right = B;
                }
                else A->parent->parent = B;

                if (!B->parent->is_header())
                {
                    if (B->parent->left == B)
                        B->parent->left = A;
                    else
                        B->parent->right = A;
                }
                else B->parent->parent = A;
            }

            if (B->left)  B->left->parent = A;
            if (B->right) B->right->parent = A;

            if (A->left)  A->left->parent = B;
            if (A->right) A->right->parent = B;

            swap_node_reference(A->left, B->left);
            swap_node_reference(A->right, B->right);
            swap_node_reference(A->parent, B->parent);
        }

        unsigned balance = A->balance;
        A->balance = B->balance;
        B->balance = balance;
    }

    inline void rotate_left(node*& root)
    {
        node* parent = root->parent;
        node* x = root->right;
        root->parent = x;
        x->parent = parent;
        if (x->left) x->left->parent = root;
        root->right = x->left;
        x->left = root;
        root = x;
    }

    inline void rotate_right(node*& root)
    {
        node* parent = root->parent;
        node* x = root->left;
        root->parent = x;
        x->parent = parent;
        if (x->right) x->right->parent = root;
        root->left = x->right;
        x->right = root;
        root = x;
    }

    inline void balance_left(node*& root)
    {
        node* left = root->left; // left Subtree of root node

        switch (left->balance)
        {
        case core::state::left_high:
            root->balance = core::state::balanced;
            left->balance = core::state::balanced;
            rotate_right(root);
            break;

        case core::state::right_high:
        {
            node* subright = left->right;  // right subtree of left
            switch (subright->balance)
            {
            case core::state::balanced:
                root->balance = core::state::balanced;
                left->balance = core::state::balanced;
                break;

            case core::state::right_high:
                root->balance = core::state::balanced;
                left->balance = core::state::left_high;
                break;

            case core::state::left_high:
                root->balance = core::state::right_high;
                left->balance = core::state::balanced;
                break;
            }
            subright->balance = core::state::balanced;
            rotate_left(left);
            root->left = left;
            rotate_right(root);
        }
        break;

        case core::state::balanced:
            root->balance = core::state::left_high;
            left->balance = core::state::right_high;
            rotate_right(root);
            break;
        }
    }

    inline void balance_right(node*& root)
    {
        node* right = root->right; // right Subtree of root node

        switch (right->balance)
        {
        case core::state::right_high:
            root->balance = core::state::balanced;
            right->balance = core::state::balanced;
            rotate_left(root);
            break;

        case core::state::left_high:
        {
            node* subleft = right->left; // left Subtree of right
            switch (subleft->balance)
            {
            case core::state::balanced:
                root->balance = core::state::balanced;
                right->balance = core::state::balanced;
                break;

            case core::state::left_high:
                root->balance = core::state::balanced;
                right->balance = core::state::right_high;
                break;

            case core::state::right_high:
                root->balance = core::state::left_high;
                right->balance = core::state::balanced;
                break;
            }
            subleft->balance = core::state::balanced;
            rotate_right(right);
            root->right = right;
            rotate_left(root);
        }
        break;

        case core::state::balanced:
            root->balance = core::state::right_high;
            right->balance = core::state::left_high;
            rotate_left(root);
            break;
        }
    }

    inline void balance_tree(node* root, unsigned long long from)
    {
        bool taller = true;

        while (taller)
        {
            node* parent = root->parent;
            unsigned long long next_from = (parent->left == root) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    if (parent->is_header())
                        balance_left(parent->parent);
                    else if (parent->left == root)
                        balance_left(parent->left);
                    else
                        balance_left(parent->right);
                    taller = false;
                    break;

                case core::state::balanced:
                    root->balance = core::state::left_high;
                    taller = true;
                    break;

                case core::state::right_high:
                    root->balance = core::state::balanced;
                    taller = false;
                    break;
                }
            }
            else
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    root->balance = core::state::balanced;
                    taller = false;
                    break;

                case core::state::balanced:
                    root->balance = core::state::right_high;
                    taller = true;
                    break;

                case core::state::right_high:
                    if (parent->is_header())
                        balance_right(parent->parent);
                    else if (parent->left == root)
                        balance_right(parent->left);
                    else
                        balance_right(parent->right);
                    taller = false;
                    break;
                }
            }

            if (taller) // skip up a level
            {
                if (parent->is_header())
                    taller = false;
                else
                {
                    root = parent;
                    from = next_from;
                }
            }
        }
    }

    inline void balance_tree_remove(node* root, unsigned long long from)
    {
        if (root->is_header()) return;
        bool shorter = true;

        while (shorter)
        {
            node* parent = root->parent;
            unsigned long long next_from = (parent->left == root) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (root->balance)
                {
                case core::state::left_high:
                    root->balance = core::state::balanced;
                    shorter = true;
                    break;

                case core::state::balanced:
                    root->balance = core::state::right_high;
                    shorter = false;
                    break;

                case core::state::right_high:
                    if (root->right->balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;
                    if (parent->is_header())
                        balance_right(parent->parent);
                    else if (parent->left == root)
                        balance_right(parent->left);
                    else
                        balance_right(parent->right);
                    break;
                }
            }
            else
            {
                switch (root->balance)
                {
                case core::state::right_high:
                    root->balance = core::state::balanced;
                    shorter = true;
                    break;

                case core::state::balanced:
                    root->balance = core::state::left_high;
                    shorter = false;
                    break;

                case core::state::left_high:
                    if (root->left->balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;
                    if (parent->is_header())
                        balance_left(parent->parent);
                    else if (parent->left == root)
                        balance_left(parent->left);
                    else
                        balance_left(parent->right);
                    break;
                }
            }

            if (shorter)
            {
                if (parent->is_header())
                    shorter = false;
                else
                {
                    from = next_from;
                    root = parent;
                }
            }
        }
    }

    export inline void adjust_add(node* root)
    {
        node* header = root->parent;
        while (!header->is_header()) header = header->parent;

        if (root->parent->left == root)
        {
            balance_tree(root->parent, direction::from_left);
            if (header->left == root->parent) header->left = root;
        }
        else
        {
            balance_tree(root->parent, direction::from_right);
            if (header->right == root->parent) header->right = root;
        }
    }

    export inline void adjust_remove(node* parent, unsigned long long direction)
    {
        balance_tree_remove(parent, direction);

        node* header = parent;
        while (!header->is_header()) header = header->parent;

        if (header->parent == 0)
        {
            header->left = header;
            header->right = header;
        }
        else
        {
            header->left = minimum(header->parent);
            header->right = maximum(header->parent);
        }
    }

    export inline unsigned long long depth(const node* root)
    {
        if (root)
        {
            unsigned long long left = root->left ? depth(root->left) : 0;
            unsigned long long right = root->right ? depth(root->right) : 0;
            return left < right ? right + 1 : left + 1;
        }
        else
            return 0;
    }

    export inline unsigned long long count(const node* root)
    {
        if (root)
        {
            unsigned long long left = root->left ? count(root->left) : 0;
            unsigned long long right = root->right ? count(root->right) : 0;
            return left + right + 1;
        }
        else
            return 0;
    }
    export inline node* previous_item(node* _node)
    {
        if (_node->is_header()) { return _node->right; }

        else if (_node->left != 0)
        {
            node* y = _node->left;
            while (y->right != 0) y = y->right;
            _node = y;
        }
        else
        {
            node* y = _node->parent;
            if (y->is_header()) return y;
            while (_node == y->left) { _node = y; y = y->parent; }
            _node = y;
        }
        return _node;
    }

    export inline node* next_item(node* _node)
    {
        if (_node->is_header()) return _node->left;

        if (_node->right != 0)
        {
            _node = _node->right;
            while (_node->left != 0) _node = _node->left;
        }
        else
        {
            node* y = _node->parent;
            if (y->is_header()) return y;
            while (_node == y->right) { _node = y; y = y->parent; }
            _node = y;
        }
        return _node;
    }

    export template<class t>
        struct list_node
    {
        list_node<t>* next;
        t data;

        list_node(const t& data_set) : data(data_set) {}

        void* operator new(size_t s) { return allocate_from_heap(s); }

        void operator delete(void* p) { free_from_heap(p); }
    };

    export template<class t>
        struct list_header
    {
        list_node<t>* next;
    };

    export template <class t, class compare>
        inline list_node<t>* merge(list_node<t>* first, list_node<t>* second)
    {
        list_node<t>* a = first->next;
        list_node<t>* b = second->next;

        list_node<t>* head;
        list_node<t>* tail;

        enum { list_end_none, list_end_a, list_end_b } list_end = list_end_none;

        if (compare()(a->data, b->data) <= 0)
        {
            head = tail = a;
            a = a->next;
            if (a == first->next) list_end = list_end_a;
        }
        else
        {
            head = tail = b;
            b = b->next;
            if (b == second->next) list_end = list_end_b;
        }

        while (list_end == list_end_none)
        {
            if (compare()(a->data, b->data) <= 0)
            {
                tail->next = a;
                tail = a;
                a = a->next;
                if (a == first->next) list_end = list_end_a;
            }
            else
            {
                tail->next = b;
                tail = b;
                b = b->next;
                if (b == second->next) list_end = list_end_b;
            }
        }
        if (list_end == list_end_a)
        {
            tail->next = b;
            second->next = head;
            return second;
        }
        else
        {
            tail->next = a;
            first->next = head;
            return first;
        }
    }

    template <class t, class compare = core::compare<t>>
    list_node<t>* merge_sort(list_node<t>* root)     // non-recursive merge sort
    {
        list_node<t>* sublist[64];

        unsigned long long c = 0;

        list_node<t>* p = root;                    // first unsorted Item

        do
        {
            c++;
            long long merge_count = Power2(c);
            list_node<t>* q = p;                  // tail of partial (merged) list.
            p = p->next;
            q->next = q;                                  // q is a sublist of size 1.
            for (long long i = 0; i < merge_count; i++)
                q = merge<t, compare>(q, sublist[i]);
            sublist[merge_count] = q;
        } while (p != root);

        long long merge_count = -1;

        while (c)
        {
            long long d = c % 2;
            c /= 2;
            merge_count++;
            if (d)
                if (p == root)
                    p = sublist[merge_count];
                else
                    p = merge<t, compare>(p, sublist[merge_count]);
        }

        return p;
    }

    export template <class t>
        struct list_iterator
    {
        list_node<t>* node;

        list_iterator() : node(0) {}

        list_iterator(const list_node<t>& in) : node((list_node<t>*)& in) {}

        t& operator*() const
        {
            return node->data;
        }

        t* operator->() const
        {
            return &(node->data);
        }

        t* operator&() const
        {
            return &(node->data);
        }

        list_iterator& operator++()
        {
            node = node->next; return *this;
        }

        list_iterator operator++(int)
        {
            list_iterator<t> save = *this; ++* this;return save;
        }

        list_iterator& operator+=(unsigned long long increment)
        {
            for (unsigned long long i = 0; i < increment; i++)++* this; return *this;
        }

        list_iterator operator+(unsigned long long increment) const
        {
            list_iterator<t> result(*this);
            for (unsigned long long i = 0; i < increment; i++) ++result;
            return result;
        }

        bool operator==(const list_iterator& y) const { return node == y.node; }

        bool operator!=(const list_iterator& y) const { return node != y.node; }

        long long operator-(list_iterator iter) const
        {
            long long result = 0;
            while (iter++ != *this) { result++; }
            return result;
        }
    };

    export template <class t, class compare = core::compare<t>>
        struct list    // circular, singly-linked list (with merge sort).
    {
        list_header<t> tail; // header node for the list.
        list_node<t>* root;  // points to the last node in the list.
        unsigned long long nodes;    // fast access to list size.

        typedef list_iterator<t> iterator;

        list() : nodes(0)
        {
            root = (list_node<t>*) & tail;
            root->next = root;
        }

        list(const list<t>& copy) : nodes(0)
        {
            root = (list_node<t>*) & tail;
            root->next = root;
            for (t _t : copy) *this << _t;
        }

        template<class I>
        list(I first, I last)
        {
            nodes = 0;
            root = (list_node<t>*) & tail;
            root->next = root;
            while (first != last) *this << *first++;
        }

        list(std::initializer_list<t> l)
        {
            nodes = 0;
            root = (list_node<t>*) & tail;
            root->next = root;
            for (t _t : l) *this << _t;
        }

        ~list() { erase(); }

        list<t>& operator=(const list& copy)
        {
            erase();
            for (t _t : copy) *this << _t;
            return *this;
        }

        void erase()
        {
            list_node<t>* n = tail.next;
            while (n != (list_node<t>*) & tail)
            {
                list_node<t>* next = n->next;
                delete n;
                n = next;
            }
            nodes = 0;
            root = (list_node<t>*) & tail;
            root->next = root;
        }

        unsigned long long length() const { return nodes; }

        list& operator<<(const t& data) { push(data); return *this; }

        const t& back() const { if (root == (list_node<t>*) & tail) throw is_list_tail_exception(); return *iterator(*root); }

        t& back() { if (root == (list_node<t>*) & tail) throw is_list_tail_exception(); return *iterator(*root); }

        const t& front() const { if (root == (list_node<t>*) & tail) throw is_list_tail_exception(); return *iterator(*tail.next); }

        t& front() { if (root == (list_node<t>*) & tail) throw is_list_tail_exception(); return *iterator(*tail.next); }

        iterator begin() const { return *tail.next; }

        iterator end() const { return *(list_node<t>*) & tail; }

        iterator last() const { return *root; }

        iterator push(const t& data)
        {
            list_node<t>* new_node = new list_node<t>(data);
            new_node->next = (list_node<t>*) & tail;
            root->next = new_node;
            root = new_node;
            ++nodes;
            return *new_node;
        }

        void sort()
        {
            list_node<t>* root = (list_node<t>*) & tail;
            if (nodes > 1) merge_sort<t, compare>(root);
        }
    };

    export template<class t>
        struct linked_list_node
    {
        linked_list_node<t>* previous;
        linked_list_node<t>* next;
        t data;

        linked_list_node(const t& dataSet) : data(dataSet) {}

        void* operator new(size_t s) { return allocate_from_heap(s); }

        void operator delete(void* p) { free_from_heap(p); }
    };

    export template<class t>
        struct linked_list_header
    {
        linked_list_node<t>* previous;
        linked_list_node<t>* next;
    };

    export template <class t>
        struct linked_list_iterator
    {
        linked_list_node<t>* node;

        linked_list_iterator() : node(0) {}

        linked_list_iterator(const linked_list_node<t>& in) : node((linked_list_node<t>*)& in) {}

        t& operator*() const
        {
            return node->data;
        }

        t* operator->() const
        {
            return &(node->data);
        }

        t* operator&() const
        {
            return &(node->data);
        }

        linked_list_iterator& operator++()
        {
            node = node->next; return *this;
        }

        linked_list_iterator operator++(int)
        {
            linked_list_iterator save = *this; ++* this;return save;
        }

        linked_list_iterator& operator+=(unsigned long long increment)
        {
            for (unsigned long long i = 0; i < increment; i++)++* this; return *this;
        }

        linked_list_iterator operator+(unsigned long long increment) const
        {
            linked_list_iterator result(*this);
            for (unsigned long long i = 0; i < increment; i++) ++result;
            return result;
        }

        linked_list_iterator& operator--()
        {
            node = node->previous; return *this;
        }

        linked_list_iterator operator--(int)
        {
            linked_list_iterator save = *this; --* this;return save;
        }

        linked_list_iterator& operator-=(unsigned long long decrement)
        {
            for (unsigned long long i = 0; i < decrement; i++)--* this; return *this;
        }

        linked_list_iterator operator-(unsigned long long decrement) const
        {
            linked_list_iterator result(*this);
            for (unsigned long long i = 0; i < decrement; i++) --result;
            return result;
        }

        bool operator==(const linked_list_iterator& y) const { return node == y.node; }

        bool operator!=(const linked_list_iterator& y) const { return node != y.node; }

        const t& operator[](long long i) const { return i >= 0 ? *(*this + i) : *(*this - -i); }

        long long operator-(linked_list_iterator iter) const
        {
            long long result = 0;
            while (iter++ != *this) { result++; }
            return result;
        }
    };

    export template <class t, class compare = core::compare<t>>
        inline linked_list_node<t>* merge(linked_list_node<t>* first, linked_list_node<t>* second)
    {
        linked_list_node<t>* a = first->next;
        linked_list_node<t>* b = second->next;

        linked_list_node<t>* head;
        linked_list_node<t>* tail;

        enum { list_end_none, list_end_A, list_end_B } list_end = list_end_none;

        if (compare()(a->data, b->data) <= 0)
        {
            head = tail = a;
            a = a->next;
            if (a == first->next) list_end = list_end_A;
        }
        else
        {
            head = tail = b;
            b = b->next;
            if (b == second->next) list_end = list_end_B;
        }

        while (list_end == list_end_none)
        {
            if (compare()(a->data, b->data) <= 0)
            {
                tail->next = a;
                a->previous = tail;
                tail = a;
                a = a->next;
                if (a == first->next) list_end = list_end_A;
            }
            else
            {
                tail->next = b;
                b->previous = tail;
                tail = b;
                b = b->next;
                if (b == second->next) list_end = list_end_B;
            }
        }
        if (list_end == list_end_A)
        {
            tail->next = b;
            b->previous = tail;
            second->next = head;
            head->previous = second;
            return second;
        }
        else
        {
            tail->next = a;
            a->previous = tail;
            first->next = head;
            head->previous = first;
            return first;
        }
    }

    export template <class t, class compare = core::compare<t>>
        linked_list_node<t>* merge_sort(linked_list_node<t>* root)
    {
        linked_list_node<t>* sublist[64];

        unsigned long long c = 0;

        linked_list_node<t>* p = root;              // first unsorted Item

        do
        {
            c++;
            long long merge_count = Power2(c);
            linked_list_node<t>* q = p;                  // tail of partial (merged) List.
            p = p->next;
            q->next = q->previous = q;           // q is a sublist of size 1.
            for (long long i = 0; i < merge_count; i++)
                q = merge<t, compare>(q, sublist[i]);
            sublist[merge_count] = q;
        } while (p != root);

        long long merge_count = -1;
        while (c)
        {
            long long d = c % 2;
            c /= 2;
            merge_count++;
            if (d)
                if (p == root)
                    p = sublist[merge_count];
                else
                    p = merge<t, compare>(p, sublist[merge_count]);
        }

        return p;
    }

    export template <class t, class compare = core::compare<t>>
        struct linked_list // doubly-linked linked linked_list with the doubly-linked version of the merge sort.
    {
        linked_list_header<t> tail;
        unsigned long long nodes;

        typedef linked_list_iterator<t> iterator;

        linked_list()
        {
            nodes = 0;
            linked_list_node<t>* root = (linked_list_node<t>*) & tail;
            root->previous = root;
            root->next = root;
        }

        template<class I>
        linked_list(I first, I last)
        {
            nodes = 0;
            linked_list_node<t>* root = (linked_list_node<t>*) & tail;
            root->previous = root;
            root->next = root;
            while (first != last) insert(*first++);
        }

        linked_list(std::initializer_list<t> l)
        {
            nodes = 0;
            linked_list_node<t>* root = (linked_list_node<t>*) & tail;
            root->previous = root;
            root->next = root;
            for (t _t : l) insert(_t);
        }

        ~linked_list() { erase(); }

        linked_list(const linked_list& copy)
        {
            linked_list_node<t>* root = (linked_list_node<t>*) & tail;
            root->previous = root;
            root->next = root;
            nodes = 0;
            for (t _t : copy) insert(_t);
        }

        linked_list& operator=(const linked_list& copy)
        {
            if (nodes) erase();
            for (t _t : copy) insert(_t);
            return *this;
        }

        unsigned long long length() const { return nodes; }

        linked_list& operator<<(const t& data) { insert(data); return *this; }

        iterator begin() const { return *(linked_list_node<t>*)tail.next; }

        iterator end() const { return *(linked_list_node<t>*) & tail; }

        void push(const t& data) { insert(data); }

        iterator insert(const t& data)
        {
            linked_list_node<t>* new_node = new linked_list_node<t>(data);
            linked_list_node<t>* root = (linked_list_node<t>*) & tail;
            root->previous->next = new_node;
            new_node->previous = root->previous;
            root->previous = new_node;
            new_node->next = root;
            ++nodes;
            return *new_node;
        }

        iterator insert(iterator i, const t& data)
        {
            linked_list_node<t>* node = i.node;
            linked_list_node<t>* new_node = new linked_list_node<t>(data);
            node->previous->next = new_node;
            new_node->previous = node->previous;
            node->previous = new_node;
            new_node->next = node;
            ++nodes;
            return *new_node;
        }

        void erase(iterator i)
        {
            linked_list_node<t>* node = i.node;
            if (node == (linked_list_node<t>*) & tail) throw is_list_tail_exception();
            linked_list_node<t>* next = node->next;
            node->previous->next = next;
            next->previous = node->previous;
            delete node;
            --nodes;
        }

        void erase()
        {
            linked_list_node<t>* n = tail.next;
            while (n != (linked_list_node<t>*) & tail)
            {
                linked_list_node<t>* next = n->next;
                delete n;
                n = next;
            }
            linked_list_node<t>* root = (linked_list_node<t>*) & tail;
            root->previous = root;
            root->next = root;
            nodes = 0;
        }

        t pop()
        {
            linked_list_node<t>* last = tail.previous;
            if (last != (linked_list_node<t>*) & tail)
            {
                last->previous->next = (linked_list_node<t>*) & tail;
                tail.previous = last->previous;
            }
            else
                throw is_list_tail_exception();
            t r = last->data;
            delete last;
            nodes--;
            return r;
        }

        iterator last() const { return *(linked_list_node<t>*)tail.previous; }

        t& front()
        {
            linked_list_node<t>* f = tail.next;
            if (f == (linked_list_node<t>*) & tail) throw is_list_tail_exception();
            return f->data;
        }

        const t& front() const
        {
            linked_list_node<t>* f = tail.next;
            if (f == (linked_list_node<t>*) & tail) throw is_list_tail_exception();
            return f->data;
        }

        t& back()
        {
            linked_list_node<t>* b = tail.previous;
            if (b == (linked_list_node<t>*) & tail) throw is_list_tail_exception();
            return b->data;
        }

        const t& back() const
        {
            linked_list_node<t>* b = tail.previous;
            if (b == (linked_list_node<t>*) & tail) throw is_list_tail_exception();
            return b->data;
        }

        void sort()
        {
            linked_list_node<t>* root = (linked_list_node<t>*) & tail;
            if (nodes > 1) merge_sort<t, compare>(root);
        }
    };

    export struct entry
    {
        union
        {
            char _char;
            wchar_t _wchar_t;
            unsigned char _byte;
            short _short;
            unsigned short _ushort;
            int _int;
            unsigned _unsigned;
            float _float;
            double _double;
            long _long;
            unsigned long _ulong;
            long long _longlong;
            unsigned long long _ulonglong;
            bool _bool;
        } data;

        entry() {}

        entry(char c)
        {
            data._char = c;
        }

        entry(wchar_t c)
        {
            data._wchar_t = c;
        }

        entry(unsigned char uc)
        {
            data._byte = uc;
        }

        entry(short s)
        {
            data._short = s;
        }

        entry(unsigned short us)
        {
            data._ushort = us;
        }

        entry(int i)
        {
            data._int = i;
        }

        entry(unsigned u)
        {
            data._unsigned = u;
        }

        entry(float f)
        {
            data._float = f;
        }

        entry(double d)
        {
            data._double = d;
        }

        entry(long l)
        {
            data._long = l;
        }

        entry(unsigned long ul)
        {
            data._ulong = ul;
        }

        entry(long long l)
        {
            data._longlong = l;
        }

        entry(unsigned long long ul)
        {
            data._ulonglong = ul;
        }

        entry(bool b)
        {
            data._bool = b;
        }

        inline void* operator new(size_t s) { return allocate_from_heap(s); }

        inline void operator delete(void* p) { free_from_heap(p); }
    };

    export struct oarchive
    {
        list<entry> data;

        oarchive& operator<<(char c)
        {
            data << entry(c);
            return *this;
        }

        oarchive& operator<<(wchar_t c)
        {
            data << entry(c);
            return *this;
        }

        oarchive& operator<<(unsigned char uc)
        {
            data << entry(uc);
            return *this;
        }

        oarchive& operator<<(short s)
        {
            data << entry(s);
            return *this;
        }

        oarchive& operator<<(unsigned short us)
        {
            data << entry(us);
            return *this;
        }

        oarchive& operator<<(int i)
        {
            data << entry(i);
            return *this;
        }

        oarchive& operator<<(unsigned u)
        {
            data << entry(u);
            return *this;
        }

        oarchive& operator<<(float f)
        {
            data << entry(f);
            return *this;
        }

        oarchive& operator<<(double d)
        {
            data << entry(d);
            return *this;
        }

        oarchive& operator<<(long l)
        {
            data << entry(l);
            return *this;
        }

        oarchive& operator<<(unsigned long ul)
        {
            data << entry(ul);
            return *this;
        }

        oarchive& operator<<(long long l)
        {
            data << entry(l);
            return *this;
        }

        oarchive& operator<<(unsigned long long ul)
        {
            data << entry(ul);
            return *this;
        }

        oarchive& operator<<(bool b)
        {
            data << entry(b);
            return *this;
        }

        void* allocate()
        {
            long long size = data.length();
            entry* buffer = (entry*)allocate_from_heap((size + 1) * sizeof(entry));
            buffer[0].data._longlong = (size + 1) * sizeof(entry);
            long long l = 0;
            for (entry e : data)
            {
                buffer[l + 1].data = e.data;
                l++;
            }
            return buffer;
        }

        void free(void* buffer) { free_from_heap(buffer); }
    };

    export struct iarchive
    {
        entry* buffer;
        long long offset;

        iarchive(void* b = 0) : offset(0), buffer((entry*)b) {  }

        iarchive& operator>>(char& c)
        {
            c = buffer[offset + 1].data._char;
            offset++;
            return *this;
        }

        iarchive& operator>>(wchar_t& c)
        {
            c = buffer[offset + 1].data._wchar_t;
            offset++;
            return *this;
        }

        iarchive& operator>>(unsigned char& uc)
        {
            uc = buffer[offset + 1].data._byte;
            offset++;
            return *this;
        }

        iarchive& operator>>(short& s)
        {
            s = buffer[offset + 1].data._short;
            offset++;
            return *this;
        }

        iarchive& operator>>(unsigned short& us)
        {
            us = buffer[offset + 1].data._ushort;
            offset++;
            return *this;
        }

        iarchive& operator>>(int& i)
        {
            i = buffer[offset + 1].data._int;
            offset++;
            return *this;
        }

        iarchive& operator>>(unsigned& u)
        {
            u = buffer[offset + 1].data._unsigned;
            offset++;
            return *this;
        }

        iarchive& operator>>(float& f)
        {
            f = buffer[offset + 1].data._float;
            offset++;
            return *this;
        }

        iarchive& operator>>(double& d)
        {
            d = buffer[offset + 1].data._double;
            offset++;
            return *this;
        }

        iarchive& operator>>(long& l)
        {
            l = buffer[offset + 1].data._long;
            offset++;
            return *this;
        }

        iarchive& operator>>(unsigned long& ul)
        {
            ul = buffer[offset + 1].data._ulong;
            offset++;
            return *this;
        }

        iarchive& operator>>(long long& l)
        {
            l = buffer[offset + 1].data._longlong;
            offset++;
            return *this;
        }

        iarchive& operator>>(unsigned long long& ul)
        {
            ul = buffer[offset + 1].data._ulonglong;
            offset++;
            return *this;
        }

        iarchive& operator>>(bool& b)
        {
            b = buffer[offset + 1].data._bool;
            offset++;
            return *this;
        }

    };

    export template <class k, class t>
        struct key_value
    {
        k key;
        t value;

        key_value() {}

        key_value(k k_set) : key(k_set) {}

        key_value(k k_set, t t_set) : key(k_set), value(t_set) {}

        void* operator new(size_t s) { return allocate_from_heap(s); }

        void operator delete(void* p) { free_from_heap(p); }
    };

    export template <class k, class t>
        inline bool operator<(const key_value<k, t>& a, const key_value<k, t>& b)
    {
        return a.key < b.key;
    }

    export template <class k, class t>
        inline std::ostream& operator<<(std::ostream& s, const key_value<k, t>& cv)
    {
        s << "(" << cv.key << "," << cv.value << ")";
        return s;
    }

    export template<class k, class t>
        inline oarchive& operator<<(oarchive& s, const key_value<k, t>& o)
    {
        s << o.key;
        s << o.value;
        return s;
    }

    export template<class k, class t>
        inline iarchive& operator>>(iarchive& s, key_value<k, t>& o)
    {
        s >> o.key;
        s >> o.value;
        return s;
    }

    export template<class k, class t>
        inline oarchive& operator<<(oarchive& s, const std::pair<k, t>& o)
    {
        s << o.first;
        s << o.second;
        return s;
    }

    export template<class k, class t>
        inline iarchive& operator>>(iarchive& s, std::pair<k, t>& o)
    {
        s >> o.first;
        s >> o.second;
        return s;
    }

    export template <class character>
        bool integer_to_ascii(long long convert,
            character* string,
            long long base)
    {
        if (base >= 36 || base < 2)
            return false;
        else
        {
            character digits[] = { '0','1','2','3','4','5','6','7','8','9',
                                  'a','b','c','d','e','f','g','h','i','j',
                                  'k','l','m','n','o','p','q','r','s','t',
                                  'u','v','w','x','y','z' };

            if (!convert)
            {
                *string = '0';
                *(string + 1) = '\0';
            }
            else
            {
                long long i = 0;

                if (base == 10 && convert < 0)
                {
                    string[i] = '-';
                    convert = -convert;
                    i++;
                }
                long long u = (long long)convert;
                while (u)
                {
                    long long remainder = u % base;

                    string[i] = digits[remainder];
                    u /= base;
                    i++;
                }
                string[i] = '\0';
                if (string[0] == '-')
                    reverse_string(string + 1);
                else
                    reverse_string(string);
            }
        }
        return true;
    }

    export template <class character>
        gstring<character> integer_to_string(long long convert, long long base = 10)
    {
        character bupher[80];

        integer_to_ascii(convert,
            bupher,
            base);

        return (character*)bupher;
    }

    export template<class character>
        inline std::ostream& operator<<(std::ostream& s, const gstring<character>& o)
    {
        for (character c : o) s << (char)c;
        return s;
    }

    export template<class character>
        inline std::wostream& operator<<(std::wostream& s, const gstring<character>& o)
    {
        for (character c : o) s << (wchar_t)c;
        return s;
    }

    export template<class character>
        inline oarchive& operator<<(oarchive& oa, const gstring<character>& o)
    {
        long long l = o.length();
        oa << l;
        for (long long i = 0; i < l; i++)
            oa << o[i];
        return oa;
    }

    export template<class character>
        inline iarchive& operator>>(iarchive& ia, gstring<character>& o)
    {
        long long l;
        ia >> l;
        for (long long i = 0; i < l; i++)
        {
            character c;
            ia >> c;
            o.push(c);
        }
        return ia;
    }

    export template<class t, class allocator>
        std::ostream& operator<<(std::ostream& s, const std::list<t, allocator>& o)
    {
        s << string(L"{");
        typename::std::list<t, allocator>::const_iterator e = o.end();
        typename::std::list<t, allocator>::const_iterator l = e; l--;
        for (typename::std::list<t, allocator>::const_iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t, class compare, class allocator>
        std::ostream& operator<<(std::ostream& s, const std::set<t, compare, allocator>& o)
    {
        s << string(L"{");
        typename::std::set<t, compare, allocator>::iterator e = o.end();
        typename::std::set<t, compare, allocator>::iterator l = e; l--;
        for (typename::std::set<t, compare, allocator>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t, class compare, class allocator>
        std::ostream& operator<<(std::ostream& s, const std::multiset<t, compare, allocator>& o)
    {
        s << string(L"{");
        typename::std::multiset<t, compare, allocator>::iterator e = o.end();
        typename::std::multiset<t, compare, allocator>::iterator l = e; l--;
        for (typename::std::multiset<t, compare, allocator>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t, class compare, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::set<t, compare, allocator>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class compare, class allocator>
        inline iarchive& operator>>(iarchive& s, std::set<t, compare, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o.insert(_t);
        }
        return s;
    }

    export template<class t, class compare, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::multiset<t, compare, allocator>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class compare, class allocator>
        inline iarchive& operator>>(iarchive& s, std::multiset<t, compare, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o.insert(_t);
        }
        return s;
    }

    export template<class t, class hash, class equal, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::unordered_set<t, hash, equal, allocator>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class hash, class equal, class allocator>
        inline iarchive& operator>>(iarchive& s, std::unordered_set<t, hash, equal, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o.insert(_t);
        }
        return s;
    }

    export template<class t, class hash, class Equal, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::unordered_multiset<t, hash, Equal, allocator>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class hash, class equal, class allocator>
        inline iarchive& operator>>(iarchive& s, std::unordered_multiset<t, hash, equal, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o.insert(_t);
        }
        return s;
    }

    export inline oarchive& operator<<(oarchive& s, const std::string& o)
    {
        s << o.size();
        std::string::const_iterator e = o.end();
        for (std::string::const_iterator i = o.begin(); i != e; ++i)
        {
            s << *i;
        }
        return s;
    }

    export inline  iarchive& operator>>(iarchive& s, std::string& o)
    {
        int length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            wchar_t t;
            s >> t;
            o.push_back(t);
        }
        return s;
    }

    export template<class t, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::forward_list<t, allocator>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class allocator>
        inline iarchive& operator>>(iarchive& s, std::forward_list<t, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o.push_back(_t);
        }
        return s;
    }

    export template<class t, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::list<t, allocator>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class allocator>
        inline iarchive& operator>>(iarchive& s, std::list<t, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o.push_back(_t);
        }
        return s;
    }

    export template<class t, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::vector<t, allocator>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class allocator>
        inline iarchive& operator>>(iarchive& s, std::vector<t, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o.push_back(_t);
        }
        return s;
    }

    export template<class t, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::deque<t, allocator>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class allocator>
        inline iarchive& operator>>(iarchive& s, std::deque<t, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o.push_back(_t);
        }
        return s;
    }

    export template<class k, class t, class compare, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::map<k, t, compare, allocator>& o)
    {
        s << o.size();
        for (std::pair<k, t> p : o) s << p;
        return s;
    }

    export template<class k, class t, class compare, class allocator>
        inline iarchive& operator>>(iarchive& s, std::map<k, t, compare, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            std::pair<k, t> _t;
            s >> _t;
            o[_t.first] = _t.second;
        }
        return s;
    }


    export template<class k, class t, class hash, class equal, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::unordered_map<k, t, hash, equal, allocator>& o)
    {
        s << o.size();
        for (std::pair<k, t> p : o) s << p;
        return s;
    }

    export template<class k, class t, class hash, class equal, class allocator>
        inline iarchive& operator>>(iarchive& s, std::unordered_map<k, t, hash, equal, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            std::pair<k, t> _t;
            s >> _t;
            o[_t.first] = _t.second;
        }
        return s;
    }

    export template<class k, class t, class hash, class equal, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::unordered_multimap<k, t, hash, equal, allocator>& o)
    {
        s << o.size();
        for (std::pair<k, t> p : o) s << p;
        return s;
    }

    export template<class k, class t, class hash, class equal, class allocator>
        inline iarchive& operator>>(iarchive& s, std::unordered_multimap<k, t, hash, equal, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            std::pair<k, t> _t;
            s >> _t;
            o.insert(_t);
        }
        return s;
    }

    export template<class k, class t, class compare, class allocator>
        inline oarchive& operator<<(oarchive& s, const std::multimap<k, t, compare, allocator>& o)
    {
        s << o.size();
        for (std::pair<k, t> p : o) s << p;
        return s;
    }

    export template<class k, class t, class compare, class allocator>
        inline iarchive& operator>>(iarchive& s, std::multimap<k, t, compare, allocator>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            std::pair<k, t> _t;
            s >> _t;
            o.insert(_t);
        }
        return s;
    }

    export template<class t, class compare>
        std::ostream& operator<<(std::ostream& s, const linked_list<t, compare>& o)
    {
        s << string(L"{");
        typename::linked_list<t, compare>::iterator e = o.end();
        typename::linked_list<t, compare>::iterator l = e; l--;
        for (typename::linked_list<t, compare>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export struct set_operation
    {
        enum
        {
            _union,
            intersection,
            symmetric_difference,
            difference,
        };
    };

    export template<class t>
        struct set_node : public node
    {
        t element;

        set_node(const t& element_set, node* parent) : node(parent), element(element_set) {}

        void* operator new(size_t s) { return allocate_from_heap(s); }

        void operator delete(void* p) { free_from_heap(p); }
    };

    export template <class t>
        struct set_iterator
    {
        node* _node;

        set_iterator() : _node(0) {}

        set_iterator(node* in) : _node(in) {}

        t& operator*() const
        {
            return ((set_node<t>*)_node)->element;
        }

        t* operator->() const
        {
            return &((set_node<t>*)_node)->element;
        }

        t* operator&() const
        {
            return &((set_node<t>*)_node)->element;
        }

        set_iterator& operator++()
        {
            _node = next_item(_node); return *this;
        }

        set_iterator operator++(int)
        {
            set_iterator save = *this; ++* this;return save;
        }

        set_iterator& operator+=(long long increment)
        {
            for (long long i = 0; i < increment; i++)++* this; return *this;
        }

        set_iterator operator+(long long increment) const
        {
            set_iterator result(*this);
            for (long long i = 0; i < increment; i++) ++result;
            return result;
        }

        set_iterator& operator--()
        {
            _node = previous_item(_node); return *this;
        }

        set_iterator operator--(int)
        {
            set_iterator save = *this; --* this;return save;
        }

        set_iterator& operator-=(long long decrement)
        {
            for (long long i = 0; i < decrement; i++)--* this; return *this;
        }

        set_iterator operator-(long long decrement) const
        {
            set_iterator result(*this);
            for (long long i = 0; i < decrement; i++) --result;
            return result;
        }

        bool operator==(const set_iterator& y) const { return _node == y._node; }

        bool operator!=(const set_iterator& y) const { return _node != y._node; }

        const t& operator[](long long i) const { return i >= 0 ? *(*this + i) : *(*this - -i); }

        long long operator-(set_iterator iter) const
        {
            long long result = 0;
            while (iter++ != *this) { result++; }
            return result;
        }

        bool is_header() const { return _node->is_header(); }
    };

    export template <class t, class less = core::less<t>>
        struct set
    {
        node header;

        typedef set_iterator<t> iterator;

        set() {}

        set(const set& copy) { for (t type : copy) *this << type; }

        set(std::initializer_list<t> l)
        {
            for (t _t : l) insert(_t);
        }

        set(const set& A, const set& B, long long operation)
        {
            iterator first1 = A.begin();
            iterator last1 = A.end();
            iterator first2 = B.begin();
            iterator last2 = B.end();

            switch (operation)
            {
            case set_operation::_union:
            {
                while (first1 != last1 && first2 != last2)
                {
                    bool _less = less()(*first1, *first2);
                    bool _greater = less()(*first2, *first1);

                    if (_less)
                    {
                        insert(*first1);
                        ++first1;
                    }

                    else if (_greater)
                    {
                        insert(*first2);
                        ++first2;
                    }

                    else
                    {
                        insert(*first1);
                        ++first1; ++first2;
                    }
                }

                while (first1 != last1)
                {
                    insert(*first1);
                    first1++;
                }

                while (first2 != last2)
                {
                    insert(*first2);
                    first2++;
                }
            }
            break;

            case set_operation::intersection:
            {
                while (first1 != last1 && first2 != last2)
                {
                    bool is_less = less()(*first1, *first2);
                    bool is_greater = less()(*first2, *first1);

                    if (is_less)
                        ++first1;

                    else if (is_greater)
                        ++first2;

                    else
                    {
                        insert(*first1);
                        ++first1; ++first2;
                    }
                }
            }
            break;

            case set_operation::symmetric_difference:
            {
                while (first1 != last1 && first2 != last2)
                {
                    bool is_less = less()(*first1, *first2);
                    bool is_greater = less()(*first2, *first1);

                    if (is_less)
                    {
                        insert(*first1);
                        ++first1;
                    }

                    else if (is_greater)
                    {
                        insert(*first2);
                        ++first2;
                    }

                    else
                    {
                        ++first1; ++first2;
                    }
                }

                while (first1 != last1)
                {
                    insert(*first1);
                    ++first1;
                }

                while (first2 != last2)
                {
                    insert(*first2);
                    ++first2;
                }
            }
            break;

            case set_operation::difference:
            {
                while (first1 != last1 && first2 != last2)
                {
                    bool is_less = less()(*first1, *first2);
                    bool is_greater = less()(*first2, *first1);

                    if (is_less)
                    {
                        insert(*first1);
                        ++first1;
                    }

                    else if (is_greater)
                    {
                        insert(*first1);
                        ++first1; ++first2;
                    }

                    else
                    {
                        ++first1; ++first2;
                    }
                }

                while (first1 != last1)
                {
                    insert(*first1);
                    ++first1;
                }
            }
            break;

            default:
                throw invalid_set_operation_exception();
            }
        }

        set& operator<<(const set& i)
        {
            for (t _t : i) *this << _t;
            return *this;
        }

        ~set()
        {
            destroy((set_node<t>*)header.parent);
        }

        set& operator=(const set& copy)
        {
            erase();
            for (t _t : copy) *this << _t;
            return *this;
        }

        long long length() const { return count(header.parent); }

        set& operator<<(const t& element) { insert(element); return *this; }

        set& operator>>(const t& element) { erase(element); return *this; }

        iterator begin() const { return header.left; }

        iterator end() const { return (node*)&header; }

        t& front()
        {
            iterator i = begin();
            if (i.is_header()) throw is_header_exception();
            return *i;
        }

        const t& front() const
        {
            iterator i = begin();
            if (i.is_header()) throw is_header_exception();
            return *i;
        }

        t& back()
        {
            iterator i = end(); i--;
            if (i.is_header()) throw is_header_exception();
            return *i;
        }

        const t& back() const
        {
            iterator i = end(); i--;
            if (i.is_header()) throw is_header_exception();
            return *i;
        }

        iterator insert(const t& element) // insertion balances from leaf-to-root.
        {
            node* root_node = header.parent;

            if (root_node == 0)
            {
                root_node = new set_node<t>(element, &header);
                header.left = root_node;
                header.right = root_node;
                header.parent = root_node;
                return root_node;
            }

            else
            {
                for (; ; )
                {
                    bool is_less = less()(element, ((set_node<t>*)root_node)->element);
                    if (is_less)
                    {
                        if (root_node->left != 0)
                        {
                            root_node = root_node->left;
                            continue;
                        }
                        else
                        {
                            node* new_node = new set_node<t>(element, root_node);
                            root_node->left = new_node;
                            adjust_add(new_node);
                            return new_node;
                        }
                    }

                    bool is_greater = less()(((set_node<t>*)root_node)->element, element);

                    if (!is_less && !is_greater) // if the entry exists, replace it.
                    {
                        ((set_node<t>*)root_node)->element = element;
                        return root_node;
                    }

                    else
                    {
                        if (root_node->right != 0)
                            root_node = root_node->right;
                        else
                        {
                            node* new_node = new set_node<t>(element, root_node);
                            root_node->right = new_node;
                            adjust_add(new_node);
                            return new_node;
                        }
                    }
                }
            }
        }

        void erase(const t& element)
        {
            node* root_node = header.parent;

            for (; ; )
            {
                if (root_node == 0) throw entry_not_found_exception();

                bool is_less = less()(element, ((set_node<t>*)root_node)->element);

                if (is_less)
                {
                    root_node = root_node->left;
                    continue;
                }

                bool is_greater = less()(((set_node<t>*)root_node)->element, element);

                if (is_greater)
                    root_node = root_node->right;
                else
                {
                    if (root_node->left != 0 && root_node->right != 0)
                    {
                        node* replace = root_node->left;
                        while (replace->right != 0) replace = replace->right;
                        swap_nodes(root_node, replace);
                    }

                    node* parent = root_node->parent;

                    long long from = (parent->left == root_node) ? direction::from_left : direction::from_right;

                    if (root_node->left == 0)
                    {
                        if (parent == &header)
                            header.parent = root_node->right;
                        else if (from == direction::from_left)
                            parent->left = root_node->right;
                        else
                            parent->right = root_node->right;

                        if (root_node->right != 0) root_node->right->parent = parent;
                    }
                    else
                    {
                        if (parent == &header)
                            header.parent = root_node->left;
                        else if (from == direction::from_left)
                            parent->left = root_node->left;
                        else
                            parent->right = root_node->left;

                        if (root_node->left != 0) root_node->left->parent = parent;
                    }

                    adjust_remove(parent, from);
                    delete (set_node<t>*)root_node;
                    break;
                }
            }
        }

        void erase(iterator i)
        {
            node* root_node = i._node;

            if (root_node->is_header()) throw is_header_exception();

            if (root_node->left != 0 && root_node->right != 0)
            {
                node* replace = root_node->left;
                while (replace->right != 0) replace = replace->right;
                swap_nodes(root_node, replace);
            }

            node* parent = root_node->parent;

            long long from = (parent->left == root_node) ? direction::from_left : direction::from_right;

            if (root_node->left == 0)
            {
                if (parent == &header)
                    header.parent = root_node->right;
                else if (from == direction::from_left)
                    parent->left = root_node->right;
                else
                    parent->right = root_node->right;

                if (root_node->right != 0) root_node->right->parent = parent;
            }
            else
            {
                if (parent == &header)
                    header.parent = root_node->left;
                else if (from == direction::from_left)
                    parent->left = root_node->left;
                else
                    parent->right = root_node->left;

                if (root_node->left != 0) root_node->left->parent = parent;
            }

            adjust_remove(parent, from);
            delete (set_node<t>*)root_node;
        }

        //bool operator[](const t& element) const { return contains(element); }

        bool contains(const t& element) const
        {
            if (!header.parent)
                return false;
            else
            {
                const node* search_node = header.parent;
                do
                {
                    bool is_less = less()(element, ((set_node<t>*)search_node)->element);
                    if (is_less) { search_node = search_node->left; continue; }
                    bool is_greater = less()(((set_node<t>*)search_node)->element, element);
                    if (is_greater) search_node = search_node->right;
                    else break;
                } while (search_node);
                return search_node != 0;
            }
        }

        t* locate(const t& element)
        {
            if (!header.parent)
                return 0;
            else
            {
                const node* search_node = header.parent;

                do
                {
                    bool _less = less()(element, ((set_node<t>*)search_node)->element);
                    if (_less < 0) { search_node = search_node->left; continue; }
                    bool _greater = less()(((set_node<t>*)search_node)->element, element);
                    if (_greater > 0) search_node = search_node->right;
                    else break;

                } while (search_node);

                if (search_node == 0) return 0;

                return &((set_node<t>*)search_node)->element;
            }
        }

        iterator find(const t& element) const
        {
            if (!header.parent)
                throw entry_not_found_exception();
            else
            {
                const node* search_node = header.parent;

                do
                {
                    bool _less = less()(element, ((set_node<t>*)search_node)->element);
                    if (_less) { search_node = search_node->left; continue; }
                    bool _greater = less()(((set_node<t>*)search_node)->element, element);
                    if (_greater) search_node = search_node->right;
                    else break;

                } while (search_node);

                if (search_node == 0) throw entry_not_found_exception();

                return (node*)search_node;
            }
        }

        t& get(const t& element)
        {
            iterator i = find(element);
            return *i;
        }

        const t& get(const t& element) const
        {
            iterator i = find(element);
            return *i;
        }

        void erase()
        {
            destroy((set_node<t>*)header.parent);
            header.left = &header;
            header.right = &header;
            header.parent = 0;
        }

        iterator after(const t& element) const
        {
            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
                if (less()(element, ((set_node<t>*)x)->element))
                {
                    y = x; x = x->left;
                }
                else
                    x = x->right;

            return (node*)y;
        }

        iterator after_equals(const t& element) const
        {
            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
            {
                bool _less = less()(element, ((set_node<t>*)x)->element);
                bool _greater = less()(((set_node<t>*)x)->element, element);
                if (!_less && !_greater)
                {
                    y = x; break;
                }
                else if (_less)
                {
                    y = x; x = x->left;
                }
                else
                    x = x->right;
            }

            return (node*)y;
        }

        iterator before(const t& element) const
        {
            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
            {
                if (!less()(((set_node<t>*)x)->element, element))
                {
                    x = x->left;
                }
                else
                {
                    y = x; x = x->right;
                }
            }
            return (node*)y;
        }

        iterator before_equals(const t& element) const
        {
            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
            {
                bool _less = less()(element, ((set_node<t>*)x)->element);
                bool _greater = less()(((set_node<t>*)x)->element, element);
                if (!_less && !_greater)
                {
                    y = x; break;
                }
                else if (_less)
                    x = x->left;
                else
                {
                    y = x; x = x->right;
                }
            }

            return (node*)y;
        }

        iterator last() const { return header.right; }

        long long depth() const { return depth(header.parent); }

        node* get_first()
        {
            if (!header.parent)
                return &header;

            else
            {
                node* search_node = header.parent;
                while (search_node->left) search_node = search_node->left;
                return search_node;
            }
        }

        node* get_last()
        {
            if (!header.parent)
                return &header;

            else
            {
                node* search_node = header.parent;
                while (search_node->right) search_node = search_node->right;
                return search_node;
            }
        }

        void destroy(set_node<t>* root_node)
        {
            if (root_node)
            {
                if (root_node->left)
                    destroy((set_node<t>*)root_node->left);

                if (root_node->right)
                    destroy((set_node<t>*)root_node->right);

                delete root_node;
            }
        }
    };

    export template<class t, class less = core::less<t>>
        inline set<t, less> operator|(const set<t, less>& a, const set<t, less>& b)
    {
        set<t, less> r(a, b, set_operation::_union); return r;
    }

    export template<class t, class less = core::less<t>>
        inline set<t, less> operator&(const set<t, less>& a, const set<t, less>& b)
    {
        set<t, less> r(a, b, set_operation::intersection); return r;
    }

    export template<class t, class less = core::less<t>>
        inline set<t, less> operator^(const set<t, less>& a, const set<t, less>& b)
    {
        set<t, less> r(a, b, set_operation::symmetric_difference); return r;
    }

    export template<class t, class less = core::less<t>>
        inline set<t, less> operator-(const set<t, less>& a, const set<t, less>& b)
    {
        set<t, less> r(a, b, set_operation::difference); return r;
    }

    export template<class t, class less = core::less<t>>
        inline bool operator==(const set<t, less>& a, const set<t, less>& b)
    {
        typename::set<t, less>::iterator first1 = a.begin();
        typename::set<t, less>::iterator last1 = a.end();
        typename::set<t, less>::iterator first2 = b.begin();
        typename::set<t, less>::iterator last2 = b.end();

        bool equals = true;

        while (first1 != last1 && first2 != last2)
        {
            bool _less = less()(*first1, *first2);
            bool _greater = less()(*first2, *first1);

            if (_less)
            {
                equals = false; break;
            }
            else if (_greater)
            {
                equals = false; break;
            }
            else
            {
                ++first1; ++first2;
            }
        }

        if (equals)
        {
            if (first1 != last1) equals = false;
            if (first2 != last2) equals = false;
        }

        return equals;
    }

    export template<class t, class less = core::less<t>>
        inline bool operator!=(const set<t, less>& a, const set<t, less>& b) { return !(a == b); }

    export template<class t, class less = core::less<t>>
        int compare_sets(const set<t, less>& a, const set<t, less>& b)
    {
        typename::set<t, less>::iterator first1 = a.begin();
        typename::set<t, less>::iterator last1 = a.end();
        typename::set<t, less>::iterator first2 = b.begin();
        typename::set<t, less>::iterator last2 = b.end();

        while (first1 != last1 && first2 != last2)
        {
            bool _less = less()(*first1, *first2);
            bool _greater = less()(*first2, *first1);
            if (_less)
                return -1;
            else if (_greater)
                return 1;
            else
            {
                ++first1; ++first2;
            }
        }

        if (first1 != last1) return 1;
        if (first2 != last2) return -1;

        return 0;
    }

    export template<class t, class less = core::less<t>>
        bool operator<(const set<t, less>& a, const set<t, less>& b)
    {
        return compare_sets(a, b) < 0;
    }

    export template<class t, class less = core::less<t>>
        oarchive& operator<<(oarchive& s, const set<t, less>& o)
    {
        s << o.length();
        typename::set<t, less>::iterator e = o.end();
        for (typename::set<t, less>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i;
        }
        return s;
    }

    export template<class t, class less = core::less<t>>
        iarchive& operator>>(iarchive& s, set<t, less>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o << _t;
        }
        return s;
    }

    export template<class t, class less = core::less<t>>
        std::ostream& operator<<(std::ostream& s, const set<t, less>& o)
    {
        s << string(L"{");
        typename::set<t, less>::iterator e = o.end();
        typename::set<t, less>::iterator l = e - 1;
        for (typename::set<t, less>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t, class less = core::less<t>>
        std::wostream& operator<<(std::wostream& s, const set<t, less>& o)
    {
        s << string(L"{");
        typename::set<t, less>::iterator e = o.end();
        typename::set<t, less>::iterator l = e - 1;
        for (typename::set<t, less>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template <class t, class less = core::less<t>>
        struct multiset
    {
        node header;

        typedef set_iterator<t> iterator;

        multiset() {}

        multiset(const multiset& copy) { for (t tiip : copy) *this << tiip; }

        multiset(std::initializer_list<t> l) { for (t _t : l) insert(_t); }

        multiset& operator<<(const multiset& i)
        {
            for (t _t : i) *this << _t;
            return *this;
        }

        template<class I>
        multiset(I first, I last)
        {
            while (first != last) insert(*first++);
        }

        ~multiset()
        {
            destroy((set_node<t>*)header.parent);
        }

        multiset& operator=(const multiset& copy)
        {
            erase();
            for (t _t : copy) *this << _t;
            return *this;
        }

        long long length() const { return count(header.parent); }

        multiset& operator<<(const t& element) { insert(element); return *this; }

        multiset& operator>>(const t& element) { erase(element); return *this; }

        iterator begin() const { return header.left; }

        iterator end() const { return (node*)&header; }

        t& front()
        {
            iterator i = begin();;
            return *i;
        }

        const t& front() const
        {
            iterator i = begin();
            return *i;
        }

        t& back()
        {
            iterator i = end(); i--;
            return *i;
        }

        const t& back() const
        {
            iterator i = end(); i--;
            return *i;
        }

        iterator insert(const t& element)
        {
            node* root_node = header.parent;

            if (root_node == 0)
            {
                root_node = new set_node<t>(element, &header);
                header.left = root_node;
                header.right = root_node;
                header.parent = root_node;
                return root_node;
            }

            else
            {
                for (; ; )
                {
                    bool is_less = less()(element, ((set_node<t>*)root_node)->element);

                    if (is_less)
                    {
                        if (root_node->left != 0)
                            root_node = root_node->left;
                        else
                        {
                            node* new_node = new set_node<t>(element, root_node);
                            root_node->left = new_node;
                            adjust_add(new_node);
                            return new_node;
                        }
                    }

                    else
                    {
                        if (root_node->right != 0)
                            root_node = root_node->right;
                        else
                        {
                            node* new_node = new set_node<t>(element, root_node);
                            root_node->right = new_node;
                            adjust_add(new_node);
                            return new_node;
                        }
                    }
                }
            }
        }

        void erase(iterator i)
        {
            node* root_node = i._node;

            if (root_node->is_header()) throw is_header_exception();

            if (root_node->left != 0 && root_node->right != 0)
            {
                node* replace = root_node->left;
                while (replace->right != 0) replace = replace->right;
                swap_nodes(root_node, replace);
            }

            node* parent = root_node->parent;

            long long from = (parent->left == root_node) ? direction::from_left : direction::from_right;

            if (root_node->left == 0)
            {
                if (parent == &header)
                    header.parent = root_node->right;
                else if (from == direction::from_left)
                    parent->left = root_node->right;
                else
                    parent->right = root_node->right;

                if (root_node->right != 0) root_node->right->parent = parent;
            }
            else
            {
                if (parent == &header)
                    header.parent = root_node->left;
                else if (from == direction::from_left)
                    parent->left = root_node->left;
                else
                    parent->right = root_node->left;

                if (root_node->left != 0) root_node->left->parent = parent;
            }

            adjust_remove(parent, from);
            delete (set_node<t>*)root_node;
        }

        bool operator[](const t& element) const { return contains(element); }

        void erase()
        {
            destroy((set_node<t>*)header.parent);
            header.left = &header;
            header.right = &header;
            header.parent = 0;
        }

        iterator after(const t& element) const
        {
            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
                if (less()(element, ((set_node<t>*)x)->element))
                {
                    y = x; x = x->left;
                }
                else
                    x = x->right;

            return (node*)y;
        }

        iterator after_equals(const t& element) const
        {
            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
            {
                bool _less = less()(element, ((set_node<t>*)x)->element);
                bool _greater = less()(((set_node<t>*)x)->element, element);
                if (!_less && !_greater)
                {
                    y = x; break;
                }
                else if (_less)
                {
                    y = x; x = x->left;
                }
                else
                    x = x->right;
            }

            return (node*)y;
        }

        iterator before(const t& element) const
        {
            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
            {
                if (!less()(((set_node<t>*)x)->element, element))
                {
                    x = x->left;
                }
                else
                {
                    y = x; x = x->right;
                }
            }
            return (node*)y;
        }

        iterator before_equals(const t& element) const
        {
            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
            {
                bool _less = less()(element, ((set_node<t>*)x)->element);
                bool _greater = less()(((set_node<t>*)x)->element, element);
                if (!_less && !_greater)
                {
                    y = x; break;
                }
                else if (_less)
                    x = x->left;
                else
                {
                    y = x; x = x->right;
                }
            }

            return (node*)y;
        }

        iterator last() const { return header.right; }

        long long depth() const { return depth(header.parent); }

        list<t> find(const t& element) const
        {
            if (!header.parent)
                throw entry_not_found_exception();
            else
            {
                const node* search_node = header.parent;

                do
                {
                    bool _less = less()(element, ((set_node<t>*)search_node)->element);
                    if (_less) { search_node = search_node->left; continue; }
                    bool _greater = less()(((set_node<t>*)search_node)->element, element);
                    if (_greater) search_node = search_node->right;
                    else break;
                } while (search_node);

                if (search_node == 0) throw entry_not_found_exception();

                list<t> ret;

                iterator i((node*)search_node); // backup while equals
                i--;
                while (!(i.is_header()) && !(less()(*i, element) || less()(element, *i))) i--;
                i++;

                for (;;)
                {
                    ret << *i;
                    i++;
                    if (i.is_header()) break;
                    if (less()(*i, element)) break;
                    if (less()(element, *i)) break;
                }

                return ret;
            }
        }

        void erase(const t& element)
        {
            if (!header.parent)
                throw entry_not_found_exception();
            else
            {
                const node* search_node = header.parent;

                do
                {
                    bool _less = less()(element, ((set_node<t>*)search_node)->element);
                    if (_less) { search_node = search_node->left; continue; }
                    bool _greater = less()(((set_node<t>*)search_node)->element, element);
                    if (_greater) search_node = search_node->right;
                    else break;

                } while (search_node);

                if (search_node == 0) throw entry_not_found_exception();

                iterator i((node*)search_node); // backup while equals
                i--;
                while (!i.is_header() && !(less()(*i, element) || less()(element, *i))) i--;
                i++;

                list<iterator> to_erase;

                for (;;)
                {
                    to_erase << i;
                    i++;
                    if (i.is_header()) break;
                    if (less()(*i, element)) break;
                    if (less()(element, *i)) break;
                }

                for (iterator k : to_erase) erase(k);
            }
        }

        node* get_first()
        {
            if (!header.parent)
                return &header;

            else
            {
                node* search_node = header.parent;
                while (search_node->left) search_node = search_node->left;
                return search_node;
            }
        }

        node* get_last()
        {
            if (!header.parent)
                return &header;

            else
            {
                node* search_node = header.parent;
                while (search_node->right) search_node = search_node->right;
                return search_node;
            }
        }

        void destroy(set_node<t>* root_node)
        {
            if (root_node)
            {
                if (root_node->left)
                    destroy((set_node<t>*)root_node->left);

                if (root_node->right)
                    destroy((set_node<t>*)root_node->right);

                delete root_node;
            }
        }

    };

    export template<class t, class less = core::less<t>>
        inline multiset<t, less> operator|(const multiset<t, less>& a, const multiset<t, less>& b)
    {
        multiset<t, less> r(a, b, set_operation::_union); return r;
    }

    export template<class t, class less = core::less<t>>
        inline multiset<t, less> operator&(const multiset<t, less>& a, const multiset<t, less>& b)
    {
        multiset<t, less> r(a, b, set_operation::intersection); return r;
    }

    export template<class t, class less = core::less<t>>
        inline multiset<t, less> operator^(const multiset<t, less>& a, const multiset<t, less>& b)
    {
        multiset<t, less> r(a, b, set_operation::symmetric_difference); return r;
    }

    export template<class t, class less = core::less<t>>
        inline multiset<t, less> operator-(const multiset<t, less>& a, const multiset<t, less>& b)
    {
        multiset<t, less> r(a, b, set_operation::difference); return r;
    }

    export template<class t, class less = core::less<t>>
        inline bool operator==(const multiset<t, less>& a, const multiset<t, less>& b)
    {
        typename::set<t, less>::iterator first1 = a.begin();
        typename::set<t, less>::iterator last1 = a.end();
        typename::set<t, less>::iterator first2 = b.begin();
        typename::set<t, less>::iterator last2 = b.end();

        bool equals = true;


        while (first1 != last1 && first2 != last2)
        {
            bool _less = less()(*first1, *first2);
            bool _greater = less()(*first2, *first1);

            if (_less)
            {
                equals = false; break;
            }
            else if (_greater)
            {
                equals = false; break;
            }
            else
            {
                ++first1; ++first2;
            }
        }

        if (equals)
        {
            if (first1 != last1) equals = false;
            if (first2 != last2) equals = false;
        }

        return equals;
    }

    export template<class t, class less = core::less<t>>
        inline bool operator!=(const multiset<t, less>& a, const multiset<t, less>& b) { return !(a == b); }

    export template<class t, class less = core::less<t>>
        int compare_multisets(const multiset<t, less>& a, const multiset<t, less>& b)
    {
        typename::set<t, less>::iterator first1 = a.begin();
        typename::set<t, less>::iterator last1 = a.end();
        typename::set<t, less>::iterator first2 = b.begin();
        typename::set<t, less>::iterator last2 = b.end();

        while (first1 != last1 && first2 != last2)
        {
            bool _less = less()(*first1, *first2);
            bool _greater = less()(*first2, *first1);
            if (_less)
                return -1;
            else if (_greater)
                return 1;
            else
            {
                ++first1; ++first2;
            }
        }

        if (first1 != last1) return 1;
        if (first2 != last2) return -1;

        return 0;
    }

    export template<class t, class less = core::less<t>>
        std::ostream& operator<<(std::ostream& s, const multiset<t, less>& o)
    {
        s << string(L"{");
        typename::set<t, less>::iterator e = o.end();
        typename::set<t, less>::iterator l = e - 1;
        for (typename::set<t, less>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t, class less = core::less<t>>
        std::wostream& operator<<(std::wostream& s, const multiset<t, less>& o)
    {
        s << string(L"{");
        typename::set<t, less>::iterator e = o.end();
        typename::set<t, less>::iterator l = e - 1;
        for (typename::set<t, less>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t, class less = core::less<t>>
        oarchive& operator<<(oarchive& s, const multiset<t, less>& o)
    {
        s << o.length();
        typename::set<t, less>::iterator e = o.end();
        typename::set<t, less>::iterator l = e - 1;
        for (typename::set<t, less>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i;
        }
        return s;
    }

    export template<class t, class less = core::less<t>>
        iarchive& operator>>(iarchive& s, multiset<t, less>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o << _t;
        }
        return s;
    }


    export template <class k, class t>
        struct map : public set<key_value<k, t>>
    {
        map() {}

        map(std::initializer_list<std::pair<k, t>> l)
        {
            for (std::pair<k, t> _t : l) insert(_t.first, _t.second);
        }

        void insert(const k& key, const t& data) { set<key_value<k, t>>::insert(key_value<k, t>(key, data)); }

        void erase(const k& key) { set<key_value<k, t>>::erase(key_value<k, t>(key)); }

        const t& operator[](const k& key) const
        {
            set_iterator < key_value<k, t>> i = find(key_value<k, t>(key));
            return (*i).value;
        }

        struct reference
        {
            map* m;
            const k* key;

            reference(map& map_set, const k& key_set)
                : m(&map_set), key(&key_set) {}

            reference& operator=(const t& value)
            {
                m->insert(*key, value);
                return *this;
            }

            operator t& () const
            {
                set_iterator < key_value<k, t>> i = m->find(key_value<k, t>(*key));
                return (*i).value;
            }
        };

        reference operator[](const k& key) { return reference(*this, key); }

        map& operator>>(const k& key) { erase(key); return *this; }

        t* locate(const k& key) const { key_value<k, t>* kv = locate(key_value(key));  if (kv) return &(kv->value); else return 0; }

        bool contains(const k& key) { return contains(key_value<k, t>(key)); }
    };

    export template<class k, class t>
        inline oarchive& operator<<(oarchive& s, const map<k, t>& o)
    {
        s << o.length();
        typename::set<key_value<k, t>>::iterator e = o.end();
        for (typename::set<key_value<k, t>>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i;
        }
        return s;
    }

    export template<class k, class t>
        inline iarchive& operator>>(iarchive& s, map<k, t>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            key_value<k, t> kv;
            s >> kv;
            o << kv;
        }
        return s;
    }

    export template<class k, class t>
        inline std::ostream& operator<<(std::ostream& s, const map<k, t>& o)
    {
        s << "{";
        typename::set<key_value<k, t>>::iterator e = o.end();
        typename::set<key_value<k, t>>::iterator l = e - 1;
        for (typename::set<key_value<k, t>>::iterator i = o.begin(); i != e; ++i)
        {
            s << "(" << (*i).key << "," << (*i).value << ")"; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }

    export template<class k, class t>
        inline std::wostream& operator<<(std::wostream& s, const map<k, t>& o)
    {
        s << "{";
        typename::set<key_value<k, t>>::iterator e = o.end();
        typename::set<key_value<k, t>>::iterator l = e - 1;
        for (typename::set<key_value<k, t>>::iterator i = o.begin(); i != e; ++i)
        {
            s << "(" << (*i).key << "," << (*i).value << ")"; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }

    export template <class k, class t>
        struct multimap : public multiset<key_value<k, t>>
    {
        multimap() {}

        multimap(std::initializer_list<std::pair<k, t>> l)
        {
            for (std::pair<k, t> _t : l) insert(_t.first, _t.second);
        }

        void insert(const k& key, const t& data) { multiset<key_value<k, t>>::insert(key_value<k, t>(key, data)); }

        void erase(const k& key) { multiset<key_value<k, t>>::erase(key_value<k, t>(key)); }

        list<t> operator[](const k& key) const
        {
            list<key_value<k, t>> fl = multiset<key_value<k, t>>::find(key_value<k, t>(key));
            list<t> ret;
            for (key_value<k, t> kv : fl) ret << kv.value;
            return ret;
        }

        multimap& operator>>(const k& key) { erase(key); return *this; }

        bool contains(const k& key) { return contains(key_value<k, t>(key)); }
    };

    export template<class k, class t>
        inline oarchive& operator<<(oarchive& s, const multimap<k, t>& o)
    {
        s << o.length();
        typename::set<key_value<k, t>>::iterator e = o.end();
        for (typename::set<key_value<k, t>>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i;
        }
        return s;
    }

    export template<class k, class t>
        inline iarchive& operator>>(iarchive& s, multimap<k, t>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            key_value<k, t> kv;
            s >> kv;
            o << kv;
        }
        return s;
    }

    export template<class k, class t>
        inline std::ostream& operator<<(std::ostream& s, const multimap<k, t>& o)
    {
        s << "{";
        typename::set<key_value<k, t>>::iterator e = o.end();
        typename::set<key_value<k, t>>::iterator l = e - 1;
        for (typename::set<key_value<k, t>>::iterator i = o.begin(); i != e; ++i)
        {
            s << "(" << (*i).key << "," << (*i).value << ")"; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }

    export template<class k, class t>
        inline std::wostream& operator<<(std::wostream& s, const multimap<k, t>& o)
    {
        s << "{";
        typename::set<key_value<k, t>>::iterator e = o.end();
        typename::set<key_value<k, t>>::iterator l = e - 1;
        for (typename::set<key_value<k, t>>::iterator i = o.begin(); i != e; ++i)
        {
            s << "(" << (*i).key << "," << (*i).value << ")"; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }


    export template<class k, class t>
        struct dictionary_node : public node
    {
        k key;
        t data;

        dictionary_node(const k& keySet,
            const t& dataSet,
            node* parent) : node(parent), key(keySet), data(dataSet) {}

        operator const k& () const { return key; }

        operator t& () { return data; }
    };

    export template <class k, class t>
        struct dictionary_iterator
    {
        node* _node;

        dictionary_iterator() : _node(0) {}

        dictionary_iterator(node* in) : _node(in) {}

        dictionary_iterator(const dictionary_iterator<k, t>& i) : _node(i._node) {}

        const k& key() const
        {
            return ((dictionary_node<k, t>*)_node)->key;
        }

        t& value()
        {
            return ((dictionary_node<k, t>*)_node)->data;
        }

        key_value<k, t> operator*() const
        {
            return key_value<k, t>(((dictionary_node<k, t>*)_node)->key, ((dictionary_node<k, t>*)_node)->data);
        }

        t* operator->() const
        {
            return &(((dictionary_node<k, t>*)_node)->data);
        }

        t* operator&() const
        {
            return &(((dictionary_node<k, t>*)_node)->data);
        }

        dictionary_iterator<k, t>& operator++()
        {
            _node = next_item(_node); return *this;
        }

        dictionary_iterator<k, t> operator++(int)
        {
            dictionary_iterator<k, t> save = *this; ++* this;return save;
        }

        dictionary_iterator<k, t>& operator+=(long long increment)
        {
            for (long long i = 0; i < increment; i++)++* this; return *this;
        }

        dictionary_iterator<k, t> operator+(long long increment) const
        {
            dictionary_iterator<k, t> result(*this);
            for (long long i = 0; i < increment; i++) ++result;
            return result;
        }

        dictionary_iterator<k, t>& operator--()
        {
            _node = previous_item(_node); return *this;
        }

        dictionary_iterator<k, t> operator--(int)
        {
            dictionary_iterator<k, t> save = *this; --* this;return save;
        }

        dictionary_iterator<k, t>& operator-=(long long decrement)
        {
            for (long long i = 0; i < decrement; i++)--* this; return *this;
        }

        dictionary_iterator<k, t> operator-(long long decrement) const
        {
            dictionary_iterator<k, t> result(*this);
            for (long long i = 0; i < decrement; i++) --result;
            return result;
        }

        bool operator==(const dictionary_iterator<k, t>& y) const { return _node == y._node; }

        bool operator!=(const dictionary_iterator<k, t>& y) const { return _node != y._node; }

        const t& operator[](long long i) const { return i >= 0 ? *(*this + i) : *(*this - -i); }

        long long operator-(dictionary_iterator<k, t> iter) const
        {
            long long result = 0;
            while (iter++ != *this) { result++; }
            return result;
        }

        bool is_header() const { return _node->is_header(); }
    };

    export template <class k, class t, class less = core::less<k>>
        struct dictionary : semaphore
    {
        node header;

        typedef dictionary_iterator<k, t> iterator;

        dictionary() {}

        dictionary(std::initializer_list<std::pair<k, t>> l)
        {
            for (std::pair<k, t> _t : l) insert(_t.first, _t.second);
        }

        dictionary(const dictionary& copy)
        {
            wait w(copy);
            for (key_value<k, t> kv : copy) (*this)[kv.key] = kv.value;
        }

        ~dictionary()
        {
            wait w(*this);
            destroy((dictionary_node<k, t>*)header.parent);
        }

        dictionary& operator=(const dictionary& copy)
        {
            wait wA(*this);
            wait wB(copy);
            erase();
            for (key_value<k, t> kv : copy) (*this)[kv.key] = kv.value;
            return *this;
        }

        dictionary& operator<<(key_value<k, t> kv)
        {
            insert(kv.key, kv.value);
            return *this;
        }

        long long length() const { wait w(*this); return count(header.parent); }

        iterator begin() const { return header.left; }

        iterator end() const { return (node*)&header; }

        iterator insert(const k& key,
            const t& data)
        {
            wait w(*this);

            node* root_node = header.parent;

            if (root_node == 0)
            {
                root_node = new dictionary_node<k, t>(key, data, &header);
                header.left = root_node;
                header.right = root_node;
                header.parent = root_node;
                return root_node;
            }

            else
            {
                for (; ; )
                {
                    bool _less = less()(key, ((dictionary_node<k, t>*)root_node)->key);
                    bool _greater = less()(((dictionary_node<k, t>*)root_node)->key, key);

                    if (!_less && !_greater)
                    {
                        ((dictionary_node<k, t>*)root_node)->data = data;
                        return root_node;
                    }

                    else if (_less)
                    {
                        if (root_node->left != 0)
                            root_node = root_node->left;
                        else
                        {
                            node* new_node = new dictionary_node<k, t>(key, data, root_node);
                            root_node->left = new_node;
                            adjust_add(new_node);
                            return new_node;
                        }
                    }

                    else
                    {
                        if (root_node->right != 0)
                            root_node = root_node->right;
                        else
                        {
                            node* new_node = new dictionary_node<k, t>(key, data, root_node);
                            root_node->right = new_node;
                            adjust_add(new_node);
                            return new_node;
                        }
                    }
                }
            }
        }

        void erase(const k& key)
        {
            wait w(*this);

            node* root_node = header.parent;

            for (; ; )
            {
                if (root_node == 0) throw entry_not_found_exception();

                bool _less = less()(key, ((dictionary_node<k, t>*)root_node)->key);
                bool _greater = less()(((dictionary_node<k, t>*)root_node)->key, key);

                if (_less)
                    root_node = root_node->left;

                else if (_greater)
                    root_node = root_node->right;

                else // Item is found
                {
                    if (root_node->left != 0 && root_node->right != 0)
                    {
                        node* replace = root_node->left;
                        while (replace->right != 0) replace = replace->right;
                        swap_nodes(root_node, replace);
                    }

                    node* parent = root_node->parent;

                    long long from = (parent->left == root_node) ? direction::from_left : direction::from_right;

                    if (root_node->left == 0)
                    {
                        if (parent == &header)
                            header.parent = root_node->right;
                        else if (from == direction::from_left)
                            parent->left = root_node->right;
                        else
                            parent->right = root_node->right;

                        if (root_node->right != 0) root_node->right->parent = parent;
                    }
                    else
                    {
                        if (parent == &header)
                            header.parent = root_node->left;
                        else if (from == direction::from_left)
                            parent->left = root_node->left;
                        else
                            parent->right = root_node->left;

                        if (root_node->left != 0) root_node->left->parent = parent;
                    }

                    adjust_remove(parent, from);
                    delete (dictionary_node<k, t>*)root_node;
                    break;
                }
            }
        }

        const t& operator[](const k& key) const { return find(key).value(); }

        struct reference
        {

            dictionary* pdictionary;
            const k* key;

            reference(dictionary& dictionary_set, const k& key_set) : pdictionary(&dictionary_set), key(&key_set) {}

            reference& operator=(const t& value)
            {
                pdictionary->insert(*key, value);
                return *this;
            }

            operator t& () const
            {
                iterator i = pdictionary->find(*key);
                return i.value();
            }
        };

        reference operator[](const k& key) { return reference(*this, key); }

        dictionary& operator>>(const k& key) { erase(key); return *this; }

        iterator find(const k& key) const
        {
            wait w(*this);

            if (!header.parent)
                throw entry_not_found_exception();
            else
            {
                const node* search_node = header.parent;

                do
                {
                    bool _less = less()(key, ((dictionary_node<k, t>*)search_node)->key);
                    if (_less) { search_node = search_node->left; continue; }
                    bool _greater = less()(((dictionary_node<k, t>*)search_node)->key, key);
                    if (_greater) search_node = search_node->right;
                    else break;
                } while (search_node);

                if (search_node == 0) throw entry_not_found_exception();

                return (node*)search_node;
            }
        }

        bool contains(const k& key)
        {
            wait w(*this);
            try
            {
                iterator i = find(key);
                return true;
            }
            catch (...) { return false; }
        }

        void erase()
        {
            wait w(*this);
            destroy((dictionary_node<k, t>*)header.parent);
            header.left = &header;
            header.right = &header;
            header.parent = 0;
        }

        iterator after(const k& key) const
        {
            wait w(*this);

            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
                if (less()(key, ((dictionary_node<k, t>*)x)->key))
                {
                    y = x; x = x->left;
                }
                else
                    x = x->right;

            return (node*)y;
        }

        iterator after_equals(const k& key) const
        {
            wait w(*this);

            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
            {
                bool _less = less()(key, ((dictionary_node<k, t>*)x)->key);
                bool _greater = less()(((dictionary_node<k, t>*)x)->key, key);
                if (!_less && !_greater)
                {
                    y = x; break;
                }
                else if (_less)
                {
                    y = x; x = x->left;
                }
                else
                    x = x->right;
            }

            return (node*)y;
        }

        iterator before(const k& key) const
        {
            wait w(*this);

            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
                if (!less()(((dictionary_node<k, t>*)x)->key, key))
                {
                    x = x->left;
                }
                else
                {
                    y = x; x = x->right;
                }

            return (node*)y;
        }

        iterator before_equals(const k& key) const
        {
            wait w(*this);

            const node* y = &header;
            const node* x = header.parent;

            while (x != 0)
            {
                bool _less = less()(key, ((dictionary_node<k, t>*)x)->key);
                bool _greater = less()(((dictionary_node<k, t>*)x)->key, key);
                if (!_less && !_greater)
                {
                    y = x; break;
                }
                else if (less)
                    x = x->left;
                else
                {
                    y = x; x = x->right;
                }
            }

            return (node*)y;
        }

        iterator last() const { wait w(*this); return header.right; }

        long long depth() const { wait w(*this); return depth(header.parent); }

        node* get_first()
        {
            if (!header.parent)
                return &header;

            else
            {
                node* search_node = header.parent;
                while (search_node->left) search_node = search_node->left;
                return search_node;
            }
        }

        node* get_last()
        {
            if (!header.parent)
                return &header;

            else
            {
                node* search_node = header.parent;
                while (search_node->right) search_node = search_node->right;
                return search_node;
            }
        }

        void destroy(dictionary_node<k, t>* root_node)
        {
            if (root_node)
            {
                if (root_node->left)
                    destroy((dictionary_node<k, t>*)root_node->left);

                if (root_node->right)
                    destroy((dictionary_node<k, t>*)root_node->right);

                delete root_node;
            }
        }
    };

    export template<class k, class t, class less = less<t>>
        inline oarchive& operator<<(oarchive& s, const dictionary<k, t, less>& o)
    {
        s << o.length();
        dictionary_iterator<k, t> e = o.end();
        dictionary_iterator<k, t> l = e - 1;
        for (dictionary_iterator<k, t> i = o.begin(); i != e; ++i)
        {
            s << *i;
        }
        return s;
    }

    export template<class k, class t, class less = less<t>>
        inline iarchive& operator>>(iarchive& s, dictionary<k, t, less>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            key_value<k, t> _t;
            s >> _t;
            o << _t;
        }
        return s;
    }

    export template<class k, class t, class less = less<t>>
        inline std::ostream& operator<<(std::ostream& s, const dictionary<k, t, less>& o)
    {
        s << string(L"{");
        dictionary_iterator<k, t> e = o.end();
        dictionary_iterator<k, t> l = e - 1;
        for (dictionary_iterator<k, t> i = o.begin(); i != e; ++i)
        {
            s << "(" << i.key() << "," << i.value() << string(")"); if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class k, class t, class less = less<t>>
        inline std::wostream& operator<<(std::wostream& s, const dictionary<k, t, less>& o)
    {
        s << string(L"{");
        dictionary_iterator<k, t> e = o.end();
        dictionary_iterator<k, t> l = e - 1;
        for (dictionary_iterator<k, t> i = o.begin(); i != e; ++i)
        {
            s << "(" << i.key() << "," << i.value() << string(L")"); if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template <class t>
        struct array_iterator
    {
        set_iterator<key_value<long long, t>> i;

        array_iterator() {}

        array_iterator(node* in) : i(in) {}

        const long long& key() const
        {
            return (*i).key;
        }

        t& value()
        {
            return (*i).value;
        }

        t& operator*() const
        {
            return (*i).value;
        }

        array_iterator& operator++()
        {
            ++i; return *this;
        }

        array_iterator operator++(int)
        {
            array_iterator save = *this; i++;return save;
        }

        array_iterator& operator+=(long long increment)
        {
            for (long long i = 0; i < increment; i++)++* this; return *this;
        }

        array_iterator operator+(long long increment) const
        {
            array_iterator<t> result(*this);
            for (long long i = 0; i < increment; i++) ++result;
            return result;
        }

        array_iterator& operator--()
        {
            i--; return *this;
        }

        array_iterator operator--(int)
        {
            array_iterator save = *this; --* this;return save;
        }

        array_iterator& operator-=(long long decrement)
        {
            for (long long i = 0; i < decrement; i++)--* this; return *this;
        }

        array_iterator operator-(long long decrement) const
        {
            array_iterator<t> result(*this);
            for (long long i = 0; i < decrement; i++) --result;
            return result;
        }

        bool operator==(const array_iterator& y) const { return i == y.i; }

        bool operator!=(const array_iterator& y) const { return i != y.i; }

        long long operator-(array_iterator iter) const
        {
            long long result = 0;
            while (iter++ != *this) { result++; }
            return result;
        }

        bool is_header() const { return i.is_header(); }
    };


    export template <class t>
        struct array : public dictionary<long long, t>
    {
        typedef array_iterator<t> iterator;

        iterator begin() const { return dictionary<long long, t>::header.left; }

        iterator end() const { return (node*)&(dictionary<long long, t>::header); }

        array() {}

        array(long long count, const t* values)
        {
            for (int i = 0; i < count, i++; ) this << values[i];
        }

        template<class I>
        array(I first, I last)
        {
            while (first != last) insert(*first++);
        }

        array(std::initializer_list<t> l)
        {
            for (t _t : l) insert(_t);
        }

        void insert(const t& data)
        {
            set_iterator<key_value<long long, t>> _last = set<key_value<long long, t>>::last();
            if (_last.is_header())
                dictionary<long long, t>::insert(0, data);
            else
            {
                dictionary<long long, t>::insert(_last->key + 1, data);
            }
        }

        array& operator>>(long long key) { dictionary<long long, t>::erase(key); return *this; }

        array& operator<<(const t& _t)
        {
            push(_t);
            return *this;
        }

        array& operator>>(t& _t)
        {
            _t = pop();
            return *this;
        }

        void push(const t& data)
        {
            dictionary_iterator<long long, t> i = dictionary<long long, t>::last();
            i--;
            if (i.is_header())
                (*this)[0] = data;
            else
                (*this)[(*i).key + 1] = data;
        }

        t pop()
        {
            dictionary_iterator<long long, t> i = dictionary<long long, t>::last();
            if (i.is_header())
                throw entry_not_found_exception();
            else
            {
                t r = (*i).value;
                dictionary<long long, t>::erase((*i).key);
                return r;
            }
        }

        bool contiguous() const
        {
            long long l = set<key_value, long long, t >> ::length();
            if (l == 0) return true;
            set_iterator<key_value<long long, t>> i = set<key_value<long long, t>>::last();
            long long k = (*i).key;
            return l == k + 1;
        }
    };

    export template<class t>
        inline std::ostream& operator<<(std::ostream& s, const array<t>& o)
    {
        s << string(L"{");
        typename::array<t>::iterator e = o.end();
        typename::array<t>::iterator l = e - 1;
        for (typename::array<t>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t>
        inline std::wostream& operator<<(std::wostream& s, const array<t>& o)
    {
        s << string(L"{");
        typename::array<t>::iterator e = o.end();
        typename::array<t>::iterator l = e - 1;
        for (typename::array<t>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t>
        oarchive& operator<<(oarchive& s, const array<t>& o)
    {
        s << o.length();
        typename::array<t>::iterator e = o.end();
        for (typename::array<t>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i;
        }
        return s;
    }


    export template<class t>
        iarchive& operator>>(iarchive& s, array<t>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o << _t;
        }
        return s;
    }

    export template <class k, class t, class compare, class less = core::less<t>>
        struct tree : public set< t, less>
    {
        typedef set_iterator<t> iterator;

        tree() {}

        tree(std::initializer_list<t> l)
        {
            for (t _t : l) insert(_t);
        }

        t& operator[](const k& key)
        {
            iterator i = find(key);
            return *i;
        }

        void erase(const k& key)
        {
            node* root_node = set<t, less>::header.parent;

            for (; ; )
            {
                if (root_node == 0) throw entry_not_found_exception();

                int result = compare()(key, ((set_node<t>*)root_node)->element);

                if (result < 0)
                    root_node = root_node->left;

                else if (result > 0)
                    root_node = root_node->right;

                else // Item is found
                {
                    if (root_node->left != 0 && root_node->right != 0)
                    {
                        node* replace = root_node->left;
                        while (replace->right != 0) replace = replace->right;
                        swap_nodes(root_node, replace);
                    }

                    node* parent = root_node->parent;

                    long long from = (parent->left == root_node) ? direction::from_left : direction::from_right;

                    if (root_node->left == 0)
                    {
                        if (parent == &(set<t, less>::header))
                            set<t, less>::header.parent = root_node->right;
                        else if (from == direction::from_left)
                            parent->left = root_node->right;
                        else
                            parent->right = root_node->right;

                        if (root_node->right != 0) root_node->right->parent = parent;
                    }
                    else
                    {
                        if (parent == &(set<t, less>::header))
                            set<t, less>::header.parent = root_node->left;
                        else if (from == direction::from_left)
                            parent->left = root_node->left;
                        else
                            parent->right = root_node->left;

                        if (root_node->left != 0) root_node->left->parent = parent;
                    }

                    adjust_remove(parent, from);
                    delete (set_node<t>*)root_node;
                    break;
                }
            }
        }

        bool contains(const k& key) const
        {
            if (!set<t, less>::header.parent)
                return false;
            else
            {
                const node* search_node = set<t, less>::header.parent;

                do
                {
                    int result = compare()(key, ((set_node<t>*)search_node)->element);

                    if (result < 0) search_node = search_node->left;

                    else if (result > 0) search_node = search_node->right;

                    else break;

                } while (search_node);

                if (search_node == 0) return false; else return true;
            }
        }

        iterator find(const k& key) const
        {
            if (!set<t, less>::header.parent)
                throw entry_not_found_exception();
            else
            {
                const node* search_node = set<t, less>::header.parent;

                do
                {
                    int result = compare()(key, ((set_node<t>*)search_node)->element);

                    if (result < 0) search_node = search_node->left;

                    else if (result > 0) search_node = search_node->right;

                    else break;

                } while (search_node);

                if (search_node == 0) throw entry_not_found_exception();

                return (node*)search_node;
            }
        }

        t* locate(const k& key) const
        {
            if (!set<t, less>::header.parent)
                return 0;
            else
            {
                const node* search_node = set<t, less>::header.parent;

                do
                {
                    int result = compare()(key, ((set_node<t>*)search_node)->element);

                    if (result < 0) search_node = search_node->left;

                    else if (result > 0) search_node = search_node->right;

                    else break;

                } while (search_node);

                if (search_node == 0) return 0;

                return &((set_node<t>*)search_node)->element;
            }
        }
    };

    export template<class k, class t, class compare, class less = core::less<t>>
        oarchive& operator<<(oarchive& s, const tree<k, t, compare, less>& o)
    {
        s << o.length();
        typename::set<t, less>::iterator e = o.end();
        for (typename::set<t, less>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i;
        }
        return s;
    }

    export template<class k, class t, class compare, class less = core::less<t>>
        iarchive& operator>>(iarchive& s, tree<k, t, compare, less>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o << _t;
        }
        return s;
    }

    export template<class t, class compare = core::compare<t>>
        oarchive& operator<<(oarchive& s, const linked_list<t, compare> o)
    {
        s << o.length();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class compare = core::compare<t>>
        iarchive& operator>>(iarchive& s, linked_list<t, compare>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o << _t;
        }
        return s;
    }

    export template<class t, class compare = core::compare<t>>
        oarchive& operator<<(oarchive& s, const list<t, compare> o)
    {
        s << o.length();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t, class compare = core::compare<t>>
        iarchive& operator>>(iarchive& s, list<t, compare>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o << _t;
        }
        return s;
    }

    template<class t, class compare>
    struct quick
    {
        t* array;

        quick(t* base, unsigned long long entries) : array(base)
        {
            if (entries > 1) sort(0, entries - 1);
        }

        void sort(long long low, long long high)
        {
            long long pivot = partition(low, high);
            if (low < pivot - 1) sort(low, pivot - 1);
            if (pivot + 1 < high)  sort(pivot + 1, high);
        }

        long long partition(long long low, long long high)
        {
            if (low + 1 == high)
            {
                if (compare()((*this)[low], (*this)[high]) > 0)
                    swap(low, high);
                return low;
            }
            else
            {
                swap(low, (low + high) / 2);
                t& pivot = (*this)[low];

                long long i = low + 1;
                long long j = high;

                while (i < j)
                {
                    while (i < j && compare()((*this)[i], pivot) < 0)  i++;
                    while (i < j && compare()((*this)[j], pivot) >= 0) j--;
                    if (i != j) { swap(i, j); i++; j--; }
                }

                if (compare()((*this)[i], pivot) >= 0) i--;

                if (i != low) swap(i, low);

                return i;
            }
        }

        void swap(long long first, long long last)
        {
            t temporary = array[first];
            array[first] = array[last];
            array[last] = temporary;
        }

        t& operator[](long long index) { return array[index]; }
    };

    export template <class t, class compare = core::compare<t>>
        void quick_sort(t* array, unsigned long long entries)
    {
        quick<t, compare> sort(array, entries);
    };

    // *** date and time classes ***

    export bool is_leap_year(unsigned year)
    {
        return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 ? true : false;
    }

    export enum
    {
        Sunday = 0,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday
    };

    export enum
    {
        January = 1,
        February,
        March,
        April,
        May,
        June,
        July,
        August,
        September,
        October,
        November,
        December
    };

    export struct date // My brother Paul is responsible for this class.
    {
        unsigned year;
        unsigned julian;

        date();

        date(unsigned day,
            unsigned month,
            unsigned year);

        date(unsigned julian,
            unsigned year);

        date(const date& date);

        date& operator=(const date& date);

        void get();

        unsigned get_day() const;
        unsigned get_month() const;
        unsigned get_year() const { return year; }

        unsigned Julian() const { return julian; }

        operator unsigned() const;               // returns month
        unsigned get_day_of_week() const;

        date& operator+=(unsigned days_add);
        date& operator-=(unsigned days_minus);

        date& operator++() { return *this += 1; }
        date& operator--() { return *this -= 1; }

        date operator++(int) { date d = *this; *this += 1; return d; }
        date operator--(int) { date d = *this; *this -= 1; return d; }

        bool is_leap_year() const { return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 ? true : false; }

        date& add_month();
        date& subtract_month();

        date& add_year();
        date& subtract_year();

        int days_to_month_end();
        int days_to_year_end();

        friend int __declspec(dllexport) operator-(const date& date1, const date& date2);

        inline friend bool operator==(const date& date1, const date& date2)
        {
            return (bool)(date1.year == date2.year && date1.julian == date2.julian);
        }

        inline friend bool operator!=(const date& date1, const date& date2)
        {
            return (bool)(date1.year != date2.year || date1.julian != date2.julian);
        }

        inline friend bool operator<=(const date& date1, const date& date2)
        {
            return (bool)(date1.year < date2.year || (date1.year == date2.year && date1.julian <= date2.julian));
        }

        inline friend bool operator>=(const date& date1, const date& date2)
        {
            return (bool)(date1.year > date2.year || (date1.year == date2.year && date1.julian >= date2.julian));
        }

        inline friend bool operator<(const date& date1, const date& date2)
        {
            return (bool)(date1.year < date2.year || (date1.year == date2.year && date1.julian < date2.julian));
        }

        inline friend bool operator>(const date& date1, const date& date2)
        {
            return (bool)(date1.year > date2.year || (date1.year == date2.year && date1.julian > date2.julian));
        }
    };

    export struct difference
    {
        unsigned hour;         // Range: 0 - 23
        unsigned minute;       // Range: 0 - 59
        unsigned second;       // Range: 0 - 59
        unsigned millisecond;  // Range: 0 - 99
        unsigned day;          // Days difference

        difference();
    };

    export enum time_compare
    {
        time_less = -1,
        time_equal = 0,
        time_greater = 1
    };

    export struct time
    {
        unsigned year;
        unsigned month;
        unsigned day_of_week;
        unsigned day;
        unsigned hour;
        unsigned minute;
        unsigned second;
        unsigned millisecond;

        time(unsigned year,
            unsigned month = 0,
            unsigned day_of_week = 0,
            unsigned day = 0,
            unsigned hour = 0,
            unsigned minute = 0,
            unsigned second = 0,
            unsigned millisecond = 0);

        time(const date& date);

        time();

        operator date() const;
    };

    time_compare operator==(const time& time_first,
        const time& time_second);

    difference operator-(const time& time_first,
        const time& time_second);


    export std::ostream& operator<<(std::ostream& os, const difference& d)
    {
        os << d.day << ":" << d.hour << ":" << d.minute << ":" << d.second << ":" << d.millisecond; return os;
    }

    static unsigned day_table[2][12] =
    {
     {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
     {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
    };

    static unsigned days_cumulative[2][13] =
    {
     {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
     {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}
    };


    date::date()
    {
        time time_query;
        *this = date(time_query.day,
            (unsigned)time_query.month,
            time_query.year);
    }

    date& date::operator=(const date& date_assign)
    {
        year = date_assign.year;
        julian = date_assign.julian;
        return *this;
    }

    void date::get()
    {
        time time_query;
        *this = (date)time_query;
    }

    date::date(unsigned day,
        unsigned month_date,
        unsigned year_set)
        : year(year_set),
        julian(day)
    {
        if (month_date > 12) throw month_is_invalid_exception();

        if (day > day_table[is_leap_year()][month_date - 1])
            throw day_of_month_is_invalid_exception();

        if (month_date < January || month_date > December)
            throw month_is_invalid_exception();

        bool decide_leap_year = is_leap_year();
        for (unsigned index = January; index < (unsigned)month_date; index++)
            julian += day_table[decide_leap_year][index - 1];
    }

    date::date(unsigned julian_set,
        unsigned year_set)
        : year(year_set),
        julian(julian_set)
    {
        if (julian_set > (unsigned)(365 + is_leap_year()))
            throw julian_day_is_invalid_exception();
    }

    date::date(const date& date_copy)
        : year(date_copy.year),
        julian(date_copy.julian) {}

    date& date::operator+=(unsigned days_add)
    {
        unsigned total_days = julian + days_add;

        while (total_days > (unsigned)(365 + is_leap_year()))
        {
            total_days -= 365 + is_leap_year();
            year++;
        }

        julian = total_days;
        return *this;
    }

    date& date::operator-=(unsigned days_minus)
    {
        int total_days = (int)julian - (int)days_minus;

        while (total_days <= 0)
        {
            year--;
            total_days += 365 + is_leap_year();
        }

        julian = (unsigned)total_days;
        return *this;
    }

    int operator-(const date& date1, const date& date2)
    {
        int years_difference = (int)date1.year - (int)date2.year;

        if (!years_difference)
            return (int)date1.julian - (int)date2.julian;

        else
        {
            unsigned  year = (years_difference > 0) ? date2.year : date1.year;

            int days_difference = (years_difference > 0) ? 365 + is_leap_year(year) - date2.julian
                : -365 - is_leap_year(year) + date1.julian;
            while (years_difference)
            {
                if (years_difference > 0)
                {
                    if (!--years_difference)
                        days_difference += date1.julian;
                    else
                    {
                        year++;
                        days_difference += 365 + is_leap_year(year);
                    }
                }
                else
                {
                    if (!++years_difference)
                        days_difference -= date2.julian;
                    else
                    {
                        year++;
                        days_difference -= 365 + is_leap_year(year);
                    }
                }
            }
            return days_difference;
        }
    }

    unsigned date::get_month() const
    {
        bool decide_leap_year = is_leap_year();
        unsigned month = 0;
        while (julian > days_cumulative[decide_leap_year][month]) month++;
        return month;
    }

    date::operator unsigned() const
    {
        bool decide_leap_year = is_leap_year();
        unsigned month = 0;
        while (julian > days_cumulative[decide_leap_year][month]) month++;
        return month;
    }

    unsigned date::get_day() const
    {
        bool decide_leap_year = is_leap_year();
        unsigned month = 0;
        while (julian > days_cumulative[decide_leap_year][month]) month++;
        return julian - days_cumulative[decide_leap_year][month - 1];
    }

    unsigned date::get_day_of_week() const
    {
        date date_reference(1, January, 1995);  // Is a Sunday

        int days_difference = *this - date_reference;

        unsigned day_return = (days_difference > 0) ? (days_difference % 7 + 1)
            : ((7 + (days_difference % 7)) % 7 + 1);
        return day_return;
    }

    int date::days_to_month_end()
    {
        return (day_table[is_leap_year()][get_month()] - get_day());
    }

    int date::days_to_year_end()
    {
        return ((365 + is_leap_year()) - julian);
    }

    date& date::add_month()
    {
        if ((unsigned)*this == 4 || (unsigned)*this == 6 || (unsigned)*this == 9 || (unsigned)*this == 11)
            *this += 30;

        else if ((unsigned)*this == 2)
            *this += 28 + is_leap_year();

        else if ((unsigned)*this == 1)
        {
            if (get_day() <= (unsigned)(28 + is_leap_year()))
                *this += 31;
            else
                julian = 59 + is_leap_year();
        }

        else if (((unsigned)*this == 7) || ((unsigned)*this == 12))
            *this += 31;

        else if ((unsigned)*this == 3 || (unsigned)*this == 5 || (unsigned)*this == 8 || (unsigned)*this == 10)
        {
            if (get_day() <= 30)
                *this += 31;
            else
                *this += 30;
        }

        return *this;
    }

    date& date::subtract_month()
    {
        if ((unsigned)*this == 1 ||
            (unsigned)*this == 2 ||
            (unsigned)*this == 4 ||
            (unsigned)*this == 6 ||
            (unsigned)*this == 8 ||
            (unsigned)*this == 9 ||
            (unsigned)*this == 11)
            *this -= 31;

        else if ((unsigned)*this == 3)
        {
            if (get_day() <= (unsigned)(28 + is_leap_year()))
                *this -= 28 + is_leap_year();
            else
                julian = 59 + core::is_leap_year(year);
        }

        else if ((unsigned)*this == 5 || (unsigned)*this == 7 || (unsigned)*this == 10 || (unsigned)*this == 12)
        {
            if (get_day() <= 30)
                *this -= 30;
            else
                *this -= 31;
        }

        return *this;
    }

    date& date::add_year()
    {
        if (julian < 60)
            *this += 365 + is_leap_year();

        else if (julian > 60)
            *this += 365 + core::is_leap_year(year + 1);

        else if (julian == 60)
            *this += is_leap_year() ? 365 : 365 + core::is_leap_year(year + 1);

        return *this;
    }

    date& date::subtract_year()
    {
        if (!year)
            julian = 0;

        else if (julian < 60)
            *this -= 365 + core::is_leap_year(year - 1);

        else if (julian > 60)
            *this -= 365 + is_leap_year();

        else if (julian == 60)
            *this -= is_leap_year() ? 366 : 365;

        return *this;
    }

    const char* date_suffix(const date& date_to_suffix)
    {
        enum { th, st, nd, rd } suffix = th;

        int day = date_to_suffix.get_day();
        int day_mod_10 = day % 10;
        int day_mod_100 = day % 100;

        if (!(day_mod_100 >= 10 && day_mod_100 <= 20))
            switch (day_mod_10)
            {
            case 1:
                suffix = st;
                break;

            case 2:
                suffix = nd;
                break;

            case 3:
                suffix = rd;
                break;

            default: break;
            }

        static const char* suffix_strings[] = { "th",
                                                "st",
                                                "nd",
                                                "rd" };

        return suffix_strings[suffix];
    }

 
    export struct systime
    {
        int hour;          // Range: 0 - 23
        int minute;        // Range: 0 - 59
        int second;        // Range: 0 - 59
        int millisecond;   // Range: 0 - 999
        int day;           // Current day of the month. Range: 1 - 31
        int month;         // Current month of the year. Range: 1 - 12
        int year;          // Current year
    };

    export time_compare operator==(const time& time_first,
        const time& time_second)
    {
        register int result;

        if (time_first.year != time_second.year)
        {
            result = (int)time_first.year -
                (int)time_second.year;
        }

        else if (time_first.month != time_second.month)
        {
            result = (int)time_first.month -
                (int)time_second.month;
        }

        else if (time_first.day != time_second.day)
        {
            result = (int)time_first.day -
                (int)time_second.day;
        }

        else if (time_first.hour != time_second.hour)
        {
            result = (int)time_first.hour -
                (int)time_second.hour;
        }

        else if (time_first.minute != time_second.minute)
        {
            result = (int)time_first.minute -
                (int)time_second.minute;
        }

        else if (time_first.second != time_second.second)
        {
            result = (int)time_first.second -
                (int)time_second.second;
        }

        else if (time_first.millisecond != time_second.millisecond)
        {
            result = (int)time_first.millisecond -
                (int)time_second.millisecond;
        }

        else result = 0;

        if (result == 0)
            return time_equal;

        else if (result < 0)
            return time_less;

        else
            return time_greater;
    }

    export difference::difference()
        : hour(0),
        minute(0),
        second(0),
        millisecond(0),
        day(0) {}


    time::operator date() const { return date(day, month, year); }


    export template<class t, class compare>
        std::ostream& operator<<(std::ostream& s, const list <t, compare>& o)
    {
        s << string(L"{");
        typename::list<t, compare>::iterator e = o.end();
        typename::list<t, compare>::iterator l = o.last();
        for (typename::list<t, compare>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t>
        struct stack_node
    {
        stack_node<t>* next;
        t data;

        stack_node(const t& data_set) : data(data_set) {}

        void* operator new(size_t s) { return allocate_from_heap(s); }

        void operator delete(void* p) { free_from_heap(p); }
    };

    export template<class t>
        struct stack_header
    {
        stack_node<t>* next;
    };

    export template <class t>
        struct stack_iterator
    {
        stack_node<t>* node;

        stack_iterator() : node(0) {}

        stack_iterator(const stack_node<t>& in) : node((stack_node<t>*)& in) {}

        t& operator*() const
        {
            return node->data;
        }

        t* operator->() const
        {
            return &(node->data);
        }

        t* operator&() const
        {
            return &(node->data);
        }

        stack_iterator& operator++()
        {
            node = node->next; return *this;
        }

        stack_iterator operator++(int)
        {
            stack_iterator<t> save = *this; ++* this;return save;
        }

        stack_iterator& operator+=(unsigned long long increment)
        {
            for (unsigned long long i = 0; i < increment; i++)++* this; return *this;
        }

        stack_iterator operator+(unsigned long long increment) const
        {
            stack_iterator<t> result(*this);
            for (unsigned long long i = 0; i < increment; i++) ++result;
            return result;
        }

        bool operator==(const stack_iterator& y) const { return node == y.node; }

        bool operator!=(const stack_iterator& y) const { return node != y.node; }

        long long operator-(stack_iterator iter) const
        {
            long long result = 0;
            while (iter++ != *this) { result++; }
            return result;
        }
    };

    export template <class t>
        struct stack    // circular, singly-linked list (with merge sort).
    {
        stack_header<t> tail; // header node for the list.
        unsigned long long nodes;    // fast access to list size.

        typedef stack_iterator<t> iterator;

        stack() : nodes(0)
        {
            tail.next = (stack_node<t>*) & tail;
        }

        stack(const stack<t>& copy) : nodes(0)
        {
            tail.next = (stack_node<t>*) & tail;
            for (t _t : copy) *this << _t;
        }

        template<class I>
        stack(I first, I last)
        {
            nodes = 0;
            tail.next = (stack_node<t>*) & tail;
            while (first != last) *this << *first++;
        }

        stack(std::initializer_list<t> l)
        {
            nodes = 0;
            tail.next = (stack_node<t>*) & tail;
            for (t _t : l) *this << _t;
        }

        ~stack() { erase(); }

        stack<t>& operator=(const stack& copy)
        {
            erase();
            for (t _t : copy) *this << _t;
            return *this;
        }

        void erase()
        {
            stack_node<t>* n = tail.next;
            while (n != (stack_node<t>*) & tail)
            {
                stack_node<t>* next = n->next;
                delete n;
                n = next;
            }
            nodes = 0;
            tail.next = (stack_node<t>*) & tail;
        }

        unsigned long long length() const { return nodes; }

        stack& operator<<(const t& data) { push(data); return *this; }

        stack& operator>>(t& data) { data = pop(); return *this; }

        iterator begin() const { return *tail.next; }

        iterator end() const { return *(stack_node<t>*) & tail; }

        iterator push(const t& data)
        {
            stack_node<t>* new_node = new stack_node<t>(data);
            new_node->next = tail.next;
            tail.next = new_node;
            ++nodes;
            return *new_node;
        }

        t pop()
        {
            if (nodes == 0) throw is_list_tail_exception();
            t ret = tail.next->data;
            stack_node<t>* next = tail.next->next;
            delete tail.next;
            tail.next = next;
            nodes--;
            return ret;
        }

        iterator last() const
        {
            if (nodes == 0) throw is_list_tail_exception();
            iterator i(*tail.next);
            while (i.node->next != (stack_node<t>*) & tail) i++;
            return i;
        }
    };

    export template<class t>
        inline oarchive& operator<<(oarchive& s, const stack<t>& o)
    {
        s << o.size();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t>
        inline iarchive& operator>>(iarchive& s, stack<t>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o << _t;
        }
        return s;
    }

    export template<class t>
        std::ostream& operator<<(std::ostream& s, const stack<t>& o)
    {
        s << string(L"{");
        if (o.length() != 0)
        {
            typename::stack<t>::iterator e = o.end();
            typename::stack<t>::iterator l = o.last();
            for (typename::stack<t>::iterator i = o.begin(); i != e; ++i)
            {
                s << *i; if (i != l) s << string(L",");
            }
        }
        s << string(L"}");
        return s;
    }

    export template<class t>
        struct queue_node
    {
        queue_node<t>* previous;
        queue_node<t>* next;
        t data;

        queue_node(const t& dataSet) : data(dataSet) {}

        void* operator new(size_t s) { return allocate_from_heap(s); }

        void operator delete(void* p) { free_from_heap(p); }
    };

    export template<class t>
        struct queue_header
    {
        queue_node<t>* previous;
        queue_node<t>* next;
    };

    export template <class t>
        struct queue_iterator
    {
        queue_node<t>* node;

        queue_iterator() : node(0) {}

        queue_iterator(const queue_node<t>& in) : node((queue_node<t>*)& in) {}

        t& operator*() const
        {
            return node->data;
        }

        t* operator->() const
        {
            return &(node->data);
        }

        t* operator&() const
        {
            return &(node->data);
        }

        queue_iterator& operator++()
        {
            node = node->next; return *this;
        }

        queue_iterator operator++(int)
        {
            queue_iterator save = *this; ++* this;return save;
        }

        queue_iterator& operator+=(unsigned long long increment)
        {
            for (unsigned long long i = 0; i < increment; i++)++* this; return *this;
        }

        queue_iterator operator+(unsigned long long increment) const
        {
            queue_iterator result(*this);
            for (unsigned long long i = 0; i < increment; i++) ++result;
            return result;
        }

        queue_iterator& operator--()
        {
            node = node->previous; return *this;
        }

        queue_iterator operator--(int)
        {
            queue_iterator save = *this; --* this;return save;
        }

        queue_iterator& operator-=(unsigned long long decrement)
        {
            for (unsigned long long i = 0; i < decrement; i++)--* this; return *this;
        }

        queue_iterator operator-(unsigned long long decrement) const
        {
            queue_iterator result(*this);
            for (unsigned long long i = 0; i < decrement; i++) --result;
            return result;
        }

        bool operator==(const queue_iterator& y) const { return node == y.node; }

        bool operator!=(const queue_iterator& y) const { return node != y.node; }

        const t& operator[](long long i) const { return i >= 0 ? *(*this + i) : *(*this - -i); }

        long long operator-(queue_iterator iter) const
        {
            long long result = 0;
            while (iter++ != *this) { result++; }
            return result;
        }
    };

    export template <class t>
        struct queue
    {
        queue_header<t> tail;
        unsigned long long nodes;

        typedef queue_iterator<t> iterator;

        queue()
        {
            nodes = 0;
            queue_node<t>* root = (queue_node<t>*) & tail;
            root->previous = root;
            root->next = root;
        }

        template<class I>
        queue(I first, I last)
        {
            nodes = 0;
            queue_node<t>* root = (queue_node<t>*) & tail;
            root->previous = root;
            root->next = root;
            while (first != last) enqueue(*first++);
        }

        queue(std::initializer_list<t> l)
        {
            nodes = 0;
            queue_node<t>* root = (queue_node<t>*) & tail;
            root->previous = root;
            root->next = root;
            for (t _t : l) enqueue(_t);
        }

        ~queue() { erase(); }

        queue(const queue& copy)
        {
            queue_node<t>* root = (queue_node<t>*) & tail;
            root->previous = root;
            root->next = root;
            nodes = 0;
            for (t _t : copy) enqueue(_t);
        }

        queue& operator=(const queue& copy)
        {
            if (nodes) erase();
            for (t _t : copy) enqueue(_t);
            return *this;
        }

        unsigned long long length() const { return nodes; }

        queue& operator<<(const t& data) { enqueue(data); return *this; }

        queue& operator>>(t& data) { data = dequeue(); return *this; }

        iterator begin() const { return *(queue_node<t>*)tail.next; }

        iterator end() const { return *(queue_node<t>*) & tail; }

        iterator enqueue(const t& data)
        {
            queue_node<t>* new_node = new queue_node<t>(data);
            tail.next->previous = new_node;
            new_node->next = tail.next;
            tail.next = new_node;
            new_node->previous = (queue_node<t>*) & tail;
            ++nodes;
            return *new_node;
        }

        t dequeue()
        {
            queue_node<t>* last = tail.previous;
            if (last != (queue_node<t>*) & tail)
            {
                last->previous->next = (queue_node<t>*) & tail;
                tail.previous = last->previous;
            }
            else
                throw is_list_tail_exception();
            t r = last->data;
            delete last;
            nodes--;
            return r;
        }

        void erase()
        {
            queue_node<t>* n = tail.next;
            while (n != (queue_node<t>*) & tail)
            {
                queue_node<t>* next = n->next;
                delete n;
                n = next;
            }
            queue_node<t>* root = (queue_node<t>*) & tail;
            root->previous = root;
            root->next = root;
            nodes = 0;
        }

        iterator last() const { return *tail.previous; }

        t& front()
        {
            queue_node<t>* f = tail.next;
            if (f == (queue_node<t>*) & tail) throw is_list_tail_exception();
            return f->data;
        }

        const t& front() const
        {
            queue_node<t>* f = tail.next;
            if (f == (queue_node<t>*) & tail) throw is_list_tail_exception();
            return f->data;
        }

        t& back()
        {
            queue_node<t>* b = tail.previous;
            if (b == (queue_node<t>*) & tail) throw is_list_tail_exception();
            return b->data;
        }

        const t& back() const
        {
            queue_node<t>* b = tail.previous;
            if (b == (queue_node<t>*) & tail) throw is_list_tail_exception();
            return b->data;
        }

        void sort()
        {
            queue_node<t>* root = (queue_node<t>*) & tail;
            if (nodes > 1) merge_sort<t, compare>(root);
        }
    };


    export template<class t>
        std::ostream& operator<<(std::ostream& s, const queue<t>& o)
    {
        s << string(L"{");
        typename::queue<t>::iterator e = o.end();
        typename::queue<t>::iterator l = e; l--;
        for (typename::queue<t>::iterator i = o.begin(); i != e; ++i)
        {
            s << *i; if (i != l) s << string(L",");
        }
        s << string(L"}");
        return s;
    }

    export template<class t>
        oarchive& operator<<(oarchive& s, const queue<t>& o)
    {
        s << o.length();
        for (t _t : o) s << _t;
        return s;
    }

    export template<class t>
        iarchive& operator>>(iarchive& s, queue<t>& o)
    {
        long long length;
        s >> length;
        for (long long i = 0; i < length; i++)
        {
            t _t;
            s >> _t;
            o << _t;
        }
        return s;
    }

    export template <class k, class t, class compare, class less = core::less<t>>
        struct multitree : public multiset< t, less>
    {
        typedef set_iterator<t> iterator;

        multitree() {}

        multitree(std::initializer_list<t> l)
        {
            for (t _t : l) insert(_t);
        }

        list<t> operator[](const k& key) const
        {
            return find(key);
        }

        void erase(const k& element)
        {
            if (!multiset<t, less>::header.parent)
                throw entry_not_found_exception();
            else
            {
                const node* search_node = multiset<t, less>::header.parent;

                do
                {
                    int c = compare()(element, ((set_node<t>*)search_node)->element);
                    if (c < 0)  search_node = search_node->left;
                    else if (c > 0) search_node = search_node->right;
                    else break;

                } while (search_node);

                if (search_node == 0) throw entry_not_found_exception();

                iterator i((node*)search_node); // backup while equals
                i--;
                while (!i.is_header() && !compare()(element, *i)) i--;
                i++;

                list<iterator> to_erase;

                for (;;)
                {
                    to_erase << i;
                    i++;
                    if (i.is_header()) break;
                    if (compare()(element, *i)) break;
                }

                for (iterator i : to_erase) multiset<t, less>::erase(i);
            }
        }

        bool contains(const k& key) const
        {
            if (!set<t, less>::header.parent)
                return false;
            else
            {
                const node* search_node = set<t, less>::header.parent;

                do
                {
                    int result = compare()(key, ((set_node<t>*)search_node)->element);

                    if (result < 0) search_node = search_node->left;

                    else if (result > 0) search_node = search_node->right;

                    else break;

                } while (search_node);

                if (search_node == 0) return false; else return true;
            }
        }

        list<t> find(const k& element) const
        {
            if (!multiset<t, less>::header.parent)
                throw entry_not_found_exception();
            else
            {
                const node* search_node = multiset<t, less>::header.parent;

                do
                {
                    int c = compare()(element, ((set_node<t>*)search_node)->element);
                    if (c < 0) { search_node = search_node->left; }
                    else if (c > 0) search_node = search_node->right;
                    else break;
                } while (search_node);

                if (search_node == 0) throw entry_not_found_exception();

                list<t> ret;

                iterator i((node*)search_node); // backup while equals
                i--;
                while (!i.is_header() && !compare()(element, *i)) i--;
                i++;

                for (;;)
                {
                    ret << *i;
                    i++;
                    if (i.is_header()) break;
                    if (compare()(element, *i)) break;
                }

                return ret;
            }
        }

    };

    export  typedef void* handle;
    export  typedef wchar_t character;
    export  typedef unsigned short ushort;
    export  typedef unsigned char byte;
    export  typedef signed char sbyte;
    export  typedef unsigned uint;
    export  typedef unsigned long long parameter;
    export  typedef long long result;
    export  typedef ushort atom;
    export  typedef ushort part;
    export  typedef unsigned long long ulong;
    export  typedef unsigned char byte;
    export  typedef unsigned char byte;

    export template<class t> t maximum(t a, t b) { return a > b ? a : b; };
    export template<class t> t minimum(t a, t b) { return a < b ? a : b; };

    export template<class character>
        void reverse(character* toreverse);

    export struct xform
    {
        float number00;
        float number01;
        float number10;
        float number11;
        float offset_x;
        float offset_y;
    };

    export template<class t, uint dimension>
        struct vector
    {
        t elements[dimension];

        vector()
        {
            for (uint j = 0; j < dimension; j++)
                elements[j] = 0;
        }

        vector(const t* const elements_set)
        {
            for (uint j = 0; j < dimension; j++)
                elements[j] = elements_set[j];
        }

        t& operator()(uint row) { return elements[row]; }

        const t& operator()(uint row) const { return elements[row]; }

        bool operator==(const vector& _vector) const
        {
            for (uint i = 0; i < dimension; i++)
                if (elements[i] != _vector.elements[i])
                    return false;

            return true;
        }

        bool operator!=(const vector& _vector) const
        {
            for (uint i = 0; i < dimension; i++)
                if (elements[i] != _vector.elements[i])
                    return true;

            return false;
        }

        vector operator+() const
        {
            vector result;

            for (uint i = 0; i < dimension; i++)
                result.elements[i] = elements[i];

            return result;
        }

        vector operator-() const
        {
            vector result;

            //    for (uint i = 0; i < dimension; i++)
            //        result.elements[i] = -elements[i];

            return result;
        }

        vector operator+(const vector& _vector) const
        {
            vector result;

            for (uint i = 0; i < dimension; i++)
                result.elements[i] = elements[i] + _vector.elements[i];

            return result;
        }

        vector operator-(const vector& _vector) const
        {
            vector result;

            for (uint i = 0; i < dimension; i++)
                result.elements[i] = elements[i] - _vector.elements[i];

            return result;
        }

        vector& operator+=(const vector& _vector)
        {
            for (uint i = 0; i < dimension; i++)
                elements[i] = elements[i] + _vector.elements[i];

            return *this;
        }

        vector& operator-=(const vector& _vector)
        {
            for (uint i = 0; i < dimension; i++)
                elements[i] = elements[i] - _vector.elements[i];

            return *this;
        }

        vector operator*(const t& t) const
        {
            vector result;

            for (uint i = 0; i < dimension; i++)
                result.elements[i] = elements[i] * t;

            return result;
        }

        vector operator/(const t& t) const
        {
            vector result;

            for (uint i = 0; i < dimension; i++)
                result.elements[i] = elements[i] / t;

            return result;
        }

        vector& operator*=(const t& t)
        {
            for (uint i = 0; i < dimension; i++)
                elements[i] = elements[i] * t;

            return *this;
        }

        vector& operator/=(const t& t)
        {
            for (uint i = 0; i < dimension; i++)
                elements[i] = elements[i] / t;

            return *this;
        }

        t operator*(const vector& _vector) const
        {
            t type_result = 0;

            for (uint i = 0; i < dimension; i++)
                type_result += elements[i] * _vector.elements[i];

            return type_result;
        }

        uint rows() const { return dimension; }

        uint dimensions() const { return dimension; }
    };

    export struct ipoint : public vector<int, 2>
    {
        ipoint(int x = 0, int y = 0)
        {
            (*this)(0) = x; (*this)(1) = y;
        }

        ipoint(const int* pxy)
        {
            (*this)(0) = *pxy; (*this)(1) = *(pxy + 1);
        }
    };

    export  bool operator==(const ipoint& a, const ipoint& b)
    {
        return a(0) == b(0) && a(1) == b(1);
    }

    export  bool operator!=(const ipoint& a, const ipoint& b)
    {
        return a(0) != b(0) || a(1) != b(1);
    }

    export  ipoint operator+(const ipoint& a, const ipoint& b)
    {
        return ipoint(a(0) + b(0), a(1) + b(1));
    }

    export  ipoint operator-(const ipoint& a, const ipoint& b)
    {
        return ipoint(a(0) - b(0), a(1) - b(1));
    }

    export  typedef ipoint idimensions;

    export  ipoint operator*(int multiplier, const ipoint& multiplicand)
    {
        return ipoint(multiplier * multiplicand(0), multiplier * multiplicand(1));
    }

    export  ipoint operator*(const ipoint& multiplier, int multiplicand)
    {
        return ipoint(multiplicand * multiplier(0), multiplicand * multiplier(1));
    }

    export  ipoint operator/(const ipoint& dividend, int divisor)
    {
        return ipoint(dividend(0) / divisor, dividend(1) / divisor);
    }

    export  typedef ipoint size;

    export struct point2 : public vector<double, 2>
    {
        point2(double x = 0, double y = 0)
        {
            (*this)(0) = x; (*this)(1) = y;
        }

        point2(const double* pxy)
        {
            (*this)(0) = *pxy; (*this)(1) = *(pxy + 1);
        }

        ipoint to_ipoint() const { return ipoint((*this)(0), (*this)(1)); }
    };

    export  bool operator==(const point2& a, const point2& b)
    {
        return a(0) == b(0) && a(1) == b(1);
    }

    export  bool operator!=(const point2& a, const point2& b)
    {
        return a(0) != b(0) || a(1) != b(1);
    }

    export  point2 operator+(const point2& a, const point2& b)
    {
        return point2(a(0) + b(0), a(1) + b(1));
    }

    export  double operator-(const point2& a, const point2& b)
    {
        return a(0) * b(0) + a(1) * b(1);
    }

    export  point2 operator*(double multiply, const point2& multiplier)
    {
        return point2(multiply * multiplier(0), multiply * multiplier(1));
    }

    export  point2 operator*(const point2& multiplier, double multiply)
    {
        return point2(multiply * multiplier(0), multiply * multiplier(1));
    }

    export  point2 operator/(const point2& dividend, double divisor)
    {
        return point2(dividend(0) / divisor, dividend(1) / divisor);
    }

    export  typedef point2 idimensions2;

    export struct pointf : public vector<float, 2>
    {
        pointf(double x = 0, double y = 0)
        {
            (*this)(0) = x; (*this)(1) = y;
        }

        pointf(const double* pxy)
        {
            (*this)(0) = *pxy; (*this)(1) = *(pxy + 1);
        }

        pointf(const pointf& copy)
        {
            (*this)(0) = copy(0); (*this)(1) = copy(1);
        }
    };

    export  bool operator==(const pointf& a, const pointf& b)
    {
        return a(0) == b(0) && a(1) == b(1);
    }

    export  bool operator!=(const pointf& a, const pointf& b)
    {
        return a(0) != b(0) || a(1) != b(1);
    }

    export  pointf operator+(const pointf& a, const pointf& b)
    {
        return pointf(a(0) + b(0), a(1) + b(1));
    }

    export  double operator-(const pointf& a, const pointf& b)
    {
        return a(0) * b(0) + a(1) * b(1);
    }

    export  pointf operator*(double multiply, const pointf& multiplier)
    {
        return pointf(multiply * multiplier(0), multiply * multiplier(1));
    }

    export  pointf operator*(const pointf& multiplier, double multiply)
    {
        return pointf(multiply * multiplier(0), multiply * multiplier(1));
    }

    export  pointf operator/(const pointf& dividend, double divisor)
    {
        return pointf(dividend(0) / divisor, dividend(1) / divisor);
    }

    export  typedef pointf sizef;

    export template<class t, uint rows, uint columns>
        struct matrix
    {
        t elements[rows][columns];

        matrix()
        {
            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    elements[i][j] = 0;
        }

        matrix(const t* const elements_set)
        {
            for (uint i = 0; i < rows; i++)
            {
                uint offset = i * columns;
                for (uint j = 0; j < columns; j++)
                    elements[i][j] = elements_set[offset + j];
            }
        }

        matrix operator+() const
        {
            matrix result;

            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    result.elements[i][j] = +elements[i][j];

            return result;
        }

        matrix operator-() const
        {
            matrix result;

            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    result.elements[i][j] = -elements[i][j];

            return result;
        }

        bool operator==(const matrix& _matrix) const
        {
            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    if (elements[i][j] != _matrix.elements[i][j])
                        return false;

            return true;
        }

        bool operator!=(const matrix& _matrix) const
        {
            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    if (elements[i][j] != _matrix.elements[i][j])
                        return true;

            return false;
        }

        matrix operator+(const matrix& _matrix) const
        {
            matrix result;

            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    result.elements[i][j] = elements[i][j] + _matrix.elements[i][j];

            return result;
        }

        matrix operator-(const matrix& _matrix) const
        {
            matrix result;

            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    result.elements[i][j] = elements[i][j] - _matrix.elements[i][j];

            return result;
        }

        matrix<t, rows, rows> operator*(const matrix<t, columns, rows>& _matrix) const
        {
            matrix<t, rows, rows> result;

            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < rows; j++)
                    for (uint k = 0; k < columns; k++)
                        result.elements[i][j] += elements[i][k] * _matrix.elements[k][j];

            return result;
        }

        matrix& operator+=(const matrix& _matrix)
        {
            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    elements[i][j] = elements[i][j] + _matrix.elements[i][j];

            return *this;
        }

        matrix& operator-=(const matrix& _matrix)
        {
            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    elements[i][j] = elements[i][j] - _matrix.elements[i][j];

            return *this;
        }

        vector<t, rows> operator*(const vector<t, columns>& _vector) const
        {
            vector<t, rows> result;

            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    result.elements[i] += elements[i][j] * _vector.elements[j];

            return result;
        }

        matrix operator*(const t& type) const
        {
            matrix result;

            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    result.elements[i][j] = elements[i][j] * type;

            return result;
        }

        matrix operator/(const t& type) const
        {
            matrix result;

            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    result.elements[i][j] = elements[i][j] / type;

            return result;
        }

        matrix& operator*=(const t& type)
        {
            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    elements[i][j] = elements[i][j] * type;

            return *this;
        }

        matrix& operator/=(const t& type)
        {
            for (uint i = 0; i < rows; i++)
                for (uint j = 0; j < columns; j++)
                    elements[i][j] = elements[i][j] / type;

            return *this;
        }

        operator const t* () const { return (const t*)elements; }

        //vector<t, columns>& operator[](uint row)
        //{
        //    return *((vector<t, columns>*)((char*)elements + (row * columns * size())));
        //}

        t& operator()(uint row, uint column)
        {
            return elements[row][column];
        }

        const t& operator()(uint row, uint column) const
        {
            return elements[row][column];
        }

        uint Rows() const { return rows; }

        uint Columns() const { return columns; }

        uint Size() const { return sizeof(t); }
    };


    export template<class t, uint n, uint m, uint p>
        matrix<t, n, p> operator*(const matrix<t, n, m>& a,
            const matrix<t, m, p>& b)
    {
        matrix<t, n, p> _p;

        for (uint i = 0; i < n; i++)
            for (uint j = 0; j < p; j++)
                for (uint k = 0; k < m; k++)
                    _p(i, j) += a(i, k) * b(k, j);

        return _p;
    }

    export struct matrix22 : public matrix<double, 2, 2>
    {
        matrix22(double f00 = 0, double f01 = 0,
            double f10 = 0, double f11 = 0)
        {
            (*this)(0, 0) = f00; (*this)(0, 1) = f01;
            (*this)(1, 0) = f10; (*this)(1, 1) = f11;
        }

        matrix22& operator+(const matrix22& matrix)
        {
            for (uint i = 0; i < matrix.Rows(); i++)
                for (uint j = 0; j < matrix.Columns(); j++)
                    elements[i][j] = elements[i][j] + matrix.elements[i][j];

            return *this;
        }
    };

    export  matrix22 operator*(double multiply,
        const matrix22& matrix_multiply)
    {
        return matrix22(matrix_multiply(0, 0) * multiply, matrix_multiply(0, 1) * multiply,
            matrix_multiply(1, 0) * multiply, matrix_multiply(1, 1) * multiply);
    }

    export  matrix22 operator*(const matrix22& matrix_multiply,
        double multiply)
    {
        return matrix22(matrix_multiply(0, 0) * multiply, matrix_multiply(0, 1) * multiply,
            matrix_multiply(1, 0) * multiply, matrix_multiply(1, 1) * multiply);
    }

    export  point2 operator*(const matrix22& matrix_multiply,
        const point2& multiply)
    {
        return point2(matrix_multiply(0, 0) * multiply(0) + matrix_multiply(0, 1) * multiply(1),
            matrix_multiply(1, 0) * multiply(0) + matrix_multiply(1, 1) * multiply(1));
    }

    export  pointf operator*(const matrix22& matrix_multiply,
        const pointf& multiply)
    {
        return pointf(matrix_multiply(0, 0) * multiply(0) + matrix_multiply(0, 1) * multiply(1),
            matrix_multiply(1, 0) * multiply(0) + matrix_multiply(1, 1) * multiply(1));
    }

    export  ipoint operator*(const matrix22& matrix_multiply,
        const ipoint& multiply)
    {
        return ipoint(matrix_multiply(0, 0) * multiply(0) + matrix_multiply(0, 1) * multiply(1),
            matrix_multiply(1, 0) * multiply(0) + matrix_multiply(1, 1) * multiply(1));
    }

    export  matrix22 operator*(const matrix22& transform_a,
        const matrix22& transform_b)
    {
        return matrix22(transform_a(0, 0) * transform_b(0, 0) + transform_a(0, 1) * transform_b(1, 0),
            transform_a(0, 0) * transform_b(0, 1) + transform_a(0, 1) * transform_b(1, 1),
            transform_a(1, 0) * transform_b(0, 0) + transform_a(1, 1) * transform_b(1, 0),
            transform_a(1, 0) * transform_b(0, 1) + transform_a(1, 1) * transform_b(1, 1));
    }

    export struct icon_information
    {
        bool icon;
        ipoint hotspot;
        handle mask;
        handle color;
    };

    export struct icon_identity
    {
        enum
        {
            application = 32512,
            hand = 32513,
            question = 32514,
            exclamation = 32515,
            asterisk = 32516,
            logo = 32517,
            warning = exclamation,
            error = hand,
            note = asterisk
        };
    };

    export struct icolor
    {
        uint value;

        icolor(uint value_set = 0) : value(value_set) {}

        icolor(uint red,
            uint green,
            uint blue) : value(red | green << 8 | blue << 16) {}

        icolor(uint red,
            uint green,
            uint blue,
            uint alpha) : value(red | green << 8 | blue << 16 | alpha << 24) {}

        icolor& operator=(uint color_set) { value = color_set; return *this; }

        operator uint() const { return value; }
    };

    export struct basic_limits
    {
        enum
        {
            maximum_short = 0x7fff,
            minimum_short = 0x8000,
            maximum_integer = 0x7fffffff,
            minimum_integer = 0x80000000,
            maximum_uint = 0xffffffff,
        };
    };

    export struct double_integer : public vector<int, 2>
    {
        double_integer(int low = 0, int high = 0)
        {
            (*this)(0) = low; (*this)(1) = high;
        }

        double_integer(const double_integer& copy)
        {
            (*this)(0) = copy(0); (*this)(1) = copy(1);
        }
    };

    export struct double_uint : public vector<uint, 2>
    {
        double_uint(uint low = 0, uint high = 0)
        {
            (*this)(0) = low; (*this)(1) = high;
        }

        double_uint(const double_uint& copy)
        {
            (*this)(0) = copy(0); (*this)(1) = copy(1);
        }

        operator uint() const { return (*this)(0); }
    };


    export  typedef double_uint large_integer;

    //*** constants and  datatypes ***

    export struct error_return
    {
        enum
        {
            graphics = -1,
            color = -1,
            invalid_handle = -1
        };
    };

    export struct duplicate_option
    {
        enum
        {
            source_close = 1,
            access_same = 2
        };
    };

    export  enum { unity = 1 << 16 };

    export struct path_length
    {
        enum
        {
            maximum = 260,
            maximum_component = 256
        };
    };

    export  uint make_uint(part l, part h)
    {
        return ((uint)(((part)(l)) | ((uint)((part)(h))) << 16));
    }

    export  int make_integer(part l, part h)
    {
        return ((int)make_uint(l, h));
    }

    export  part make_part(byte l, byte h)
    {
        return (((byte)(l)) | ((byte)(h)) << 8);
    }

    export  short make_short(byte l, byte h)
    {
        return ((short)make_part(l, h));
    }

    export  part low_part(int i) { return ((part)(uint)i); }
    export  part high_part(int i) { return ((part)(((uint)(i) >> 16) & 0xffff)); }

    export  part low_part(uint i) { return ((part)i); }
    export  part high_part(uint i) { return ((part)((i >> 16) & 0xffff)); }

    export  part low_part(parameter i) { return ((part)(uint)i); }
    export  part high_part(parameter i) { return ((part)(((uint)i >> 16) & 0xffff)); }

    export template<class t> byte low_byte(t _t) { return ((byte)(part)t); }
    export template<class t> byte high_byte(t _t) { return ((byte)(((part)(_t) >> 8) & 0xff)); }

    export struct irectangle
    {
        ipoint a;
        ipoint b;

        irectangle(int x_a = 0,
            int y_a = 0,
            int x_b = 0,
            int y_b = 0) {
            a(0) = x_a; a(1) = y_a; b(0) = x_b; b(1) = y_b;
        }

        irectangle(const ipoint& ain,
            const ipoint& b_in) {
            a = ain; b = b_in;
        }

        ipoint& operator[](int index) { return !index ? a : b; }

        const ipoint& operator()(int index) const { return !index ? a : b; }

        int& operator()(int i, int j) { return !i ? a(j) : b(j); }

        const int& operator()(int i, int j) const { return !i ? a(j) : b(j); }

        int width() const { return (*this)(1, 0) - (*this)(0, 0); }
        int height() const { return (*this)(1, 1) - (*this)(0, 1); }
    };

    export  typedef int(__stdcall* function_type)();

    export struct region_type
    {
        enum
        {
            error = 0,
            null = 1,
            simple,
            complex
        };
    };

    typedef unsigned uint;

    export  uint round_up(uint value,
        uint base)
    {
        if (value < base)
            return base;
        else if (value % base)
            return value + (base - (value % base));
        else
            return value;
    }

    export  uint round_down(uint value,
        uint base)
    {
        return (value / base) * base;
    }

    export  enum
    {
        bits_per_integer = 32,
        kilo_byte = 1024,
        megabyte = kilo_byte * kilo_byte,
        gigabyte = megabyte * kilo_byte,
        line_feed = 0xd,
        carriage_return = 0xa
    };

    export struct clipboard_format
    {
        enum
        {
            text = 1,
            bitmap = 2,
            metafile_picture = 3,
            symbolic_linker = 4,
            datainterchange_format = 5,
            tagged_image_file_format = 6,
            oem_text = 7,
            device_independent_bitmap = 8,
            palette = 9,
            pen_data = 10,
            riff = 11,
            wave = 12,
            unicode_text = 13,
            metafile = 14,
            handle_drop = 15,
            locale = 16,
            owner_display = 0x0080,
            display_text = 0x0081,
            display_bitmap = 0x0082,
            display_metafile_picture = 0x0083,
            display_metafile = 0x008e,
            private_first = 0x0200,
            private_last = 0x02ff,
            _object_first = 0x0300,
            _object_last = 0x03ff
        };
    };

    export struct paint
    {
        handle device;
        uint  erase;
        irectangle bounds;
        uint restore;
        uint  update;
        byte uint[32];
    };

    export  character* make_integer_resource(uint i) { return (character*)(ulong)i; }

    export struct style
    {
        enum
        {
            window = 0x00000000,
            popup = 0x80000000,
            child = 0x40000000,
            minimize = 0x20000000,
            visible = 0x10000000,
            disabled = 0x08000000,
            clip_siblings = 0x04000000,
            clip_children = 0x02000000,
            maximize = 0x01000000,
            caption = 0x00c00000,
            border = 0x00800000,
            dialog_frame = 0x00400000,
            vertical_scroll = 0x00200000,
            horizontal_scroll = 0x00100000,
            system_menu = 0x00080000,
            thick_frame = 0x00040000,
            group = 0x00020000,
            tabstop = 0x00010000,
            maximize_box = 0x00020000,
            minimize_box = 0x00010000,
            standard = window |
            caption |
            system_menu |
            thick_frame |
            minimize_box |
            maximize_box,
            popup_window = popup |
            border |
            system_menu,
            size_box = thick_frame
        };
    };

    export struct extended_style
    {
        enum
        {
            modal_frame = 0x00000001,
            no_parent_notify = 0x00000004,
            top_most = 0x00000008,
            accept_files = 0x00000010,
            transparent = 0x00000020,
            multidocument_child = 0x00000040,
            tool_window = 0x00000080,
            window_edge = 0x00000100,
            client_edge = 0x00000200,
            context_help = 0x00000400,
            right = 0x00001000,
            left = 0x00000000,
            right_to_left = 0x00002000,
            left_to_right = 0x00000000,
            scrollbar_left = 0x00004000,
            scrollbar_right = 0x00000000,
            control_parent = 0x00010000,
            display_edge = 0x00020000,
            application_window = 0x00040000,
            palette_window = window_edge | client_edge
        };
    };

    export  enum { null = 0 };

    export struct error
    {
        enum
        {
            none = 0,
            ok = 0,
            function_invalid = 1,
            file_not_found = 2,
            path_not_found = 3,
            too_many_open_files = 4,
            access_denied = 5,
            invalid_handle = 6,
            arena_trashed = 7,
            there_is_not_enough_memory = 8,
            block_invalid = 9,
            environment_bad = 10,
            format_bad = 11,
            access_invalid = 12,
            data_invalid = 13,
            out_of_memory = 14,
            drive_invalid = 15,
            directory_is_current = 16,
            not_same_device = 17,
            no_more_files = 18,
            write_protect = 19,
            unit_bad = 20,
            not_ready = 21,
            command_bad = 22,
            cyclic_redundancy_check = 23,
            length_bad = 24,
            seek = 25,
            disk_not_dos = 26,
            sector_not_found = 27,
            paper_out = 28,
            write_fault = 29,
            read_fault = 30,
            general_failure = 31,
            sharing_violation = 32,
            lock_violation = 33,
            disk_wrong = 34,
            sharing_buffer_exceeded = 36,
            handle_end_of_file = 38,
            handle_disk_full = 39,
            not_supported = 50,
            remote_not_listed = 51,
            duplicate_name = 52,
            network_path_bad = 53,
            network_busy = 54,
            device_nonexistent = 55,
            too_many_commands = 56,
            adapter_hardware_error = 57,
            network_response_bad = 58,
            unexpected_network_error = 59,
            removeable_adapter_bad = 60,
            print_queue_full = 61,
            no_spool_space = 62,
            print_cancelled = 63,
            network_name_deleted = 64,
            network_access_denied = 65,
            device_type_bad = 66,
            network_name_bad = 67,
            too_many_names = 68,
            too_many_sessions = 69,
            sharing_paused = 70,
            request_not_accepted = 71,
            redirector_paused = 72,
            file_exists = 80,
            cannot_make = 82,
            fail_interrupt24 = 83,
            out_of_structures = 84,
            already_assigned = 85,
            password_invalid = 86,
            aparameter_is_invalid = 87,
            net_write_fault = 88,
            no_process_slots = 89,
            too_many_semaphores = 100,
            exclusive_semaphore_already_owned = 101,
            semaphore_is_set = 102,
            too_many_semaphore_requests = 103,
            invalid_at_interrupt_time = 104,
            semaphore_owner_died = 105,
            semaphore_user_limit = 106,
            disk_change = 107,
            drive_locked = 108,
            pipe_broken = 109,
            open_failed = 110,
            buffer_overflow = 111,
            disk_full = 112,
            no_more_search_handles = 113,
            target_handle_invalid = 114,
            category_invalid = 117,
            verify_switch_invalid = 118,
            driver_level_bad = 119,
            call_not_implemented = 120,
            semaphore_timeout = 121,
            buffer_insufficient = 122,
            name_invalid = 123,
            level_invalid = 124,
            no_volume_label = 125,
            module_not_found = 126,
            process_not_found = 127,
            wait_no_children = 128,
            child_not_complete = 129,
            direct_access_handle = 130,
            seek_negative = 131,
            seek_on_device = 132,
            is_join_target = 133,
            is_joined = 134,
            is_substituted = 135,
            not_joined = 136,
            not_substituted = 137,
            join_to_join = 138,
            substitute_to_substitute = 139,
            join_to_substitute = 140,
            substitute_to_join = 141,
            drive_busy = 142,
            drive_same = 143,
            directory_not_root = 144,
            directory_not_empty = 145,
            is_substituted_path = 146,
            is_joined_path = 147,
            path_busy = 148,
            is_substituted_target = 149,
            system_trace = 150,
            event_count_invalid = 151,
            too_many_exclusive_waiters = 152,
            list_format_invalid = 153,
            label_too_long = 154,
            too_many_threads = 155,
            signal_refused = 156,
            discarded = 157,
            not_locked = 158,
            thread_identity_address_bad = 159,
            arguments_bad = 160,
            path_name_bad = 161,
            signal_pending = 162,
            thread_maximum_reached = 164,
            lock_failed = 167,
            busy = 170,
            cancel_violation = 173,
            atomic_locks_not_supported = 174,
            segment_number_invalid = 180,
            ordinal_invalid = 182,
            already_exists = 183,
            flag_number_invalid = 186,
            semaphore_not_found = 187,
            starting_code_segment_invalid = 188,
            stack_segment_invalid = 189,
            module_type_invalid = 190,
            executable_signature_invalid = 191,
            executable_marked_invalid = 192,
            executable_format_bad = 193,
            iterated_data_exceeds_64k = 194,
            minimum_allocation_size_invalid = 195,
            dynamic_link_from_invalid_ring = 196,
            input_output_privilege_level_not_enabled = 197,
            segment_privilege_level_invalid = 198,
            automatic_data_segment_exceeds_64k = 199,
            ring2_segment_must_be_movable = 200,
            relocation_chain_exceeds_segment_limit = 201,
            infinite_loop_in_relocation_chain = 202,
            environment_variable_not_found = 203,
            no_signal_sent = 205,
            file_nam_exceeds_range = 206,
            ring2_stack_in_use = 207,
            meta_expansion_too_long = 208,
            signal_number_invalid = 209,
            thread_1inactive = 210,
            locked = 212,
            too_many_modules = 214,
            nesting_not_allowed = 215,
            executable_machine_type_mismatch = 216,
            pipe_bad = 230,
            pipe_busy = 231,
            no_data = 232,
            pipe_not_connected = 233,
            more_data = 234,
            virtual_console_disconnected = 240,
            extended_attribute_name_invalid = 254,
            extended_attribute_list_inconsistent = 255,
            no_more_items = 259,
            cannot_copy = 266,
            directory = 267,
            extended_attributes_did_not_fit = 275,
            extended_attribute_file_corrupt = 276,
            extended_attribute_table_full = 277,
            extended_attribute_handle_invalid = 278,
            extended_attributes_not_supported = 282,
            not_owner = 288,
            too_many_posts = 298,
            partial_copy = 299,
            oplock_not_granted = 300,
            invalid_oplock_protocol = 301,
            message_not_found_in_file = 317,
            address_invalid = 487,
            arithmetic_overflow = 534,
            pipe_connected = 535,
            pipe_listening = 536,
            extended_attribute_access_denied = 994,
            operation_cancelled = 995,
            input_output_incomplete = 996,
            input_output_pending = 997,
            no_access = 998,
            swap_error = 999,
            stack_overflow = 1001,
            message_invalid = 1002,
            cannot_complete = 1003,
            flags_invalid = 1004,
            volume_unrecognized = 1005,
            file_invalid = 1006,
            full_screen_mode = 1007,
            no_token = 1008,
            registry_database_bad = 1009,
            key_bad = 1010,
            cannot_open = 1011,
            cannot_read = 1012,
            cannot_write = 1013,
            registry_recovered = 1014,
            registry_corrupt = 1015,
            registry_input_output_failed = 1016,
            not_registry_file = 1017,
            key_deleted = 1018,
            no_log_space = 1019,
            key_has_children = 1020,
            child_must_be_volatile = 1021,
            notify_enumerate_directory = 1022,
            dependent_services_running = 1051,
            service_control_invalid = 1052,
            service_request_timeout = 1053,
            service_no_thread = 1054,
            service_database_locked = 1055,
            service_already_running = 1056,
            service_account_invalid = 1057,
            service_disabled = 1058,
            circular_dependency = 1059,
            service_does_not_exist = 1060,
            service_cannot_accept_control = 1061,
            service_not_active = 1062,
            service_controller_connect_failed = 1063,
            servikeyxception = 1064,
            database_does_not_exist = 1065,
            service_specific_error = 1066,
            process_aborted = 1067,
            service_dependency_failed = 1068,
            service_logon_failed = 1069,
            service_start_hang = 1070,
            service_lock_invalid = 1071,
            service_marked_for_deletion = 1072,
            servikeyxists = 1073,
            already_running_last_known_good_configuration = 1074,
            service_dependency_deleted = 1075,
            boot_already_accepted = 1076,
            service_never_started = 1077,
            duplicate_service_name = 1078,
            different_service_account = 1079,
            cannot_detect_driver_failure = 1080,
            cannot_detect_process_abort = 1081,
            no_recovery_program = 1082,
            end_ofmedia = 1100,
            file_mark_detected = 1101,
            beginning_of_media = 1102,
            set_mark_detected = 1103,
            no_data_detected = 1104,
            partition_failure = 1105,
            block_length_invalid = 1106,
            device_not_partitioned = 1107,
            unable_to_lock_media = 1108,
            unable_to_unload_media = 1109,
            mediachanged = 1110,
            bus_reset = 1111,
            no_media_in_drive = 1112,
            nounicode_translation = 1113,
            dynamic_link_library_initialization_failed = 1114,
            shutdown_in_progress = 1115,
            no_shutdown_in_progress = 1116,
            input_output_device = 1117,
            serial_no_device = 1118,
            interrupt_request_busy = 1119,
            more_writes = 1120,
            counter_timeout = 1121,
            floppy_identity_mark_not_found = 1122,
            floppy_wrong_cylinder = 1123,
            floppy_unknown_error = 1124,
            floppy_registers_bad = 1125,
            disk_recalibration_failed = 1126,
            disk_operation_failed = 1127,
            disk_reset_failed = 1128,
            end_oftape_overflow = 1129,
            not_enough_server_memory = 1130,
            possible_deadlock = 1131,
            mapped_alignment = 1132,
            set_power_state_vetoed = 1140,
            set_power_state_failed = 1141,
            too_many_links = 1142,
            old_windows_version = 1150,
            application_wrong_operating_system = 1151,
            single_instance_application = 1152,
            real_mode_application = 1153,
            invalid_dynamic_link_library = 1154,
            no_association = 1155,
            dynamic_data_exchange_fail = 1156,
            dynamic_link_library_not_found = 1157,
            no_more_user_handles = 1158,
            message_syncronize_only = 1159,
            sourkeylement_empty = 1160,
            destination_element_full = 1161,
            illegal_element_address = 1162,
            magazine_not_present = 1163,
            device_reinitialization_needed = 1164,
            device_requires_cleaning = 1165,
            device_door_open = 1166,
            device_not_connected = 1167,
            not_found = 1168,
            no_match = 1169,
            set_not_found = 1170,
            ipoint_not_found = 1171,
            no_tracking_service = 1172,
            no_volume_identity = 1173,
            device_bad = 1200,
            connection_unavailable = 1201,
            device_already_remembered = 1202,
            no_network_or_path_bad = 1203,
            providor_bad = 1204,
            cannot_open_profile = 1205,
            profile_bad = 1206,
            not_container = 1207,
            extended_error = 1208,
            group_name_invalid = 1209,
            computer_name_invalid = 1210,
            event_name_invalid = 1211,
            domain_name_invalid = 1212,
            service_name_invalid = 1213,
            network_name_invalid = 1214,
            share_name_invalid = 1215,
            password_name_invalid = 1216,
            message_name_invalid = 1217,
            message_destination_invalid = 1218,
            session_credential_conflict = 1219,
            remote_session_limit_exceeded = 1220,
            duplicate_domain_name = 1221,
            no_network = 1222,
            cancelled = 1223,
            user_mapped_file = 1224,
            connection_refused = 1225,
            graceful_disconnect = 1226,
            address_already_associated = 1227,
            address_not_associated = 1228,
            connection_invalid = 1229,
            connection_active = 1230,
            network_unreachable = 1231,
            host_unreachable = 1232,
            protocol_unreachable = 1233,
            port_unreachable = 1234,
            request_aborted = 1235,
            connection_aborted = 1236,
            retry = 1237,
            connection_count_limit = 1238,
            login_time_restriction = 1239,
            login_work_station_restriction = 1240,
            address_incorrect = 1241,
            already_registered = 1242,
            service_not_found = 1243,
            not_authenticated = 1244,
            not_logged_on = 1245,
            _continue = 1246,
            already_initialized = 1247,
            no_more_devices = 1248,
            no_such_site = 1249,
            domain_controller_exists = 1250,
            directory_services_not_installed = 1251,
            not_all_assigned = 1300,
            some_not_mapped = 1301,
            no_quotas_for_account = 1302,
            local_user_session_key = 1303,
            null_local_area_network_manager_password = 1304,
            revision_unknown = 1305,
            revision_mismatch = 1306,
            owner_invalid = 1307,
            primary_group_invalid = 1308,
            no_impersonation_token = 1309,
            cannot_disable_mandatory = 1310,
            no_logon_servers = 1311,
            no_such_logon_session = 1312,
            no_such_privilege = 1313,
            privilege_not_held = 1314,
            account_name_invalid = 1315,
            user_exists = 1316,
            no_such_user = 1317,
            group_exists = 1318,
            no_such_group = 1319,
            member_in_group = 1320,
            member_not_in_group = 1321,
            last_administration_account = 1322,
            password_wrong = 1323,
            password_ill_formed = 1324,
            password_restriction = 1325,
            logon_failure = 1326,
            account_restriction = 1327,
            logon_hours_invalid = 1328,
            work_station_invalid = 1329,
            password_expired = 1330,
            account_disabled = 1331,
            none_mapped = 1332,
            too_many_identities_requested = 1333,
            identities_exhausted = 1334,
            subauthority_invalid = 1335,
            access_list_invalid = 1336,
            identity_invalid = 1337,
            security_descriptor_invalid = 1338,
            inheritance_access_list_bad = 1340,
            server_disabled = 1341,
            server_not_disabled = 1342,
            identity_authority_invalid = 1343,
            allotted_space_exceeded = 1344,
            group_attributes_invalid = 1345,
            impersonation_level_bad = 1346,
            cannot_open_anonymous = 1347,
            validation_class_bad = 1348,
            token_type_bad = 1349,
            no_security_on_object = 1350,
            cannot_access_domain_information = 1351,
            server_state_invalid = 1352,
            domain_state_invalid = 1353,
            domain_role_invalid = 1354,
            no_such_domain = 1355,
            domain_exists = 1356,
            domain_limit_exceeded = 1357,
            internal_database_corruption = 1358,
            internal_error = 1359,
            generic_not_mapped = 1360,
            descriptor_format_bad = 1361,
            not_logon_process = 1362,
            logon_session_exists = 1363,
            no_such_package = 1364,
            logon_session_state_bad = 1365,
            logon_session_collision = 1366,
            logon_type_invalid = 1367,
            cannot_impersonate = 1368,
            requested_action_incompatible_with_state = 1369,
            security_database_commit_failure = 1370,
            account_special = 1371,
            group_special = 1372,
            user_special = 1373,
            members_primary_group = 1374,
            token_already_in_use = 1375,
            no_such_alias = 1376,
            member_not_in_alias = 1377,
            member_in_alias = 1378,
            alias_exists = 1379,
            logon_not_granted = 1380,
            too_many_secrets = 1381,
            secret_too_long = 1382,
            internal_database_error = 1383,
            too_many_context_identities = 1384,
            logon_type_not_granted = 1385,
            cross_encryption_required = 1386,
            no_such_member = 1387,
            member_invalid = 1388,
            too_many_security_identities = 1389,
            lan_manager_cross_encryption_required = 1390,
            no_inheritance = 1391,
            file_corrupt = 1392,
            disk_corrupt = 1393,
            no_user_session_key = 1394,
            license_quota_exceeded = 1395,
            window_handle_invalid = 1400,
            menu_handle_invalid = 1401,
            cursor_handle_invalid = 1402,
            accelerator_handle_invalid = 1403,
            hook_handle_invalid = 1404,
            multiple_window_position_handle_invalid = 1405,
            cannot_create_a_top_level_child_window = 1406,
            cannot_find_window_class = 1407,
            window_of_other_thread = 1408,
            hotkey_already_registered = 1409,
            class_already_exists = 1410,
            class_does_not_exist = 1411,
            class_has_windows = 1412,
            index_invalid = 1413,
            iconhandle_invalid = 1414,
            private_dialog_index = 1415,
            listbox_identity_not_found = 1416,
            no_wild_card_characters = 1417,
            clipboard_not_open = 1418,
            hotkey_not_registered = 1419,
            window_not_dialog = 1420,
            control_identity_not_found = 1421,
            combobox_message_invalid = 1422,
            window_not_combobox = 1423,
            edit_height_invalid = 1424,
            device_context_not_found = 1425,
            hook_filter_invalid = 1426,
            filter_procedure_invalid = 1427,
            hook_needs_module_handle = 1428,
            global_only_hook = 1429,
            journal_hook_set = 1430,
            hook_not_installed = 1431,
            listbox_message_invalid = 1432,
            count_set_on_listbox_invalid = 1433,
            listbox_without_tab_stops = 1434,
            destroy_object_of_other_thread = 1435,
            child_window_menu = 1436,
            no_system_menu = 1437,
            message_box_style_invalid = 1438,
            system_parameter_value_invalid = 1439,
            screen_already_locked = 1440,
            windows_have_different_parent = 1441,
            not_child_window = 1442,
            window_get_command_invalid = 1443,
            thread_identity_invalid = 1444,
            non_multidocument_child_window = 1445,
            popup_already_active = 1446,
            no_scroll_bars = 1447,
            scroll_bar_range_invalid = 1448,
            show_window_command_invalid = 1449,
            no_system_resources = 1450,
            non_paged_system_resources = 1451,
            paged_system_resources = 1452,
            working_set_quota = 1453,
            page_file_quota = 1454,
            commitment_limit = 1455,
            menu_item_not_found = 1456,
            invalid_keyboard_handle = 1457,
            hook_type_not_allowed = 1458,
            requires_interactive_window_station = 1459,
            timeout = 1460,
            invalid_monitor_handle = 1461,
            event_log_file_corrupt = 1500,
            event_log_cannot_start = 1501,
            log_file_full = 1502,
            event_log_file_changed = 1503,
            install_service = 1601,
            install_user_exit = 1602,
            install_failure = 1603,
            install_suspend = 1604,
            unknown_product = 1605,
            unknown_feature = 1606,
            unknown_component = 1607,
            unknown_property = 1608,
            invalid_handle_state = 1609,
            bad_configuration = 1610,
            index_absent = 1611,
            install_source_absent = 1612,
            bad_database_version = 1613,
            product_uninstalled = 1614,
            bad_query_syntax = 1615,
            invalid_field = 1616,
            remote_string_binding_invalid = 1700,
            remote_wrong_kind_of_binding = 1701,
            remote_binding_invalid = 1702,
            remote_protocol_sequence_not_supported = 1703,
            remote_procedure_call_protocol_sequence_invalid = 1704,
            remote_universally_unique_identity_invalid = 1705,
            remote_endpoint_format_invalid = 1706,
            remote_network_address_invalid = 1707,
            remote_endpoint_not_found = 1708,
            remote_time_out_invalid = 1709,
            remote_object_not_found = 1710,
            remote_already_registered = 1711,
            remote_type_already_registered = 1712,
            remote_already_listening = 1713,
            remote_no_protocol_sequences_registered = 1714,
            remote_not_listening = 1715,
            remote_manager_type_unknown = 1716,
            remote_interface_unknown = 1717,
            remote_no_bindings = 1718,
            remote_no_protocol_sequences = 1719,
            remote_cannot_create_endpoint = 1720,
            remote_out_of_resources = 1721,
            remote_server_unavailable = 1722,
            remote_server_too_busy = 1723,
            remote_network_options_invalid = 1724,
            remote_no_call_active = 1725,
            remote_call_failed = 1726,
            remote_call_failed_and_did_not_execute = 1727,
            remote_protocol_error = 1728,
            remote_transport_syntax_unsupported = 1730,
            remote_type_unsupported = 1732,
            remote_tag_invalid = 1733,
            remote_bound_invalid = 1734,
            remote_no_entry_name = 1735,
            remote_name_syntax_invalid = 1736,
            remote_name_syntax_unsupported = 1737,
            remote_universally_unique_identity_no_address = 1739,
            remote_duplicateendpoint = 1740,
            remote_unknown_authentication_type = 1741,
            remote_maximum_calls_too_small = 1742,
            remote_string_too_long = 1743,
            remote_protocol_sequence_not_found = 1744,
            remote_procedure_number_out_ofrange = 1745,
            remote_binding_has_no_authorization = 1746,
            remote_authentication_service_unknown = 1747,
            remote_authentication_level_unknown = 1748,
            remote_authentication_identity_invalid = 1749,
            remote_authorization_service_unknown = 1750,
            endpoint_entry_invalid = 1751,
            endpoint_cannot_perform_operation = 1752,
            endpoint_not_registered = 1753,
            remote_nothing_to_export = 1754,
            remote_name_incomplete = 1755,
            remote_version_option_invalid = 1756,
            remote_no_more_members = 1757,
            remote_not_all_objects_unexported = 1758,
            remote_interface_not_found = 1759,
            remote_entry_already_exists = 1760,
            remote_entry_not_found = 1761,
            remote_name_service_unavailable = 1762,
            remote_network_address_family_identity_invalid = 1763,
            remote_cannot_support = 1764,
            remote_no_context_available = 1765,
            remote_internal_error = 1766,
            remote_divide_by_zero = 1767,
            remote_address_error = 1768,
            remote_decimal_divide_by_zero = 1769,
            remote_decimal_underflow = 1770,
            remote_decimal_overflow = 1771,
            remote_no_more_entries = 1772,
            remotecharacter_translation_open_fail = 1773,
            remotecharacter_translation_short_file = 1774,
            remote_in_null_context = 1775,
            remote_context_damaged = 1777,
            remotehandles_mismatch = 1778,
            remote_cannot_get_call_handle = 1779,
            remote_null_reference_pointer = 1780,
            remote_enumeration_value_out_of_range = 1781,
            remote_byte_count_too_small = 1782,
            remote_stub_data_bad = 1783,
            user_buffer_invalid = 1784,
            media_unrecognized = 1785,
            no_trust_secret = 1786,
            no_trust_account = 1787,
            trusted_domain_failure = 1788,
            trusted_relationship_failure = 1789,
            trust_failure = 1790,
            remote_call_in_progress = 1791,
            network_logon_not_started = 1792,
            account_expired = 1793,
            redirector_has_open_handles = 1794,
            printer_driver_already_installed = 1795,
            port_unknown = 1796,
            printer_driver_unknown = 1797,
            print_processor_unknown = 1798,
            separator_file_invalid = 1799,
            priority_invalid = 1800,
            printer_name_invalid = 1801,
            printer_already_exists = 1802,
            printer_command_invalid = 1803,
            datatype_invalid = 1804,
            environment_invalid = 1805,
            remote_no_more_bindings = 1806,
            no_logon_inter_domain_trust_account = 1807,
            no_logon_work_station_trust_account = 1808,
            no_logon_server_trust_account = 1809,
            domain_trust_inconsistent = 1810,
            server_has_open_handles = 1811,
            resource_data_not_found = 1812,
            resource_type_not_found = 1813,
            resource_name_not_found = 1814,
            resource_language_not_found = 1815,
            not_enough_quota = 1816,
            remote_no_interfaces = 1817,
            remote_call_cancelled = 1818,
            remote_binding_incomplete = 1819,
            remote_communication_failure = 1820,
            remote_authentication_level_unsupported = 1821,
            remote_no_principal_name = 1822,
            remote_not_remote_procedure_call_error = 1823,
            remote_universally_unique_identity_local_only = 1824,
            remote_security_package_error = 1825,
            remote_not_cancelled = 1826,
            remote_encoding_action_invalid = 1827,
            remote_encoding_version_wrong = 1828,
            remote_encoding_stub_version_wrong = 1829,
            remote_invalid_pipe_object = 1830,
            remote_wrong_pipe_order = 1831,
            remote_wrong_pipe_version = 1832,
            remote_group_member_not_found = 1898,
            endpoint_cannot_create = 1899,
            remote_object_invalid = 1900,
            time_invalid = 1901,
            form_name_invalid = 1902,
            form_size_invalid = 1903,
            already_waiting = 1904,
            printer_deleted = 1905,
            printer_state_invalid = 1906,
            password_must_change = 1907,
            domain_controller_not_found = 1908,
            account_locked_out = 1909,
            invalid_object_export_identity = 1910,
            invalid_object_identity = 1911,
            object_resolver_set = 1912,
            remote_send_incomplete = 1913,
            remote_invalid_asynchronous_handle = 1914,
            remote_invalid_asynchronous_call = 1915,
            remote_pipe_closed = 1916,
            remote_pipe_discipline_error = 1917,
            remote_pipe_empty = 1918,
            no_site_name = 1919,
            cannot_access_file = 1920,
            cannot_resolve_file_name = 1921,
            directory_services_membership_evaluated_locally = 1922,
            directory_services_no_attribute_or_value = 1923,
            directory_services_invalid_attribute_syntax = 1924,
            directory_services_attribute_type_undefined = 1925,
            directory_services_attribute_or_valueexists = 1926,
            directory_services_busy = 1927,
            directory_services_unavailable = 1928,
            directory_services_no_relative_identities_allocated = 1929,
            directory_services_no_more_relative_identities = 1930,
            directory_services_incorrect_role_owner = 1931,
            directory_services_relative_identity_manager = 1932,
            directory_services_object_class_violation = 1933,
            directory_services_cannot_on_non_leaf = 1934,
            directory_services_cannot_on_rdn = 1935,
            directory_services_cannot_modify_object_class = 1936,
            directory_services_cross_domain_move_operation = 1937,
            directory_services_global_catalog_unavailable = 1938,
            pixel_format_invalid = 2000,
            driver_bad = 2001,
            window_style_invalid = 2002,
            metafile_not_supported = 2003,
            clipping_not_supported = 2005,
            transform_not_supported = 2013,
            user_name_bad = 2202,
            not_connected = 2250,
            invalidcolor_management_module = 2300,
            invalid_profile = 2301,
            tag_not_found = 2302,
            tag_not_present = 2303,
            duplicate_tag = 2304,
            profile_not_associated_with_device = 2305,
            profile_not_found = 2306,
            invalid_color_space = 2307,
            image_color_management_not_enabled = 2308,
            deleting_image_color_management_transform = 2309,
            invalid_transform = 2310,
            open_files = 2401,
            active_connections = 2402,
            device_in_use = 2404,
            print_monitor_unknown = 3000,
            printer_driver_in_use = 3001,
            spool_file_not_found = 3002,
            spooler_no_start_document = 3003,
            spooler_no_add_job = 3004,
            print_processor_already_installed = 3005,
            print_monitor_already_installed = 3006,
            invalid_print_monitor = 3007,
            print_monitor_in_use = 3008,
            printer_has_jobs_queued = 3009,
            success_reboot_required = 3010,
            success_restart_required = 3011,
            wins_internal = 4000,
            cannot_delete_local_wins = 4001,
            static_initialization = 4002,
            incremental_backup = 4003,
            full_backup = 4004,
            record_non_existent = 4005,
            replication_not_allowed = 4006,
            dhcp_address_conflict = 4100,
            wmi_globally_unique_identity_not_found = 4200,
            wmi_instance_not_found = 4201,
            wmi_item_identity_not_found = 4202,
            wmi_try_again = 4203,
            wmi_dataprovidor_not_found = 4204,
            wmi_unresolved_instance_reference = 4205,
            wmi_already_enabled = 4206,
            wmi_globally_unique_identity_disconnected = 4207,
            wmi_server_unavailable = 4208,
            wmi_data_providor_failed = 4209,
            wmi_invalid_mof = 4210,
            wmi_invalid_registration_information = 4211,

            invalid_media = 4300,
            invalid_library = 4301,
            invalid_media_pool = 4302,
            drive_media_mismatch = 4303,
            media_offline = 4304,
            library_offline = 4305,
            empty = 4306,
            not_empty = 4307,
            media_unavailable = 4308,
            resource_disabled = 4309,
            invalid_cleaner = 4310,
            unable_to_clean = 4311,
            object_not_found = 4312,
            database_failure = 4313,
            database_full = 4314,
            media_incompatible = 4315,
            resource_not_present = 4316,
            invalid_operation = 4317,
            media_not_available = 4318,
            device_not_available = 4319,
            request_refused = 4320,
            file_offline = 4350,
            remote_storage_not_active = 4351,
            remote_storage_mediaerror = 4352,
            not_a_reparse_point = 4390,
            reparse_attribute_conflict = 4391,
            dependent_resource_exists = 5001,
            dependency_not_found = 5002,
            dependency_already_exists = 5003,
            resource_not_online = 5004,
            host_node_not_available = 5005,
            resource_not_available = 5006,
            resource_not_found = 5007,
            shutdown_cluster = 5008,
            cannot_evict_active_node = 5009,
            object_already_exists = 5010,
            object_in_list = 5011,
            group_not_available = 5012,
            group_not_found = 5013,
            group_not_online = 5014,
            host_node_not_resource_owner = 5015,
            host_node_not_group_owner = 5016,
            resource_monitor_create_failed = 5017,
            resource_monitor_online_failed = 5018,
            resource_online = 5019,
            quorum_resource = 5020,
            not_quorum_capable = 5021,
            cluster_shutting_down = 5022,
            invalid_state = 5023,
            resource_properties_stored = 5024,
            not_quorum_class = 5025,
            core_resource = 5026,
            quorum_resource_online_failed = 5027,
            quorum_log_open_failed = 5028,
            cluster_log_corrupt = 5029,
            cluster_log_record_exceeds_maximum_size = 5030,
            cluster_log_exceeds_maximum_size = 5031,
            cluster_log_checkipoint_not_found = 5032,
            cluster_log_not_enough_space = 5033,
            encryption_failed = 6000,
            decryption_failed = 6001,
            file_encrypted = 6002,
            no_recovery_policy = 6003,
            no_encryption_file_system = 6004,
            wrong_encryption_file_system = 6005,
            no_user_keys = 6006,
            file_not_encrypted = 6007,
            not_export_format = 6008,
            no_browser_servers_found = 6118,

            scheduler_service_not_local_system = 6200,
            terminal_server_win_station_name_invalid = 7001,
            terminal_server_invalid_protocol_driver = 7002,
            terminal_server_protocol_driver_not_found = 7003,
            terminal_server_connection_driver_not_found = 7004,
            terminal_server_cannot_makeevent_log_entry = 7005,
            terminal_server_service_name_collision = 7006,
            terminal_server_close_pending = 7007,
            terminal_server_no_output_buffers = 7008,
            terminal_server_modem_information_not_found = 7009,
            terminal_server_invalid_modem_name = 7010,
            terminal_server_modem_responseerror = 7011,
            terminal_server_modem_response_time_out = 7012,
            terminal_server_modem_response_no_carrier = 7013,
            terminal_server_modem_response_no_dial_tone = 7014,
            terminal_server_modem_response_busy = 7015,
            terminal_server_modem_response_voice = 7016,
            terminal_server_transport_driver_error = 7017,
            terminal_server_win_station_not_found = 7022,
            terminal_server_win_station_already_exists = 7023,
            terminal_server_win_station_busy = 7024,
            terminal_server_bad_video_mode = 7025,
            terminal_server__invalid = 7035,
            terminal_server_logon_disabled = 7037,
            terminal_server_not_console = 7038,
            terminal_server_client_query_time_out = 7040,
            terminal_server_console_disconnect = 7041,
            terminal_server_console_connect = 7042,
            terminal_server_shadow_denied = 7044,
            terminal_server_win_station_access_denied = 7045,
            terminal_server_invalid_terminal_connection_driver = 7049,
            terminal_server_shadow_invalid = 7050,
            terminal_server_shadow_disabled = 7051,
            terminal_server_client_license_in_use = 7052,
            terminal_server_client_license_not_set = 7053,
            terminal_server_license_not_available = 7054,
            terminal_server_license_client_invalid = 7055,
            terminal_server_license_expired = 7056,
            terminal_server_shadow_not_running = 7057,
            terminal_server_shadow_ended_by_mode_change = 7058,
            activation_count_exceeded = 7059,
            facility_replication_invalid_function_sequence = 8001,
            facility_replication_starting_service = 8002,
            facility_replication_stopping_service = 8003,
            facility_replication_internal_function = 8004,
            facility_replication_internal = 8005,
            facility_replication_service_communication = 8006,
            facility_replication_insufficient_privileges = 8007,
            facility_replication_authentication = 8008,
            facility_replication_insufficient_parent_privileges = 8009,
            facility_replication_parent_authentication = 8010,
            facility_replication_child_to_parent_communications = 8011,
            facility_replication_parent_to_child_communications = 8012,
            facility_replication_system_volume_populate = 8013,
            facility_replication_system_volume_populate_time_out = 8014,
            facility_replication_system_volume_is_busy = 8015,
            facility_replication_system_volume_demote = 8016,
            facility_replication_invalid_serviceparameter = 8017,
            directory_service_not_installed = 8200,
            directory_service_membership_evaluated_locally = 8201,
            directory_service_no_attribute_or_value = 8202,
            directory_service_invalid_attribute_syntax = 8203,
            directory_service_attribute_type_undefined = 8204,
            directory_service_attribute_or_value_exists = 8205,
            directory_service_busy = 8206,
            directory_service_unavailable = 8207,
            directory_service_no_relative_identities_allocated = 8208,
            directory_service_no_more_relative_identities = 8209,
            directory_service_incorrect_role_owner = 8210,
            directory_service_relative_identity_initalization = 8211,
            directory_service_object_class_violation = 8212,
            directory_service_cannot_on_non_leaf = 8213,
            directory_service_cannot_on_rdn = 8214,
            directory_service_cannot_modify_object_class = 8215,
            directory_service_cross_domain_move = 8216,
            directory_service_global_catalog_not_available = 8217,
            shared_policy = 8218,
            policy_object_not_found = 8219,
            policy_only_in_directory_service = 8220,
            promotion_active = 8221,
            no_promotion_active = 8222,
            directory_service_operations = 8224,
            directory_service_protocol = 8225,
            directory_service_time_limit_exceeded = 8226,
            directory_service_size_limit_exceeded = 8227,
            directory_service_administrative_limit_exceeded = 8228,
            directory_service_compare_false = 8229,
            directory_service_compare_true = 8230,
            directory_service_authentication_method_not_supported = 8231,
            directory_service_strong_authentication_required = 8232,
            directory_service_inappropriate_authentication = 8233,
            directory_service_authentication_unknown = 8234,
            directory_service_referral = 8235,
            directory_service_critical_extension_unavailable = 8236,
            directory_service_confidentiality_required = 8237,
            directory_service_inappropriate_matching = 8238,
            directory_service_constraint_violation = 8239,
            directory_service_no_such_object = 8240,
            directory_service_alias_problem = 8241,
            directory_service_invalid_domain_name_syntax = 8242,
            directory_service_is_leaf = 8243,
            directory_service_alias_dereferencing_problem = 8244,
            directory_service_unwilling_to_perform = 8245,
            directory_service_loop_detected = 8246,
            directory_service_naming_violation = 8247,
            directory_service_object_results_too_large = 8248,
            directory_service_affects_multiple_dsas = 8249,
            directory_service_server_down = 8250,
            directory_service_local_error = 8251,
            directory_service_key_encoding_error = 8252,
            directory_service_decoding_error = 8253,
            directory_service_filter_unknown = 8254,
            directory_service_parameter_error = 8255,
            directory_service_not_supported = 8256,
            directory_service_no_results_returned = 8257,
            directory_service_control_not_found = 8258,
            directory_service_client_loop = 8259,
            directory_service_referral_limit_exceeded = 8260,
            directory_service_sort_control_missing = 8261,
            directory_service_offset_range_error = 8262,
            directory_service_root_must_be_naming_context = 8301,
            directory_service_add_replica_inhibited = 8302,
            directory_service_attribute_not_defined_in_schema = 8303,
            directory_service_maximum_object_size_exceeded = 8304,
            directory_service_object_string_name_exists = 8305,
            directory_service_no_relative_domain_name_defined_in_schema = 8306,
            directory_service_relative_domain_name_doesnt_match_schema = 8307,
            directory_service_no_requested_attributes_found = 8308,
            directory_service_user_buffer_too_small = 8309,
            directory_service_attribute_is_not_on_object = 8310,
            directory_service_illegal_modify_operation = 8311,
            directory_service_object_too_large = 8312,
            directory_service_bad_instance_type = 8313,
            directory_service_master_dsa_required = 8314,
            directory_service_object_class_required = 8315,
            directory_service_missing_required_attribute = 8316,
            directory_service_attribute_not_defined_for_class = 8317,
            directory_service_attribute_already_exists = 8318,
            directory_service_cannot_add_attribute_values = 8320,
            directory_service_single_value_constraint = 8321,
            directory_service_range_constraint = 8322,
            directory_service_attribute_value_already_exists = 8323,
            directory_service_cannot_remove_missing_attribute = 8324,
            directory_service_cannot_remove_missing_attribute_value = 8325,
            directory_service_root_cannot_be_subreference = 8326,
            directory_service_no_chaining = 8327,
            directory_service_no_chained_evaluation = 8328,
            directory_service_no_parent_object = 8329,
            directory_service_parent_is_an_alias = 8330,
            directory_service_cannot_mix_master_an_replicas = 8331,
            directory_service_children_exist = 8332,
            directory_service_object_not_found = 8333,
            directory_service_aliased_object_missing = 8334,
            directory_service_bad_name_syntax = 8335,
            directory_service_alias_points_to_alias = 8336,
            directory_service_cannot_dereference_alias = 8337,
            directory_service_out_of_scope = 8338,
            directory_service_object_being_removed = 8339,
            directory_service_cannot_delete_dsa_object = 8340,
            directory_service_generic_error = 8341,
            directory_service_dsa_must_be_internal_master = 8342,
            directory_service_class_not_dsa = 8343,
            directory_service_insufficient_access_rights = 8344,
            directory_service_illegal_superior = 8345,
            directory_service_attribute_owned_by_sam = 8346,
            directory_service_name_too_many_parts = 8347,
            directory_service_name_too_long = 8348,
            directory_service_name_value_too_long = 8349,
            directory_service_name_unparseable = 8350,
            directory_service_name_type_unknown = 8351,
            directory_service_not_an_object = 8352,
            directory_service_security_descriptor_too_short = 8353,
            directory_service_security_descriptor_invalid = 8354,
            directory_service_no_deleted_name = 8355,
            directory_service_subreference_must_have_parent = 8356,
            directory_service_name_must_be_naming_context = 8357,
            directory_service_cannot_add_system_only = 8358,
            directory_service_class_must_be_concrete = 8359,
            directory_service_invalidd_m_d = 8360,
            directory_service_object_globally_unique_identity_exists = 8361,
            directory_service_not_on_back_link = 8362,
            directory_service_no_cross_reference_for_naming_context = 8363,
            directory_service_shutting_down = 8364,
            directory_service_unknown_operation = 8365,
            directory_service_invalid_role_owner = 8366,
            directory_service_could_not_contact_fsmo = 8367,
            directory_service_cross_naming_context_domain_rename = 8368,
            directory_service_cannot_modify_system_only = 8369,
            directory_service_replicator_only = 8370,
            directory_service_object_class_not_defined = 8371,
            directory_service_object_class_not_subclass = 8372,
            directory_service_name_reference_invalid = 8373,
            directory_service_cross_reference_key_exists = 8374,
            directory_service_cannot_delete_master_cross_reference = 8375,
            directory_service_subtree_notify_not_nc_head = 8376,
            directory_service_notify_filter_too_complex = 8377,
            directory_service_duplicate_rdn = 8378,
            directory_service_duplicate_oid = 8379,
            directory_service_duplicate_map_identity = 8380,
            directory_service_duplicate_schema_identity = 8381,
            directory_service_duplicate_ldap_display_name = 8382,
            directory_service_semantic_attribute_test = 8383,
            directory_service_syntax_mismatch = 8384,
            directory_service_key_exists_in_must_have = 8385,
            directory_service_key_exists_in_may_have = 8386,
            directory_service_nonexistent_may_have = 8387,
            directory_service_nonexistent_must_have = 8388,
            directory_service_auxiliary_class_test_fail = 8389,
            directory_service_nonexistent_poss_superior = 8390,
            directory_service_subclass_test_fail = 8391,
            directory_service_bad_rdn_attribute_identity_syntax = 8392,
            directory_service_exists_in_auxiliary_class = 8393,
            directory_service_exists_in_subclass = 8394,
            directory_service_exists_in_poss_superior = 8395,
            directory_service_recalculating_schema_failed = 8396,
            directory_service_tree_delete_not_finished = 8397,
            directory_service_cannot_delete = 8398,
            directory_service_attribute_schema_required_identity = 8399,
            directory_service_bad_attribute_schema_syntax = 8400,
            directory_service_cannot_cache_attribute = 8401,
            directory_service_cannot_cache_class = 8402,
            directory_service_cannot_remove_attribute_cache = 8403,
            directory_service_cannot_remove_class_cache = 8404,
            directory_service_cannot_retrieve_distinguished_name = 8405,
            directory_service_missing_superior_reference = 8406,
            directory_service_cannot_retrieve_instance = 8407,
            directory_service_code_inconsistency = 8408,
            directory_service_database_error = 8409,
            directory_service_govern_sid_missing = 8410,
            directory_service_missing_expected_attribute = 8411,
            directory_service_naming_context_missing_cross_reference = 8412,
            directory_service_security_checking_error = 8413,
            directory_service_schema_not_loaded = 8414,
            directory_service_schema_allocation_failed = 8415,
            directory_service_attribute_schema_required_syntax = 8416,
            directory_service_global_catalog_verify_failed = 8417,
            directory_service_replication_schema_mismatch = 8418,
            directory_service_cannot_find_dsa_object = 8419,
            directory_service_cannot_find_expected_naming_context = 8420,
            directory_service_cannot_find_naming_context_in_cache = 8421,
            directory_service_cannot_retrieve_child = 8422,
            directory_service_security_illegal_modify = 8423,
            directory_service_cannot_replace_hidden_record = 8424,
            directory_service_bad_hierarchy_file = 8425,
            directory_service_build_hierarchy_table_failed = 8426,
            directory_service_configuration_parameter_missing = 8427,
            directory_service_counting_address_book_indices_failed = 8428,
            directory_service_hierachy_table_allocation_failed = 8429,
            directory_service_internal_failure = 8430,
            directory_service_unknown_error = 8431,
            directory_service_root_requires_class_top = 8432,
            directory_service_refusing_fsmo_roles = 8433,
            directory_service_missing_fsmo_settings = 8434,
            directory_service_unable_to_surrender_roles = 8435,
            directory_service_dra_generic = 8436,
            directory_service_dra_invalidparameter = 8437,
            directory_service_dra_busy = 8438,
            directory_service_dra_bad_distinguished_name = 8439,
            directory_service_dra_bad_nc = 8440,
            directory_service_dra_distinguished_name_exists = 8441,
            directory_service_dra_internal_error = 8442,
            directory_service_dra_inconsistent_dit = 8443,
            directory_service_dra_connection_failed = 8444,
            directory_service_dra_bad_instance_type = 8445,
            directory_service_dra_out_ofmemory = 8446,
            directory_service_dra_mail_problem = 8447,
            directory_service_dra_reference_already_exists = 8448,
            directory_service_dra_reference_not_found = 8449,
            directory_service_dra_object_is_replicated_source = 8450,
            directory_service_dra_database_error = 8451,
            directory_service_dra_no_replica = 8452,
            directory_service_dra_access_denied = 8453,
            directory_service_dra_not_supported = 8454,
            directory_service_dra_remote_procedure_call_cancelled = 8455,
            directory_service_dra_source_disabled = 8456,
            directory_service_dra_sink_disabled = 8457,
            directory_service_dra_name_collision = 8458,
            directory_service_dra_source_reinstalled = 8459,
            directory_service_dra_missing_parent = 8460,
            directory_service_dra_preempted = 8461,
            directory_service_dra_abandon_synchronization = 8462,
            directory_service_dra_shutdown = 8463,
            directory_service_dra_incompatible_partial_set = 8464,
            directory_service_dra_source_is_partial_replica = 8465,
            directory_service_dra_extended_connection_failed = 8466,
            directory_service_install_schema_mismatch = 8467,
            directory_service_duplicate_link_identity = 8468,
            directory_service_name_error_resolving = 8469,
            directory_service_name_error_not_found = 8470,
            directory_service_name_error_not_unique = 8471,
            directory_service_name_error_no_mapping = 8472,
            directory_service_name_error_domain_only = 8473,
            directory_service_name_error_no_syntactical_mapping = 8474,
            directory_service_constructed_attribute_modification = 8475,
            directory_service_wrong_object_manager_object_class = 8476,
            directory_service_dra_replication_pending = 8477,
            directory_service_directory_services_required = 8478,
            directory_service_invalid_ldap_display_name = 8479,
            directory_service_non_base_search = 8480,
            directory_service_cannot_retrieve_attributes = 8481,
            directory_service_back_link_without_link = 8482,
            directory_service_epoch_mismatch = 8483,
            directory_service_source_name_mismatch = 8484,
            directory_service_source_and_destination_nc_identical = 8485,
            directory_service_destination_nc_mismatch = 8486,
            directory_service_not_authorative_for_destination_nc = 8487,
            directory_service_source_mismatch = 8488,
            directory_service_cannot_move_deleted_object = 8489,
            directory_service_pdc_operation_in_progress = 8490,
            directory_service_cross_domain_cleanup_required = 8491,
            directory_service_illegal_cross_domain_move_operation = 8492,
            directory_service_cannot_with_account_group_memberships = 8493,
            directory_service_must_have_naming_context_parent = 8494,
            directory_servicecr_impossible_to_validate = 8495,
            directory_service_destination_domain_not_native = 8496,
            directory_service_missing_infrastructure_container = 8497,
            directory_service_cannot_move_account_group = 8498,
            directory_service_cannot_move_resource_group = 8499,
            directory_service_invalid_search_flag = 8500,
            directory_service_no_tree_delete_above_naming_context = 8501,
            directory_service_could_not_lock_tree_for_delete = 8502,
            directory_service_could_not_identify_objects_for_tree_delete = 8503,
            directory_service_sam_initialization_failure = 8504,
            directory_service_sensitive_group_violation = 8505,
            directory_service_cannot_modify_primary_group_identity = 8506,
            directory_service_illegal_base_schema_modification = 8507,
            directory_service_unsafe_schema_change = 8508,
            directory_service_unsafe_schema_update_disallowed = 8509,
            directory_service_unsafe_cannot_create_under_schema = 8510,
            directory_service_install_no_source_schema_version = 8511,
            directory_service_install_no_schema_version_in_ini_file = 8512,
            directory_service_invalid_group_type = 8513,
            directory_service_no_nest_global_group_in_mixed_domain = 8514,
            directory_service_no_nest_local_group_in_mixed_domain = 8515,
            directory_service_global_cannot_have_local_member = 8516,
            directory_service_global_cannot_have_universal_member = 8517,
            directory_service_universal_cannot_have_local_member = 8518,
            directory_service_global_cannot_have_cross_domain_member = 8519,
            directory_service_local_cannot_have_cross_domain_local_member = 8520,
            directory_service_have_primary_members = 8521,
            directory_service_string_default_conversion_failed = 8522,
            directory_service_naming_master_global_catalog = 8523,
            directory_service_dns_lookup_failure = 8524,
            directory_service_could_not_update_sevice_principal_names = 8525,
            directory_service_cannot_retrieve_security_descriptor = 8526,
            directory_service_key_not_unique = 8527,
            directory_service_wrong_linked_attribute_syntax = 8528,
            directory_service_sam_needed_boot_key_password = 8529,
            directory_service_sam_needed_boot_key_floppy = 8530,
            directory_service_cannot_start = 8531,
            directory_service_initialization_failure = 8532,
            directory_service_no_packet_privacy_on_connection = 8533,
            directory_service_source_domain_in_forest = 8534,
            directory_service_destination_domain_not_in_forest = 8535,
            directory_service_destination_auditing_not_enabled = 8536,
            directory_service_cannot_find_controller_for_source_domain = 8537,
            directory_service_source_object_not_group_or_user = 8538,
            directory_service_source_security_identity_exists_in_forest = 8539,
            directory_service_source_destination_object_class_mismatch = 8540,
            sam_initialization_failure = 8541,
            directory_service_dra_schema_information_ship = 8542,
            directory_service_dra_schema_conflict = 8543,
            directory_service_dra_earlier_schema_conflict = 8544,
            directory_service_dra_object_nc_mismatch = 8545,
            directory_service_ncstill_has_dsas = 8546,
            directory_service_global_catalog_required = 8547,
            directory_service_local_member_of_local_only = 8548,
            directory_service_nofp_o_in_universal_groups = 8549,
            directory_service_cannot_add_to_global_catalog = 8550,
            directory_service_no_check_point_with_pdc = 8551,
            directory_service_source_auditing_not_enabled = 8552,
            directory_service_cannot_create_in_non_domain_nc = 8553,
            directory_service_invalid_name_for_spn = 8554,
            directory_service_filter_uses_constructed_attributes = 8555,
            directory_service_unicode_password_not_in_quotes = 8556,
            directory_service_machine_account_quota_exceeded = 8557,
            directory_service_must_be_run_on_destination_dc = 8558,
            directory_service_source_dc_must_be_sp4_or_greater = 8559,
            directory_service_cannot_tree_delete_critical_object = 8560,
            directory_service_initialization_failure_console = 8561,
            directory_service_sam_initialization_failure_console = 8562,
            directory_service_forest_version_too_high = 8563,
            directory_service_domain_version_too_high = 8564,
            directory_service_forest_version_too_low = 8565,
            directory_service_domain_version_too_low = 8566,
            directory_service_incompatible_version = 8567,
            directory_service_low_dsa_version = 8568,
            directory_service_no_behaviour_version_in_mixed_domain = 8569,
            directory_service_not_supported_sort_order = 8570,
            directory_service_name_not_unique = 8571,
            directory_service_machine_account_create_pre_nt4 = 8572,
            directory_service_out_of_version_store = 8573,
            directory_service_incompatible_controls_used = 8574,
            directory_service_no_reference_domain = 8575,
            directory_service_reserved_link_identity = 8576,
            directory_service_link_identity_not_available = 8577,
            directory_service_account_group_cannot_have_universal_member = 8578,
            directory_service_modify_dn_disallowed_by_instance_type = 8579,
            directory_service_no_object_move_in_schema_nc = 8580,
            directory_service_modify_dn_disallowed_by_flag = 8581,
            directory_service_modify_dn_wrong_grand_parent = 8582,
            directory_service_name_error_trust_referral = 8583,
            directory_service_not_supported_on_standard_server = 8584,
            directory_service_cannot_access_remotepart_ofad = 8585,
            directory_service_cr_impossible_to_validate_v2 = 8586,
            directory_service_thread_limit_exceeded = 8587,
            directory_service_not_closest = 8588,
            directory_service_cannot_derive_spn_without_reference = 8589,
            directory_service_single_user_mode_failed = 8590,
            directory_service_ntd_script_syntax_error = 8591,
            directory_service_ntd_script_process_error = 8592,
            directory_service_different_replication_epochs = 8593,
            directory_service_drs_extensions_changed = 8594,
            directory_service_replicaset_change_not_allowed_on_disabled_cr = 8595,
            directory_service_no_msds_int_id = 8596,
            directory_service_duplicate_msds_int_id = 8597,
            directory_service_key_exists_in_rdn_att_id = 8598,
            directory_service_authorization_failed = 8599,
            directory_service_invalid_script = 8600,
            directory_service_remote_cross_reference_operation_failed = 8601,
            directory_service_cross_reference_busy = 8602,
            directory_service_cannot_derive_spn_for_deleted_domain = 8603,
            directory_service_cannot_demote_with_writeable_nc = 8604,
            directory_service_duplicate_identity_found = 8605,
            directory_service_insufficient_attributes_to_create_object = 8606,
            directory_service_group_conversion = 8607,
            directory_service_cannot_move_application_basic_group = 8608,
            directory_service_cannot_move_application_query_group = 8609,
            directory_service_role_not_verified = 8610,
            directory_service_wko_container_cannot_be_special = 8611,
            directory_service_domain_rename_in_progress = 8612,
            directory_service_existing_active_directory_child_nc = 8613,
            directory_service_replicator_lifetime_exceeded = 8614,
            directory_service_disallowed_in_system_container = 8615,
            directory_service_ldap_send_queue_full = 8616,

            ole_s_static = 0x00040001,
            ole_s_mac_clip_format = 0x00040002,
            drag_drop_s_drop = 0x00040100,
            drag_drop_s_cancel = 0x00040101,
            drag_drop_s_use_default_cursors = 0x00040102,
            datas_same_formatetc = 0x00040130,
            view_s_already_frozen = 0x00040140,
            cache_s_formatetc_not_supported = 0x00040170,
            cache_s_same_cache = 0x00040171,
            cache_s_some_caches_not_updated = 0x00040172,
            ole_obj_s_verb_invalid = 0x00040180,
            ole_obj_s_cannot_do_verb_now = 0x00040181,
            ole_obj_s_window_handle_invalid = 0x00040182,
            in_place_s_truncated = 0x000401a0,
            convert_10s_no_presentation = 0x000401c0,
            moniker_s_reduced_to_self = 0x000401e2,
            moniker_s_me = 0x000401e4,
            moniker_s_him = 0x000401e5,
            moniker_s_us = 0x000401e6,
            moniker_s_moniker_already_registered = 0x000401e7,

            not_implemented2 = 0x80000001,
            out_ofmemory2 = 0x80000002,
            argument_invalid2 = 0x80000003,
            no_interface2 = 0x80000004,
            not_implemented = 0x80004001,
            no_interface = 0x80004002,
            ipointer = 0x80004003,
            abort = 0x80004004,
            fail = 0x80004005,
            co_e_init_tls = 0x80004006,
            co_e_init_shared_allocator = 0x80004007,
            co_e_init_memory_allocator = 0x80004008,
            co_e_init_class_cache = 0x80004009,
            co_e_init_rpc_channel = 0x8000400a,
            co_e_init_tls_set_channel_control = 0x8000400b,
            co_e_init_tls_channel_control = 0x8000400c,
            co_e_init_unaccepted_user_allocator = 0x8000400d,
            co_e_init_scm_exclusiveexists = 0x8000400e,
            co_e_init_scm_file_mapping_exists = 0x8000400f,
            co_e_init_scm_map_view_of_file = 0x80004010,
            co_e_init_scm_exec_failure = 0x80004011,
            co_e_init_only_single_threaded = 0x80004012,
            co_e_cannot_remote = 0x80004013,
            co_e_bad_server_name = 0x80004014,
            co_e_wrong_server_identity = 0x80004015,
            co_e_ole1dde_disable = 0x80004016,
            co_e_run_as_syntax = 0x80004017,
            co_e_create_process_failure = 0x80004018,
            co_e_run_as_create_process_failure = 0x80004019,
            co_e_run_as_logon_failure = 0x8000401a,
            co_e_launch_permission_denied = 0x8000401b,
            co_e_start_service_failure = 0x8000401c,
            co_e_remote_communication_failure = 0x8000401d,
            co_e_server_start_timeout = 0x8000401e,
            co_e_registration_inconsistent = 0x8000401f,
            co_e_interface_registration_inconsistent = 0x80004020,
            co_e_not_supported = 0x80004021,
            co_e_reload_dynamic_link_library = 0x80004022,
            co_e_msi = 0x80004023,
            unexpected = 0x8000ffff,
            rpc_e_call_rejected = 0x80010001,
            rpc_e_call_cancelled = 0x80010002,
            rpc_e_cannot_post_in_send_call = 0x80010003,
            rpc_e_cannot_call_out_in_async_call = 0x80010004,
            rpc_e_cannot_call_out_in_external_call = 0x80010005,
            rpc_e_connection_terminated = 0x80010006,
            rpc_e_server_died = 0x80010007,
            rpc_e_client_died = 0x80010008,
            rpc_e_datapacket_invalid = 0x80010009,
            rpc_e_cannot_transmit_call = 0x8001000a,
            rpc_e_client_cannot_marshal_data = 0x8001000b,
            rpc_e_client_cannot_unmarshal_data = 0x8001000c,
            rpc_e_server_cannot_marshal_data = 0x8001000d,
            rpc_e_server_cannot_unmarshal_data = 0x8001000e,
            rpc_e_data_invalid = 0x8001000f,
            rpc_e_parameter_invalid = 0x80010010,
            rpc_e_cannot_call_out_again = 0x80010011,
            rpc_e_server_died_dne = 0x80010012,
            rpc_e_system_call_failed = 0x80010100,
            rpc_e_out_of_resources = 0x80010101,
            rpc_e_attempted_multi_thread = 0x80010102,
            rpc_e_not_registered = 0x80010103,
            rpc_e_fault = 0x80010104,
            rpc_e_server_fault = 0x80010105,
            rpc_e_changed_mode = 0x80010106,
            rpc_e_method_invalid = 0x80010107,
            rpc_e_disconnected = 0x80010108,
            rpc_e_retry = 0x80010109,
            rpc_e_server_call_retry_later = 0x8001010a,
            rpc_e_server_call_rejected = 0x8001010b,
            rpc_e_call_data_invalid = 0x8001010c,
            rpc_e_cannot_call_out_in_input_sync_call = 0x8001010d,
            rpc_e_wrong_thread = 0x8001010e,
            rpc_e_thread_not_initialized = 0x8001010f,
            rpc_e_version_mismatch = 0x80010110,
            rpc_e_invalid_header = 0x80010111,
            rpc_e_invalid_extension = 0x80010112,
            rpc_e_invalid_interface_identity = 0x80010113,
            rpc_e_invalid_object = 0x80010114,
            rpc_s_call_pending = 0x80010115,
            rpc_s_wait_on_timer = 0x80010116,
            rpc_e_call_complete = 0x80010117,
            rpc_e_unsecure_call = 0x80010118,
            rpc_e_too_late = 0x80010119,
            rpc_e_no_security_packages = 0x8001011a,
            rpc_e_access_denied = 0x8001011b,
            rpc_e_remote_disabled = 0x8001011c,
            rpc_e_invalid_object_reference = 0x8001011d,
            rpc_e_no_context = 0x8001011e,
            rpc_e_timeout = 0x8001011f,
            rpc_e_no_synchronize = 0x80010120,

            rpc_e_unexpected = 0x8001ffff,
            disp_e_interface_unknown = 0x80020001,
            disp_e_member_not_found = 0x80020003,
            disp_e_parameter_not_found = 0x80020004,
            disp_e_type_mismatch = 0x80020005,
            disp_e_name_unknown = 0x80020006,
            disp_e_no_named_arguments = 0x80020007,
            disp_e_var_type_bad = 0x80020008,
            disp_e_exception = 0x80020009,
            disp_e_overflow = 0x8002000a,
            disp_e_index_bad = 0x8002000b,
            disp_e_lc_identity_unknown = 0x8002000c,
            disp_e_array_is_locked = 0x8002000d,
            disp_e_param_count_bad = 0x8002000e,
            disp_e_param_not_optional = 0x8002000f,
            disp_e_callee_bad = 0x80020130,
            disp_e_not_a_collection = 0x80020131,
            disp_e_divide_by_zero = 0x80020132,
            type_e_buffer_too_small = 0x80028016,
            type_e_field_not_found = 0x80028017,
            type_e_data_read_invalid = 0x80028018,
            type_e_format_unsupported = 0x80028019,
            type_e_registry_access = 0x8002801c,
            type_e_library_not_registered = 0x8002801d,
            type_e_type_undefined = 0x80028027,
            type_e_qualified_name_disallowed = 0x80028028,
            type_e_state_invalid = 0x80028029,
            type_e_wrong_type_kind = 0x8002802a,
            type_e_element_not_found = 0x8002802b,
            type_e_name_ambiguous = 0x8002802c,
            typee_name_conflict = 0x8002802d,
            typee_lc_identity_unknown = 0x8002802e,
            typee_dll_function_not_found = 0x8002802f,
            typee_module_kind_bad = 0x800288bd,
            typee_size_too_big = 0x800288c5,
            typee_duplicate_identity = 0x800288c6,
            typee_identity_invalid = 0x800288cf,
            typee_type_mismatch = 0x80028ca0,
            typee_out_ofbounds = 0x80028ca1,
            typee_io_error = 0x80028ca2,
            typee_cannot_create_temporary_file = 0x80028ca3,
            typee_cannot_load_library = 0x80029c4a,
            typee_inconsistent_prop_funcs = 0x80029c83,
            typee_circular_type = 0x80029c84,
            stg_e_function_invalid = 0x80030001,
            stg_e_file_not_found = 0x80030002,
            stg_e_path_not_found = 0x80030003,
            stg_e_too_many_open_files = 0x80030004,
            stg_e_access_denied = 0x80030005,
            stg_e_handle_invalid = 0x80030006,
            stg_e_insufficient_memory = 0x80030008,
            stg_e_pointer_invalid = 0x80030009,
            stg_e_no_more_files = 0x80030012,
            stg_e_disk_is_write_protected = 0x80030013,
            stg_e_seek_error = 0x80030019,
            stg_e_write_fault = 0x8003001d,
            stg_e_read_fault = 0x8003001e,
            stg_e_share_violation = 0x80030020,
            stg_e_lock_violation = 0x80030021,
            stg_e_file_already_exists = 0x80030050,
            stg_e_parameter_invalid = 0x80030057,
            stg_e_medium_full = 0x80030070,
            stg_e_property_set_mismatch = 0x800300f0,
            stg_e_abnormal_api_exit = 0x800300fa,
            stg_e_header_invalid = 0x800300fb,
            stg_e_name_invalid = 0x800300fc,
            stg_e_unknown = 0x800300fd,
            stg_e_function_not_implemented = 0x800300fe,
            stg_e_flag_invalid = 0x800300ff,
            stg_e_in_use = 0x80030100,
            stg_e_not_current = 0x80030101,
            stg_e_reverted = 0x80030102,
            stg_e_cannot_save = 0x80030103,
            stg_e_old_format = 0x80030104,
            stg_e_old_dll = 0x80030105,
            stg_e_share_required = 0x80030106,
            stg_e_not_file_based_storage = 0x80030107,
            stg_e_extant_marshallings = 0x80030108,
            stg_e_document_file_corrupt = 0x80030109,
            stg_e_bad_base_address = 0x80030110,
            stg_s_converted = 0x80030200,
            stg_e_incomplete = 0x80030201,
            stg_e_terminated = 0x80030202,
            ole_verb = 0x80040000,
            ole_e_advise_flags = 0x80040001,
            ole_e_enumerate_no_more = 0x80040002,
            ole_e_advise_not_supported = 0x80040003,
            ole_e_no_connection = 0x80040004,
            ole_e_not_running = 0x80040005,
            ole_e_no_cache = 0x80040006,
            ole_e_blank = 0x80040007,
            ole_e_class_different = 0x80040008,
            ole_e_cannot_get_moniker = 0x80040009,
            ole_e_cannot_bind_to_source = 0x8004000a,
            ole_e_static = 0x8004000b,
            ole_e_prompt_save_cancelled = 0x8004000c,
            ole_e_rectangle_invalid = 0x8004000d,
            ole_e_wrong_comp_obj = 0x8004000e,
            ole_e_window_handle_invalid = 0x8004000f,
            ole_e_not_in_place_active = 0x80040010,
            ole_e_cannot_convert = 0x80040011,
            ole_e_no_storage = 0x80040012,
            dve_formatetc = 0x80040064,
            dve_dv_target_device = 0x80040065,
            dve_stdg_medium = 0x80040066,
            dve_stat_data = 0x80040067,
            dve_lindex = 0x80040068,
            dve_tymed = 0x80040069,
            dve_clip_format = 0x8004006a,
            dve_dv_aspect = 0x8004006b,
            dve_dv_target_device_size = 0x8004006c,
            dve_no_i_view_object = 0x8004006d,
            drag_drop_e_not_registered = 0x80040100,
            drag_drop_e_already_registered = 0x80040101,
            drag_drop_e_window_handle_invalid = 0x80040102,
            class_e_no_aggregation = 0x80040110,
            class_e_class_not_available = 0x80040111,
            class_e_not_licensed = 0x80040112,

            view_e_draw = 0x80040140,
            registry_e_read = 0x80040150,
            registry_e_write = 0x80040151,
            registry_e_key_missing = 0x80040152,
            registry_e_value_invalid = 0x80040153,
            registry_e_class_not_registered = 0x80040154,
            registry_e_interface_not_registered = 0x80040155,
            cachee_cache_not_updated = 0x80040170,
            ole_obj_e_no_verbs = 0x80040180,
            ole_obj_e_verb_invalid = 0x80040181,
            in_pla_key_not_undoable = 0x800401a0,
            in_pla_key_no_tool_space = 0x800401a1,
            convert_10e_ole_stream_get = 0x800401b0,
            convert_10e_ole_stream_put = 0x800401c1,
            convert_10e_ole_stream_format = 0x800401c2,
            convert_10e_ole_stream_bitmap_to_dib = 0x800401c3,
            convert_10e_i_storage_format = 0x800401c4,
            convert_10e_i_storage_no_standard_stream = 0x800401c5,
            convert_10e_i_storage_dib_to_bitmap = 0x800401c6,
            clipboard_e_cannot_open = 0x800401d0,
            clipboard_e_cannot_empty = 0x800401d1,
            clipboard_e_cannot_set = 0x800401d2,
            clipboard_e_databad = 0x800401d3,
            clipboard_e_cannot_close = 0x800401d4,
            moniker_e_connect_manually = 0x800401e0,
            moniker_e_exceeded_deadline = 0x800401e1,
            moniker_e_need_generic = 0x800401e2,
            moniker_e_unavailable = 0x800401e3,
            moniker_e_syntax = 0x800401e4,
            moniker_e_no_object = 0x800401e5,
            moniker_e_extension_invalid = 0x800401e6,
            moniker_e_intermediate_interface_not_supported = 0x800401e7,
            moniker_e_not_bindable = 0x800401e8,
            moniker_e_not_bound = 0x800401e9,
            moniker_e_cannot_open_file = 0x800401ea,
            moniker_e_must_bother_user = 0x800401eb,
            moniker_e_no_inverse = 0x800401ec,
            moniker_e_no_storage = 0x800401ed,
            moniker_e_no_prefix = 0x800401ee,
            moniker_eenumeration_failed = 0x800401ef,
            co_e_not_initialized = 0x800401f0,
            co_e_already_initialized = 0x800401f1,
            co_e_cannot_determine_class = 0x800401f2,
            co_e_class_string = 0x800401f3,
            co_e_interface_string = 0x800401f4,
            co_e_application_not_found = 0x800401f5,
            co_e_application_single_use = 0x800401f6,
            co_e_error_in_application = 0x800401f7,
            co_e_dll_not_found = 0x800401f8,
            co_e_error_in_dll = 0x800401f9,
            co_e_wrong_operating_system_for_application = 0x800401fa,
            co_e_object_not_registered = 0x800401fb,
            co_e_object_is_registered = 0x800401fc,
            co_e_object_not_connected = 0x800401fd,
            co_e_application_did_not_register = 0x800401fe,
            co_e_released = 0x800401ff,
            co_e_failed_to_impersonate = 0x80040200,
            co_e_failed_to_get_server_security_context = 0x80040201,
            co_e_failed_to_open_thread_token = 0x80040202,
            co_e_failed_to_get_thread_token_information = 0x80040203,
            co_e_trustee_does_not_match_client = 0x80040204,
            co_e_failed_to_query_client_blanket = 0x80040205,
            co_e_failed_to_set_discretionary_access_control_list = 0x80040206,
            co_e_access_check_failed = 0x80040207,
            co_e_network_access_function_failed = 0x80040208,
            co_e_wrong_trustee_name_syntax = 0x80040209,
            co_e_invalid_security_identity = 0x8004020a,
            co_e_conversion_failed = 0x8004020b,
            co_e_no_matching_identity_found = 0x8004020c,
            co_e_lookup_account_identity_failed = 0x8004020d,
            co_e_no_matching_name_found = 0x8004020e,
            co_e_lookup_account_name_failed = 0x8004020f,
            co_e_set_serialization_handler_failed = 0x80040210,
            co_e_failed_to_get_windows_directory = 0x80040211,
            co_e_path_too_long = 0x80040212,
            co_e_failed_to_generate_universally_unique_identity = 0x80040213,
            co_e_failed_to_create_file = 0x80040214,
            co_e_failed_to_close_handle = 0x80040215,
            co_e_access_list_limit_exceeded = 0x80040216,
            co_e_access_entries_in_wrong_order = 0x80040217,
            co_e_incompatible_stream_version = 0x80040218,
            co_e_failed_to_open_process_token = 0x80040219,
            co_e_failed_to_decode = 0x8004021a,
            co_e_access_control_object_not_initialized = 0x8004021b,
            e_access_denied = 0x80070005,
            e_handle = 0x80070006,
            e_out_ofmemory = 0x8007000e,
            e_argument_invalid = 0x80070057,
            co_e_class_create_failed = 0x80080001,
            co_e_service_key_error = 0x80080002,
            co_e_service_rpc_failure = 0x80080003,
            co_e_path_bad = 0x80080004,
            co_e_server_exec_failure = 0x80080005,
            co_e_obj_srv_rpc_failure = 0x80080006,
            moniker_e_no_normalized = 0x80080007,
            co_e_server_stopping = 0x80080008,
            mem_e_root_invalid = 0x80080009,
            mem_e_link_invalid = 0x80080010,
            mem_e_size_invalid = 0x80080011,
            co_s_not_all_interfaces = 0x80080012
        };
    };

    export struct trap_code
    {
        enum
        {
            trap_code_normal = 0,
            trap_code_hard_error = 1,
            trap_code_protection = 2,
            trap_code_signal = 3
        };
    };

    export struct last_error_flag
    {
        enum
        {
            error = 0x00000001,
            minor = 0x00000002,
            warning = 0x00000003
        };
    };

    export struct error_mode
    {
        enum
        {
            fail_critical_errors = 0x0001,
            no_protection_fault_error_box = 0x0002,
            no_alignment_fault_exceptions = 0x0004,
            no_open_file_error_box = 0x8000
        };
    };

    export struct atom_value
    {
        enum
        {
            integer_maximum = 0xc000,
            invalid = 0x0000,
        };
    };

    export struct compare_strings_result
    {
        enum
        {
            less_than = 1,
            equal = 2,
            greater_than = 3
        };
    };

    export  typedef part language_identity;
    export  typedef uint locale_identity;

    export struct _language
    {
        enum
        {
            neutral = 0x00,
            afrikaans = 0x36,
            albanian = 0x1c,
            arabic = 0x01,
            armenian = 0x2b,
            assamese = 0x4d,
            azeri = 0x2c,
            basque = 0x2d,
            belarusian = 0x23,
            bengali = 0x45,
            bulgarian = 0x02,
            catalan = 0x03,
            chinese = 0x04,
            croatian = 0x1a,
            czech = 0x05,
            danish = 0x06,
            dutch = 0x13,
            english = 0x09,
            estonian = 0x25,
            faeroese = 0x38,
            farsi = 0x29,
            finnish = 0x0b,
            french = 0x0c,
            georgian = 0x37,
            german = 0x07,
            greek = 0x08,
            gujarati = 0x47,
            hebrew = 0x0d,
            hindi = 0x39,
            hungarian = 0x0e,
            icelandic = 0x0f,
            indonesian = 0x21,
            italian = 0x10,
            japanese = 0x11,
            kannada = 0x4b,
            kashmiri = 0x60,
            kazak = 0x3f,
            konkani = 0x57,
            korean = 0x12,
            latvian = 0x26,
            lithuanian = 0x27,
            macedonian = 0x2f,
            malay = 0x3e,
            malayalam = 0x4c,
            manipuri = 0x58,
            marathi = 0x4e,
            nepali = 0x61,
            norwegian = 0x14,
            oriya = 0x48,
            polish = 0x15,
            portuguese = 0x16,
            punjabi = 0x46,
            romanian = 0x18,
            russian = 0x19,
            sanskrit = 0x4f,
            serbian = 0x1a,
            sindhi = 0x59,
            slovak = 0x1b,
            slovenian = 0x24,
            spanish = 0x0a,
            swahili = 0x41,
            swedish = 0x1d,
            tamil = 0x49,
            tatar = 0x44,
            telugu = 0x4a,
            thai = 0x1e,
            turkish = 0x1f,
            ukrainian = 0x22,
            urdu = 0x20,
            uzbek = 0x43,
            vietnamese = 0x2a
        };
    };

    export struct sublanguage
    {
        enum
        {
            neutral = 0x00,
            _default = 0x01,
            system_default = 0x02,

            arabic_saudi_arabia = 0x01,
            arabic_iraq = 0x02,
            arabic_egypt = 0x03,
            arabic_libya = 0x04,
            arabic_algeria = 0x05,
            arabic_morocco = 0x06,
            arabic_tunisia = 0x07,
            arabic_oman = 0x08,
            arabic_yemen = 0x09,
            arabic_syria = 0x0a,
            arabic_jordan = 0x0b,
            arabic_lebanon = 0x0c,
            arabic_kuwait = 0x0d,
            arabic_united_arab_emirates = 0x0e,
            arabic_bahrain = 0x0f,
            arabic_qatar = 0x10,
            azeri_latin = 0x01,
            azeri_cyrillic = 0x02,
            chinese_traditional = 0x01,
            chinese_simplified = 0x02,
            chinese_hong_kong = 0x03,
            chinese_singapore = 0x04,
            chinese_macau = 0x05,
            dutch = 0x01,
            dutch_belgian = 0x02,
            english_united_states = 0x01,
            english_united_kingdom = 0x02,
            english_australia = 0x03,
            english_canada = 0x04,
            english_new_zealand = 0x05,
            english_eire = 0x06,
            english_south_africa = 0x07,
            english_jamaica = 0x08,
            english_caribbean = 0x09,
            english_belize = 0x0a,
            english_trinidad = 0x0b,
            english_zimbabwe = 0x0c,
            english_philippines = 0x0d,
            french = 0x01,
            french_belgian = 0x02,
            french_canadian = 0x03,
            french_swiss = 0x04,
            french_luxembourg = 0x05,
            french_monaco = 0x06,
            german = 0x01,
            german_swiss = 0x02,
            german_austrian = 0x03,
            german_luxembourg = 0x04,
            german_liechtenstein = 0x05,
            italian = 0x01,
            italian_swiss = 0x02,
            korean = 0x01,
            korean_johab = 0x02,
            lithuanian = 0x01,
            lithuanian_classic = 0x02,
            malay_malaysia = 0x01,
            malay_brunei_darussalam = 0x02,
            nepali_india = 0x02,
            norwegian_bokmal = 0x01,
            norwegian_nynorsk = 0x02,
            portuguese = 0x02,
            portuguese_brazilian = 0x01,
            serbian_latin = 0x02,
            serbian_cyrillic = 0x03,
            spanish = 0x01,
            spanish_mexican = 0x02,
            spanish_modern = 0x03,
            spanish_guatemala = 0x04,
            spanish_costarica = 0x05,
            spanish_panama = 0x06,
            spanish_dominican_republic = 0x07,
            spanish_venezuela = 0x08,
            spanish_colombia = 0x09,
            spanish_peru = 0x0a,
            spanish_argentina = 0x0b,
            spanish_ecuador = 0x0c,
            spanish_chile = 0x0d,
            spanish_uruguay = 0x0e,
            spanish_paraguay = 0x0f,
            spanish_bolivia = 0x10,
            spanish_el_salvador = 0x11,
            spanish_honduras = 0x12,
            spanish_nicaragua = 0x13,
            spanish_puerto_rico = 0x14,
            swedish = 0x01,
            swedish_finland = 0x02,
            urdu_pakistan = 0x01,
            urdu_india = 0x02,
            uzbek_latin = 0x01,
            uzbek_cyrillic = 0x02,
        };
    };

    export struct sort_identity
    {
        enum
        {
            _default = 0x0,
            japanese_xjis = 0x0,
            japanese_unicode = 0x1,
            chinese_big5 = 0x0,
            chinese_phonetic = 0x0,
            chineseunicode = 0x1,
            chinese_stroke_count = 0x2,
            chinese_bopomofo = 0x3,
            korean_ksc = 0x0,
            korean_unicode = 0x1,
            german_phone_book = 0x1,
            hungarian_default = 0x0,
            hungarian_technical = 0x1,
            georgian_traditional = 0x0,
            georgian_modern = 0x1
        };
    };

    export  uint make_language(uint p, uint s) { return (s << 10) | p; }

    export  uint get_primary_language(uint language) { return language & 0x3ff; }
    export  uint get_sublanguage(uint language) { return language >> 10; }

    export  uint make_locale(uint language, uint sort) { return language | (sort << 16); }

    export  uint language_from_locale(uint locale_language) { return (part)locale_language; }

    export  uint  language_system_default = make_language(_language::neutral, sublanguage::system_default);
    export  uint  language_user_default = make_language(_language::neutral, sublanguage::_default);

    export  uint locale_system_default = make_locale(language_system_default, sort_identity::_default);
    export  uint locale_user_default = make_locale(language_user_default, sort_identity::_default);

    export struct maximum_length
    {
        enum
        {
            lead_bytes = 12, // 5 ranges, 2 bytes ea., 0 term.
            default_character = 2   // single or double byte
        };
    };

    export struct multi_byte
    {
        enum
        {
            precomposed = 0x00000001,
            composite = 0x00000002,
            glyph_characters = 0x00000004,
            error_invalid_characters = 0x00000008,
            composite_check = 0x00000200,
            discard_nonspaces = 0x00000010,
            separate = 0x00000020,
            default_character = 0x00000040,
            no_best_fit_characters = 0x00000400
        };
    };

    export struct character_type
    {
        enum
        {
            type1 = 0x00000001, // character type 1 information
            type2 = 0x00000002, // character type 2 information
            type3 = 0x00000004  // character type 3 information
        };
    };

    export struct character_type1
    {
        enum
        {
            upper = 0x0001, // upper case
            lower = 0x0002, // lower case
            digit = 0x0004, // decimal digits
            space = 0x0008, // spacing characters
            punctuation = 0x0010, // punctuation characters
            control = 0x0020, // control characters
            blank = 0x0040, // blank characters
            x_digit = 0x0080, // other digits
            alpha = 0x0100  // any linguistic character
        };
    };

    export struct character_type2
    {
        enum
        {
            left_to_right = 0x0001, // left to right
            right_to_left = 0x0002, // right to left
            european_number = 0x0003, // european number, digit
            european_separator = 0x0004, // european numeric separator
            european_terminator = 0x0005, // european numeric terminator
            arabic_number = 0x0006, // arabic number
            common_separator = 0x0007, // common numeric separator
            block_separator = 0x0008, // block separator
            segment_separator = 0x0009, // segment separator
            white_space = 0x000a, // white space
            other_neutral = 0x000b, // other neutrals
            not_applicable = 0x0000, // no implicit directionality
        };
    };

    export struct character_type3
    {
        enum
        {
            non_spacing = 0x0001, // nonspacing character
            diacritic = 0x0002, // diacritic mark
            vowel_mark = 0x0004, // vowel mark
            symbol = 0x0008, // symbols
            katakana = 0x0010, // katakana character
            hiragana = 0x0020, // hiragana character
            half_width = 0x0040, // half width character
            full_width = 0x0080, // full width character
            ideographic = 0x0100, // ideographic character
            kashida = 0x0200, // arabic kashida character
            lexical = 0x0400, // lexical character
            alpha = 0x8000, // any linguistic character (character_type1alpha)
            not_applicable = 0x0000, // ctype 3 is not applicable
        };
    };

    export struct character_ignore
    {
        enum
        {
            _case = 0x00000001,  // ignore case
            nonspace = 0x00000002,  // ignore nonspacing chars
            symbols = 0x00000004,  // ignore symbols
            kana_type = 0x00010000,  // ignore kanatype
            width = 0x00020000,  // ignore width
        };
    };

    export struct map_locale
    {
        enum
        {
            fold_compatibility_zone = 0x00000010,  // fold compatibility zone characters
            precomposed = 0x00000020,  // convert to precomposed characters
            composite = 0x00000040,  // convert to composite characters
            fold_digits = 0x00000080,  // all digits to asci_i 0-9
            expand_ligatures = 0x00002000   // expand all ligatures 
        };
    };

    export struct locale_map
    {
        enum
        {
            lower_case = 0x00000100,  // lower case letters
            upper_case = 0x00000200,  // upper case letters
            sort_key = 0x00000400,  // wide character sort key (normalize)
            byte_reverse = 0x00000800,  // byte reversal

            hiragana = 0x00100000,  // map katakana to hiragana
            katakana = 0x00200000,  // map hiragana to katakana
            half_width = 0x00400000,  // map number byte to float byte
            full_width = 0x00800000,  // map float byte to double byte

            linguistic_casing = 0x01000000,  // use linguistic rules for casing

            simplified_chinese = 0x02000000,  // map traditional chinese to simplified chinese
            traditional_chinese = 0x04000000   // map simplified chinese to traditional chinese
        };
    };

    export struct locale_property
    {
        enum
        {
            installed = 0x0001,  // installed locale identities
            supported = 0x0002,  // supported locale identities
            alternate_sorts = 0x0004   // alternate sort locale identities
        };
    };

    export struct codepage_enumerate
    {
        enum
        {
            installed = 0x00000001,  // installed code page identities
            supported = 0x00000002   // supported code page identities
        };
    };

    export struct sort_method
    {
        enum
        {
            string = 0x00001000,  // use string sort method
        };
    };

    export struct string_compare_return
    {
        enum
        {
            less = 1,
            equal = 2,
            greater = 3
        };
    };

    export struct default_codepage
    {
        enum
        {
            standard = 0,
            locale = 1,
            macintosh = 2,
            thread_standard = 3,
            symbol = 42,
            utf7 = 65000, // utf7 translation
            utf8 = 65001  // utf8 translation
        };
    };

    export struct country_identity
    {
        enum
        {
            _default = 0,
            albania = 355,
            algeria = 213,
            argentina = 54,
            australia = 61,
            austria = 43,
            bahrain = 973,
            belarus = 375,
            belgium = 32,
            belize = 501,
            bolivia = 591,
            brazil = 55,
            brunei_darussalam = 673,
            bulgaria = 359,
            canada = 2,
            caribbean = 1,
            chile = 56,
            china = 86,
            colombia = 57,
            costarica = 506,
            croatia = 385,
            czechoslovakia = 420,
            denmark = 45,
            dominican_republic = 1,
            ecuador = 593,
            egypt = 20,
            el_salvador = 503,
            estonia = 372,
            faeroe_islands = 298,
            finland = 358,
            france = 33,
            germany = 49,
            greece = 30,
            guatemala = 502,
            honduras = 504,
            hong_kong = 852,
            hungary = 36,
            iceland = 354,
            india = 91,
            indonesia = 62,
            iran = 981,
            iraq = 964,
            ireland = 353,
            israel = 972,
            italy = 39,
            jamaica = 1,
            japan = 81,
            jordan = 962,
            kenya = 254,
            kuwait = 965,
            latvia = 371,
            lebanon = 961,
            libya = 218,
            liechtenstein = 41,
            lithuania = 370,
            luxembourg = 352,
            macau = 853,
            macedonia = 389,
            malaysia = 60,
            mexico = 52,
            monaco = 33,
            morocco = 212,
            netherlands = 31,
            new_zealand = 64,
            nicaragua = 505,
            norway = 47,
            oman = 968,
            pakistan = 92,
            panama = 507,
            paraguay = 595,
            peru = 51,
            philippines = 63,
            poland = 48,
            portugal = 351,
            puerto_rico = 1,
            qatar = 974,
            romania = 40,
            russia = 7,
            saudi_arabia = 966,
            serbia = 381,
            singapore = 65,
            slovakia = 421,
            slovenia = 386,
            south_africa = 27,
            south_korea = 82,
            spain = 34,
            sweden = 46,
            switzerland = 41,
            syria = 963,
            taiwan = 886,
            thailand = 66,
            trinidad_y_tobago = 1,
            tunisia = 216,
            turkey = 90,
            united_arab_emirates = 971,
            ukraine = 380,
            united_kingdom = 44,
            united_states = 1,
            uruguay = 598,
            venezuela = 58,
            vietnam = 84,
            yemen = 967,
            zimbabwe = 263
        };
    };

    export struct locale_types
    {
        enum
        {
            use_no_override = 0x80000000,   // do not use user overrides
            use_system = 0x40000000,   // use the system ansi code page
            use_return_number = 0x20000000,   // return number instead of string

            i_language = 0x00000001,   // language id
            s_language = 0x00000002,   // localized name of language
            s_english_language = 0x00001001,   // english name of language
            s_abbreviated_language_name = 0x00000003,   // abbreviated language name
            s_native_language_name = 0x00000004,   // native name of language

            i_country = 0x00000005,   // country code
            s_country = 0x00000006,   // localized name of countr
            s_english_country = 0x00001002,   // english name of country
            s_abbreviated_country_name = 0x00000007,   // abbreviated country name
            s_native_country_name = 0x00000008,   // native name of country

            i_default_language = 0x00000009,   // default language id
            i_default_country = 0x0000000a,   // default country code
            i_default_codepage = 0x0000000b,   // default oem code page
            i_default_codepagean_s_i = 0x00001004,   // default ansi code page
            i_default_codepage_mac = 0x00001011,   // default mac code page

            s_list = 0x0000000c,   // list item separator
            i_measure = 0x0000000d,   // 0 = metric, 1 = u_s

            s_decimal = 0x0000000e,   // decimal separator
            s_thousand = 0x0000000f,   // thousand separator
            s_grouping = 0x00000010,   // digit grouping
            i_digits = 0x00000011,   // number of fractional digits
            i_leading_zero = 0x00000012,   // leading zeros for decimal
            i_negative_number = 0x00001010,   // negative number mode
            s_native_digits = 0x00000013,   // native ascii 0-9

            s_currency = 0x00000014,   // local monetary symbol
            s_international_symbol = 0x00000015,   // intl monetary symbol
            s_monetary_decimal_separator = 0x00000016,   // monetary decimal separator
            s_monetary_thousand_separator = 0x00000017,   // monetary thousand separator
            s_monetary_grouping = 0x00000018,   // monetary grouping
            i_currency_digits = 0x00000019,   // # local monetary digits
            i_international_currency_digits = 0x0000001a,   // # intl monetary digits
            i_currency = 0x0000001b,   // positive currency mode
            i_negative_currency = 0x0000001c,   // negative currency mode

            s_date = 0x0000001d,   // date separator
            s_time = 0x0000001e,   // time separator
            s_short_date = 0x0000001f,   // short date format string
            s_long_date = 0x00000020,   // int date format string
            s_time_format = 0x00001003,   // time format string
            i_date = 0x00000021,   // short date format ordering
            i_long_date = 0x00000022,   // int date format ordering
            i_time = 0x00000023,   // time format specifier
            i_time_marker_position = 0x00001005,   // time marker position
            i_century = 0x00000024,   // century format specifier (short date)
            i_time_leading_zero = 0x00000025,   // leading zeros in time field
            i_day_leading_zero = 0x00000026,   // leading zeros in day field (short date)
            i_month_leading_zero = 0x00000027,   // leading zeros in month field (short date)
            s1159 = 0x00000028,   // am designator
            s2359 = 0x00000029,   // p_m designator

            i_calendar_type = 0x00001009,   // type of calendar specifier
            i_optional_calendar = 0x0000100b,   // additional calendar types specifier
            i_first_day_of_week = 0x0000100c,   // first day of week specifier
            i_first_week_of_year = 0x0000100d,   // first week of year specifier

            s_day_name1 = 0x0000002a,   // int name for monday
            s_day_name2 = 0x0000002b,   // int name for tuesday
            s_day_name3 = 0x0000002c,   // int name for wednesday
            s_day_name4 = 0x0000002d,   // int name for thursday
            s_day_name5 = 0x0000002e,   // int name for friday
            s_day_name6 = 0x0000002f,   // int name for saturday
            s_day_name7 = 0x00000030,   // int name for sunday
            s_abbreviated_day_name1 = 0x00000031,   // abbreviated name for monday
            s_abbreviated_day_name2 = 0x00000032,   // abbreviated name for tuesday
            s_abbreviated_day_name3 = 0x00000033,   // abbreviated name for wednesday
            s_abbreviated_day_name4 = 0x00000034,   // abbreviated name for thursday
            s_abbreviated_day_name5 = 0x00000035,   // abbreviated name for friday
            s_abbreviated_day_name6 = 0x00000036,   // abbreviated name for saturday
            s_abbreviated_day_name7 = 0x00000037,   // abbreviated name for sunday
            s_month_name1 = 0x00000038,   // int name for january
            s_month_name2 = 0x00000039,   // int name for february
            s_month_name3 = 0x0000003a,   // int name for march
            s_month_name4 = 0x0000003b,   // int name for april
            s_month_name5 = 0x0000003c,   // int name for may
            s_month_name6 = 0x0000003d,   // int name for june
            s_month_name7 = 0x0000003e,   // int name for july
            s_month_name8 = 0x0000003f,   // int name for august
            s_month_name9 = 0x00000040,   // int name for september
            s_month_name10 = 0x00000041,   // int name for october
            s_month_name11 = 0x00000042,   // int name for november
            s_month_name12 = 0x00000043,   // int name for december
            s_month_name13 = 0x0000100e,   // int name for 13th month (if exists)
            s_abbreviated_month_name1 = 0x00000044,   // abbreviated name for january
            s_abbreviated_month_name2 = 0x00000045,   // abbreviated name for february
            s_abbreviated_month_name3 = 0x00000046,   // abbreviated name for march
            s_abbreviated_month_name4 = 0x00000047,   // abbreviated name for april
            s_abbreviated_month_name5 = 0x00000048,   // abbreviated name for may
            s_abbreviated_month_name6 = 0x00000049,   // abbreviated name for june
            s_abbreviated_month_name7 = 0x0000004a,   // abbreviated name for july
            s_abbreviated_month_name8 = 0x0000004b,   // abbreviated name for august
            s_abbreviated_month_name9 = 0x0000004c,   // abbreviated name for september
            s_abbreviated_month_name10 = 0x0000004d,   // abbreviated name for october
            s_abbreviated_month_name11 = 0x0000004e,   // abbreviated name for november
            s_abbreviated_month_name12 = 0x0000004f,   // abbreviated name for december
            s_abbreviated_month_name13 = 0x0000100f,   // abbreviated name for 13th month (if exists)

            s_positive_sign = 0x00000050,   // positive sign
            s_negative_sign = 0x00000051,   // negative sign
            i_positive_sign_position = 0x00000052,   // positive sign position
            i_negative_sign_position = 0x00000053,   // negative sign position
            i_positive_symbol_precedes = 0x00000054,   // mon sym precedes pos amt
            i_positive_separated_by_space = 0x00000055,   // mon sym sep by space from pos amt
            i_negative_symbol_precedes = 0x00000056,   // mon sym precedes neg amt
            i_negative_separated_by_space = 0x00000057,   // mon sym sep by space from neg amt
            font_signature = 0x00000058,   // font signature
            s_iso639_language_name = 0x00000059,   // i_s_o abbreviated language name
            s_iso3166_country_name = 0x0000005a,   // i_s_o abbreviated country name
            i_default_ebcdic_codepage = 0x00001012,   // default ebcdic code page
            i_paper_size = 0x0000100a,   // 0 = letter, 1 = a4, 2 = legal, 3 = a3
            s_english_currency_name = 0x00001007,   // english name of currency
            s_native_currency_name = 0x00001008,   // native name of currency
            s_year_month = 0x00001006,   // year month format string
            s_sort_name = 0x00001013,   // sort name
            i_digit_substitution = 0x00001014    // 0 = none, 1 = context, 2 = native digit
        };
    };

    export struct time_format
    {
        enum
        {
            no_minutes_or_seconds = 0x00000001, // do not use minutes or seconds
            no_seconds = 0x00000002, // do not use seconds
            no_time_marker = 0x00000004, // do not use time marker
            force_24_hour_format = 0x00000008
        };
    };

    export struct date_format_flag
    {
        enum
        {
            _short = 0x00000001, // use short date picture
            _long = 0x00000002, // use int date picture
            alternate_calendar = 0x00000004, // use alternate calendar (if any)
            year_month = 0x00000008, // use year month picture
            left_to_right = 0x00000010, // add marks for left to right reading
            right_to_left = 0x00000020  // add marks for right to left reading
        };
    };

    export struct calendar_identities
    {
        enum
        {
            any = 0xffffffff,  // enumerate all calendars
            gregorian = 1,  // gregorian (localized) calendar
            gregorian_us = 2,  // gregorian (u.s.) calendar
            japan = 3,  // japanese emperor era calendar
            taiwan = 4,  // taiwan region era calendar
            korea = 5,  // korean tangun era calendar
            hijri = 6,  // hijri (arabic lunar) calendar
            thai = 7,  // thai calendar
            hebrew = 8,  // hebrew (lunar) calendar
            gregorian_middle_east_french = 9,  // gregorian middle east french calendar
            gregorian_arabic = 10, // gregorian arabic calendar
            gregorian_transliterated_english = 11, // gregorian transliterated english calendar
            gregorian_transliterated_french = 12  // gregorian transliterated french calendar
        };
    };

    export struct calendar_types
    {
        enum
        {
            s_name = 0x00000002,
            i_year_offset_range = 0x00000003,
            s_era_string = 0x00000004,
            s_short_date = 0x00000005,
            s_long_date = 0x00000006,
            s_day_name1 = 0x00000007,
            s_day_name2 = 0x00000008,
            s_day_name3 = 0x00000009,
            s_day_name4 = 0x0000000a,
            s_day_name5 = 0x0000000b,
            s_day_name6 = 0x0000000c,
            s_day_name7 = 0x0000000d,
            s_abbreviated_day_name1 = 0x0000000e,
            s_abbreviated_day_name2 = 0x0000000f,
            s_abbreviated_day_name3 = 0x00000010,
            s_abbreviated_day_name4 = 0x00000011,
            s_abbreviated_day_name5 = 0x00000012,
            s_abbreviated_day_name6 = 0x00000013,
            s_abbreviated_day_name7 = 0x00000014,
            s_month_name1 = 0x00000015,
            s_month_name2 = 0x00000016,
            s_month_name3 = 0x00000017,
            s_month_name4 = 0x00000018,
            s_month_name5 = 0x00000019,
            s_month_name6 = 0x0000001a,
            s_month_name7 = 0x0000001b,
            s_month_name8 = 0x0000001c,
            s_month_name9 = 0x0000001d,
            s_month_name10 = 0x0000001e,
            s_month_name11 = 0x0000001f,
            s_month_name12 = 0x00000020,
            s_month_name13 = 0x00000021,
            s_abbreviated_month_name1 = 0x00000022,
            s_abbreviated_month_name2 = 0x00000023,
            s_abbreviated_month_name3 = 0x00000024,
            s_abbreviated_month_name4 = 0x00000025,
            s_abbreviated_month_name5 = 0x00000026,
            s_abbreviated_month_name6 = 0x00000027,
            s_abbreviated_month_name7 = 0x00000028,
            s_abbreviated_month_name8 = 0x00000029,
            s_abbreviated_month_name9 = 0x0000002a,
            s_abbreviated_month_name10 = 0x0000002b,
            s_abbreviated_month_name11 = 0x0000002c,
            s_abbreviated_month_name12 = 0x0000002d,
            s_abbreviated_month_name13 = 0x0000002e,
            s_year_month = 0x0000002f
        };
    };

    export  typedef uint locale_type;
    export  typedef uint calendar_type;
    export  typedef uint calendar_identity;

    export struct codepage_information
    {
        uint maximum_character_size;
        byte default_character[maximum_length::default_character];
        byte lead_byte[maximum_length::lead_bytes];
    };

    export template<class character>
        struct codepage_information_extended : public codepage_information
    {
        wchar_t unicode_default;
        uint codepage;
        character codepage_name[path_length::maximum];
    };

    export template<class character>
        struct number_format_flags
    {
        uint number_digits;
        uint leading_zero;
        uint grouping;
        character* decimal_separator;
        character* thousand_separator;
        uint negative_order;
    };

    export template<class character>
        struct currency_format_flags
    {
        uint number_digits;
        uint leading_zero;
        uint grouping;
        character* decimal_separator;
        character* thousand_separator;
        uint negative_order;
        uint positive_order;
        character* currency_symbol;
    };

    export  typedef bool(__stdcall* locale_callback_a)(char*);
    export  typedef bool(__stdcall* locale_callback_w)(wchar_t*);
    export  typedef bool(__stdcall* locale_callback)(character*);

    export  typedef bool(__stdcall* codepage_callback_a)(char*);
    export  typedef bool(__stdcall* codepage_callback_w)(wchar_t*);
    export  typedef bool(__stdcall* codepage_callback)(character*);

    export  typedef bool(__stdcall* format_date_callback_a)(char*);
    export  typedef bool(__stdcall* format_date_callback_w)(wchar_t*);
    export  typedef bool(__stdcall* format_date_callback)(character*);

    export  typedef bool(__stdcall* format_date_extended_callback_a)(char*, calendar_identity);
    export  typedef bool(__stdcall* format_date_extended_callback_w)(wchar_t*, calendar_identity);
    export  typedef bool(__stdcall* format_date_extended_callback)(character*, calendar_identity);

    export  typedef bool(__stdcall* time_format_callback_a)(char*);
    export  typedef bool(__stdcall* time_format_callback_w)(wchar_t*);
    export  typedef bool(__stdcall* time_format_callback)(character*);

    export  typedef bool(__stdcall* calendar_information_callback_a)(char*);
    export  typedef bool(__stdcall* calendar_information_callback_w)(wchar_t*);
    export  typedef bool(__stdcall* calendar_information_callback)(character*);

    export  typedef bool(__stdcall* calendar_information_extended_callback_a)(char*, calendar_identity);
    export  typedef bool(__stdcall* calendar_information_extended_callback_w)(wchar_t*, calendar_identity);
    export  typedef bool(__stdcall* calendar_information_extended_callback)(character*, calendar_identity);

    export struct time_difference
    {
        part hour;         // range: 0 - 23
        part minute;       // range: 0 - 59
        part second;       // range: 0 - 59
        part millisecond;  // range: 0 - 99
        part day;          // days difference
    };

    export struct date_time
    {
        part date;
        part time;
    };

    export struct file_time
    {
        uint low;
        uint high;
    };

    export struct time_zone
    {
        enum
        {
            unknown = 0,
            standard = 1,
            daylight = 2,
            invalid = 0xffffffff,
        };
    };

    export struct time_zone_information
    {
        int bias;
        wchar_t standard_name[32];
        system_time standard_date;
        int standard_bias;
        wchar_t daylight_name[32];
        system_time daylight_date;
        int daylight_bias;
    };

    export struct fixed
    {
        enum { unity = 1 << 16 };
    };

    export struct imatrix
    {
        int a00;
        int a01;
        int a10;
        int a11;
    };

    export struct itransform
    {
        int transform[2][2];
        ipoint translate;

    };

    export typedef uint access_mask;

    export struct access_type
    {
        enum
        {
            _delete = 0x00010000,
            read = 0x00020000,
            write = 0x00040000,
            owner_write = 0x00080000,
            synchronize = 0x00100000,
            standard_required = 0x000f0000,
            standard_read = read,
            standard_write = read,
            standard_execute = read,
            all_standard = 0x001f0000,
            specific = 0x0000ffff,
            system_security = 0x01000000,
            maximum_allowed = 0x02000000,
            generic_read = 0x80000000,
            generic_write = 0x40000000,
            generic_execute = 0x20000000,
            all_generic = 0x10000000
        };
    };

    export struct generic_mask
    {
        uint read;
        uint write;
        uint execute;
        uint all;
    };

    export struct unique
    {
        uint low;
        int high;
    };

    struct unique_attributes : public unique
    {
        unsigned attributes;
    };

    export struct privilege : public unique
    {
        uint attributes;
    };

    export struct privileges
    {
        uint count;

        privilege& operator[] (int index)
        {
            privilege* attribute_array = (privilege*)((uint*)this + 1);
            return attribute_array[index];
        }

        int length() { return sizeof(privileges) + count * sizeof(privilege); }
    };


    export struct privilege_set
    {
        uint count;
        uint control;

        privilege& operator[] (int index)
        {
            privilege* attribute_array = (privilege*)((uint*)this + 2);
            return attribute_array[index];
        }

    };

    export struct authority
    {
        byte array[6];

        enum
        {
            null = 0,
            world = 1,
            local = 2,
            creator = 3,
            nonunique = 4,
            nt = 5,
        };

        authority(byte b0 = 0, byte b1 = 0, byte b2 = 0, byte b3 = 0, byte b4 = 0, byte b5 = 0)
        {
            array[0] = b0;
            array[1] = b1;
            array[2] = b2;
            array[3] = b3;
            array[4] = b4;
            array[5] = b5;
        }
    };

    export struct relative_identity
    {
        enum
        {
            null = 0,
            world = 0,
            local = 0,
            creator_owner = 0,
            creator_group = 1,
            creator_owner_server = 2,
            creator_group_server = 3
        };
    };

    export struct relative_nt
    {
        enum
        {
            dialup = 1,
            network = 2,
            batch = 3,
            logon_identities = 5,
            interactive = 4,
            service = 6,
            anonymous_logon = 7,
            proxy = 8,
            server_logon = 9,
            principal_self = 0xa,
            authenticated_user = 0xb,
            restrictedcode = 0xc,
            local_system = 0x12,
            nonunique = 0x15,
            builtin_domain = 0x20
        };
    };

    export struct relative_domain
    {
        enum
        {
            user_administrator = 0x01f4,
            user_guest = 0x01f5,
            user_krbtgt = 0x01f6,
            group_administrators = 0x0200,
            group_users = 0x0201,
            group_guests = 0x0202,
            computers = 0x0203,
            controllers = 0x0204,
            certificate_administrators = 0x0205,
            scheme_administrators = 0x0206,
            alias_administrators = 0x0220,
            alias_users = 0x0221,
            alias_guests = 0x0222,
            alias_power_users = 0x0223,
            alias_account_operations = 0x0224,
            alias_system_operations = 0x0225,
            alias_print_operations = 0x0226,
            alias_backup_operations = 0x0227,
            alias_replicator = 0x0228
        };
    };

    export  authority authority_null(0, 0, 0, 0, 0, authority::null);
    export  authority authority_world(0, 0, 0, 0, 0, authority::world);
    export  authority authority_local(0, 0, 0, 0, 0, authority::local);
    export  authority authority_creator(0, 0, 0, 0, 0, authority::creator);
    export  authority authority_nonunique(0, 0, 0, 0, 0, authority::nonunique);
    export  authority authority_nt(0, 0, 0, 0, 0, authority::nt);

    export struct account_type
    {
        enum
        {
            user = 1,
            group,
            domain,
            alias,
            well_known_group,
            deleted,
            invalid,
            unknown,
            computer
        };
    };

    export struct identity
    {
        byte revision;
        byte subauthorities;
        authority identity_authority;
        uint array[15];

        identity(const authority& a,
            byte subauth,
            uint a0 = 0,
            uint a1 = 0,
            uint a2 = 0,
            uint a3 = 0,
            uint a4 = 0,
            uint a5 = 0,
            uint a6 = 0,
            uint a7 = 0,
            uint a8 = 0,
            uint a9 = 0,
            uint a10 = 0,
            uint a11 = 0,
            uint a12 = 0,
            uint a13 = 0,
            uint a14 = 0)
        {
            revision = identity_revision;
            subauthorities = subauth;
            identity_authority = a;
            array[0] = a0;
            array[1] = a1;
            array[2] = a2;
            array[3] = a3;
            array[4] = a4;
            array[5] = a5;
            array[6] = a6;
            array[7] = a7;
            array[8] = a8;
            array[9] = a9;
            array[10] = a10;
            array[11] = a11;
            array[12] = a12;
            array[13] = a13;
            array[14] = a14;

        }

        enum { identity_revision = 1, maximum_subauthorities = 15 };
    };

    export  identity identity_null(authority_null, 1, 0);
    export  identity identity_world(authority_world, 1, 0);
    export  identity identity_local(authority_local, 1, 0);
    export  identity identity_creator_owner(authority_creator, 1, 0);
    export  identity identity_creator_group(authority_creator, 1, 1);

    export  identity identity_creator_owner_server(authority_creator, 1, 2);
    export  identity identity_creator_group_server(authority_creator, 1, 3);

    export  identity identity_dialup(authority_nt, 1, 0x1);
    export  identity identity_network(authority_nt, 1, 0x2);
    export  identity identity_batch(authority_nt, 1, 0x3);
    export  identity identity_logon(authority_nt, 3, 0x5);
    export  identity identity_interactive(authority_nt, 1, 0x4);
    export  identity identity_service(authority_nt, 1, 0x6);
    export  identity identity_anonymous_logon(authority_nt, 1, 0x7);
    export  identity identity_proxy(authority_nt, 1, 0x8);
    export  identity identity_server_logon(authority_nt, 1, 0x9);
    export  identity identity_local_system(authority_nt, 1, 0x12);
    export  identity identity_builtin_domain(authority_nt, 1, 0x20);
    export  identity identity_nonunique(authority_nt, 2, 0x15);
    export  identity identity_group_adminstrators(authority_nt, 2, 0x15, 0x200);
    export  identity identity_group_users(authority_nt, 2, 0x15, 0x201);
    export  identity identity_group_guests(authority_nt, 2, 0x15, 0x202);
    export  identity identity_alias_administrators(authority_nt, 2, 0x20, 0x220);
    export  identity identity_alias_users(authority_nt, 2, 0x20, 0x221);
    export  identity identity_alias_guests(authority_nt, 2, 0x20, 0x222);
    export  identity identity_alias_power_users(authority_nt, 2, 0x20, 0x223);
    export  identity identity_alias_account_operations(authority_nt, 2, 0x20, 0x224);
    export  identity identity_alias_system_operations(authority_nt, 2, 0x20, 0x225);
    export  identity identity_alias_print_operations(authority_nt, 2, 0x20, 0x226);
    export  identity identity_alias_backup_operations(authority_nt, 2, 0x20, 0x227);
    export  identity identity_alias_replicator(authority_nt, 2, 0x20, 0x228);

    export struct identity_attributes
    {
        identity* identity;
        uint attributes;
    };

    export struct token_user
    {
        identity_attributes user;
    };

    export struct access_entry
    {
        enum access_type
        {
            access_allowed = 0x0,
            access_denied = 0x1,
            system_audit = 0x2,
            system_alarm = 0x3,
            access_allowed_compound = 0x4,
            access_allowed_object = 0x5,
            access_denied_object = 0x6,
            system_audit_object = 0x7,
            system_alarm_object = 0x8
        };

        enum access_flags
        {
            inherit_object = 0x01,
            inherit_container = 0x02,
            inherit_no_propagate = 0x04,
            inherit_access_entry = 0x08,
            inherit_flags = 0x0f,
            access_successful = 0x40,
            access_failed = 0x80
        };

        byte type;
        byte flags;
        part size;
    };

    export struct access_allowed : public access_entry
    {
        uint mask;
        identity identity;
    };

    export struct access_denied : public access_entry
    {
        uint mask;
        identity identity;
    };

    export struct system_audit : public access_entry
    {
        uint mask;
        identity identity;
    };

    export struct system_alarm : public access_entry
    {
        uint mask;
        identity identity;
    };

    export  enum { access_revision = 3 };

    export struct global
    {
        uint data1;
        ushort data2;
        ushort data3;
        byte data4[8];
    };

    export struct object_present
    {
        enum
        {
            type = 0x1,
            inherit = 0x2
        };
    };

    export struct access_allowed_object : public access_entry
    {
        uint mask;
        uint present;
        global global_value;
        global inherit;
        identity identity;
    };

    export struct access_denied_object : public access_entry
    {
        uint mask;
        uint present;
        global global_value;
        global inherit;
        identity identity;
    };

    export struct access_audit_object : public access_entry
    {
        uint mask;
        uint present;
        global global_value;
        global inherit;
        identity identity;
    };

    export struct access_alarm_object : public access_entry
    {
        uint mask;
        uint present;
        global global_value;
        global inherit;
        identity identity;
    };

    export struct access_list_information
    {
        enum
        {
            revision = 1,
            size
        };
    };

    export struct access_list_size
    {
        uint count;
        uint used;
        uint free;
    };

    export struct access_list_revision
    {
        uint revision;
    };

    export struct access_list
    {
        byte revision;
        byte zero_byte;
        part size;
        part count;
        part zero_part;
    };

    export struct privilege_control { enum { all_necessary = 1 }; };

    export struct privilege_attribute
    {
        enum
        {
            enabled_by_default = 0x00000001,
            enabled = 0x00000002,
            accessed = 0x80000000
        };
    };

    export struct token_groups
    {
        uint count;
        identity_attributes groups[1];

        identity_attributes& operator[](int index) { return groups[index]; }
    };

    export struct token_privileges
    {
        uint count;
        privilege array[1];
    };

    export struct token_owner
    {
        identity* owner;
    };

    export struct token_origin
    {
        uint originating_logon_session;
    };

    export struct token_primary_group
    {
        identity* group;
    };

    export struct token_default_access
    {
        access_list* discretionary;
    };

    export template<class character>
        struct token_source
    {
        enum { length = 8 };

        character name[length];
        unique source;
    };

    export template<class character>
        struct token_control
    {
        unique token;
        unique authentication;
        unique modified;
        token_source<character> control;
    };

    export struct identity_attributes_hash
    {
        uint identity_count;
        identity_attributes* attributes;
        long long hash[32];
    };

    export  enum security_impersonation_level
    {
        anonymous,
        identification,
        impersonation,
        delegation
    };

    export struct token_mandatory_policy
    {
        uint policy;
    };

    export struct token_mandatory_label
    {
        identity_attributes label;
    };

    export struct token_application_container
    {
        identity* container;
    };

    export struct fqbn
    {
        ulong version;
        character* name;
    };

    export struct octet
    {
        void* value;
        uint length;
    };

    export struct claim
    {
        wchar_t* name;
        short  type;
        short  reserved;
        short flags;
        uint count;
        union
        {
            long long* longs;
            ulong* ulongs;
            wchar_t** strings;
            fqbn* fqbn;
            octet* octet;
        } values;
    };

    export struct claims
    {
        ushort  version;
        ushort  reserved;
        uint count;
        claim* array;
    };

    export struct token_type { enum { primary = 1, impersonation }; };

    export struct token_access_information
    {
        identity_attributes_hash* identity_hash;
        identity_attributes_hash* restricted_identity_hash;
        token_privileges* privileges;
        long long authentication_identity;
        uint token_type;
        security_impersonation_level impersonation_level;
        token_mandatory_policy mandatory_policy;
        uint flags;
        uint application_container_number;
        identity* package_identity;
        identity_attributes_hash* capabilities_hash;
        identity* trust_level_identity;
        long long security_attributes;
    };

    export struct token_access
    {
        enum
        {
            assign_primary = 0x0001,
            duplicate = 0x0002,
            impersonate = 0x0004,
            query = 0x0008,
            query_source = 0x0010,
            adjust_privileges = 0x0020,
            adjust_groups = 0x0040,
            adjust_default = 0x0080,
            adjust_session = 0x0100,
            all = 0x00ff,
            execute = access_type::standard_execute,
            read = access_type::standard_read | query,
            write = access_type::standard_write | adjust_privileges | adjust_groups | adjust_default
        };
    };

    export struct token_level
    {
        enum
        {
            anonymous,
            identification,
            impersonation,
            delegation
        };
    };

    export struct group_attribute
    {
        enum
        {
            mandatory = 0x00000001,
            enabled_by_default = 0x00000002,
            enabled = 0x00000004,
            owner = 0x00000008,
            use_for_deny_only = 0x00000010,
            logon_identity = 0xc0000000
        };
    };

    export struct token_class
    {
        enum
        {
            user = 1,
            groups,
            privileges,
            owner,
            primary_group,
            _default,
            source,
            type,
            level,
            statistics,
            restricted_identities,
            session_identity
        };
    };

    export struct token_statistics
    {
        long long token;
        long long authority;
        ulong expire;
        uint statistics;
        uint level;
        uint charged;
        uint available;
        uint group_count;
        uint privilege_count;
        long long modified;
    };

    export struct token_groups_and_privileges
    {
        uint identity_count;
        uint identity_length;
        identity_attributes* identities;
        uint restricted_identity_count;
        uint restricted_identity_length;
        identity_attributes* restricted_identities;
        uint privilege_count;
        uint privilege_length;
        privilege* privileges;
        long authentication_identity;
    };

    export struct descriptor_control
    {
        enum
        {
            owner_defaulted = 0x0001,
            group_defaulted = 0x0002,
            discretionary_present = 0x0004,
            discretionary_defaulted = 0x0008,
            system_present = 0x0010,
            system_defaulted = 0x0020,
            discretionary_auto_inherit_required = 0x0100,
            system_auto_inherit_required = 0x0200,
            discretionary_auto_inherited = 0x0400,
            system_auto_inherited = 0x0800,
            discretionary_protected = 0x1000,
            system_protected = 0x2000,
            self_relative = 0x8000
        };
    };

    export struct security_information
    {
        enum
        {
            owner = 0x00000001,
            group = 0x00000002,
            discretionary = 0x00000004,
            system = 0x00000008
        };
    };

    export  enum { descriptor_minimum_size = 20 };

    export  typedef handle descriptor;

    export struct security_attributes
    {
        uint length;
        descriptor* descriptor;
        bool inherit;

        security_attributes() : length(sizeof(security_attributes)), descriptor(0), inherit(false) {}
    };

    export struct logon_length
    {
        enum
        {
            user_name_maximum = 256,
            password_maximum = 256
        };
    };

    export  enum { computer_name_maximum = 31 };

    export struct computer_name_format
    {
        enum
        {
            net_bios,
            dns_host_name,
            dns_domain,
            dns_fully_qualified,
            physical_net_bios,
            physical_dns_host_name,
            physical_dns_domain,
            physical_dns_fully_qualified,
        };
    };

    export struct logon_type
    {
        enum
        {
            interactive = 2,
            network = 3,
            batch = 4,
            service = 5
        };
    };

    export struct logon_providor
    {
        enum
        {
            _default = 0,
            windows_nt35 = 1,
            windows_nt40 = 2,
            windows_nt50 = 3,
        };
    };

    export  enum {
        delete_maximum_privileges = 0x0001,
        disable_maximum_identities = 0x0002
    };

    export  enum { error_handle_instance = 32 };
    export  enum { time_size_identity_invalid = 0xffffffff };

    export struct status
    {
        enum
        {
            wait0 = 0x00000000,
            wait_abandoned0 = 0x00000080,
            user_apc = 0x000000c0,
            timeout = 0x00000102,
            pending = 0x00000103,
            segment_notification = 0x40000005,
            guard_page_violation = 0x80000001,
            datatype_misalignment = 0x80000002,
            breakipoint = 0x80000003,
            single_step = 0x80000004,
            access_violation = 0xc0000005,
            in_page_error = 0xc0000006,
            handle_invalid = 0xc0000008,
            no_memory = 0xc0000017,
            illegal_instruction = 0xc000001d,
            noncontinuable_exception = 0xc0000025,
            invalid_disposition = 0xc0000026,
            array_bounds_exceeded = 0xc000008c,
            decimal_denormal_operand = 0xc000008d,
            decimal_divide_by_zero = 0xc000008e,
            decimal_inexact_result = 0xc000008f,
            decimal_invalid_operation = 0xc0000090,
            decimal_overflow = 0xc0000091,
            decimal_stack_check = 0xc0000092,
            decimal_underflow = 0xc0000093,
            integer_divide_by_zero = 0xc0000094,
            integer_overflow = 0xc0000095,
            privileged_instruction = 0xc0000096,
            stack_overflow = 0xc00000fd,
            control_c_exit = 0xc000013a,
            decimal_multiple_faults = 0xc00002b4,
            decimal_multiple_traps = 0xc00002b5,
            illegal_vlm_reference = 0xc00002c0
        };
    };

    export struct tape
    {
        enum { media = 0, drive = 1 };
    };

    export struct format_message_flag
    {
        enum
        {
            allocate_buffer = 0x00000100,
            ignore_inserts = 0x00000200,
            from_string = 0x00000400,
            from_module = 0x00000800,
            from_system = 0x00001000,
            parameter_array = 0x00002000,
            maximum_width = 0x000000ff
        };
    };

    export struct open_flag
    {
        enum
        {
            read = 0x00000000,
            write = 0x00000001,
            read_write = 0x00000002,
            share_compatible = 0x00000000,
            share_exclusive = 0x00000010,
            share_deny_write = 0x00000020,
            share_deny_read = 0x00000030,
            share_deny_none = 0x00000040,
            flag_parse = 0x00000100,
            _delete = 0x00000200,
            verify = 0x00000400,
            cancel = 0x00000800,
            create = 0x00001000,
            prompt = 0x00002000,
            exist = 0x00004000,
            reopen = 0x00008000
        };
    };

    export  enum { thread_local_storage_out_ofindices = 0xffffffff };

    export struct memory_flag
    {
        enum
        {
            access_none = 0x00000001,  // access flags
            read_only = 0x00000002,
            read_write = 0x00000004,
            write_copy = 0x00000008,
            execute = 0x00000010,
            execute_read = 0x00000020,
            execute_read_write = 0x00000040,
            execute_write_copy = 0x00000080,
            guard = 0x00000100,
            no_cache = 0x00000200,
            write_combine = 0x00000400,
            commit = 0x00001000,  // allocation flags
            reserve = 0x00002000,
            decommit = 0x00004000,
            release = 0x00008000,
            free = 0x00010000,
            _private = 0x00020000,
            mapped = 0x00040000,
            reset = 0x00080000,
            top_down = 0x00100000,
            write_watch = 0x00200000,
            physical = 0x00400000,
            rotate = 0x00800000,
            image = 0x01000000,
            four_megabyte_pages = 0x80000000,
            section_file = 0x800000,
            section_image = 0x1000000,
            section_vlm = 0x2000000,
            section_reserve = 0x4000000,
            section_commit = 0x8000000,
            section_no_cache = 0x10000000,
            write_watch_flag_reset = 0x01
        };
    };

    export struct section_access
    {
        enum
        {
            query = 0x0001,
            write = 0x0002,
            read = 0x0004,
            execute = 0x0008,
            extend = 0x0010,
            all = access_type::standard_required | query | write | read | execute | extend
        };
    };

    export struct memory_information
    {
        void* address;
        void* allocation;
        uint initial_protection;
        ulong region_size;
        uint state;
        uint protection;
        uint type;
    };

    export struct local_memory_flag
    {
        enum
        {
            fixed = 0x0000,
            moveable = 0x0002,
            no_compact = 0x0010,
            no_discard = 0x0020,
            zero_initialize = 0x0040,
            modify = 0x0080,
            discardable = 0x0f00,
            valid_flags = 0x0f72,
            handle_invalid = 0x8000
        };
    };

    export struct resource_information;

    export struct global_memory_flag
    {
        enum
        {
            fixed = 0x0000,
            moveable = 0x0002,
            no_compact = 0x0010,
            no_discard = 0x0020,
            zero_initialize = 0x0040,
            modify = 0x0080,
            discardable = 0x0100,
            share = 0x2000,
            notify = 0x4000,
            valid_flags = 0x7f72,
            handle_invalid = 0x8000
        };
    };

    export struct memory_status
    {
        uint size;
        uint memory_load;
        ulong physical_total;
        ulong physical_available;
        ulong page_file_total;
        ulong page_file_available;
        ulong virtual_total;
        ulong virtual_available;
    };

    export struct extended_memory_status
    {
        uint size;
        uint memory_load;
        ulong physical_total;
        ulong physical_available;
        ulong page_file_total;
        ulong page_file_available;
        ulong virtual_total;
        ulong virtual_available;
        ulong extended_virtual_available;
    };

    export  typedef bool(__stdcall* resource_type_callback)(handle module,
        character* type,
        void* parameter);

    export  typedef bool(__stdcall* resource_name_callback)(handle module,
        character* type,
        character* name,
        void* parameter);

    export  typedef bool(__stdcall* resource_language_callback)(handle module,
        character* type,
        character* name,
        part language,
        void* parameter);

    export struct library_load_flag
    {
        enum
        {
            none = 0,
            no_resolve_references = 0x00000001,
            load_as_datafile = 0x00000002,
            alternate_search_path = 0x00000008
        };
    };

    export struct resource_type
    {
        enum
        {
            cursor = 1,
            bitmap = 2,
            icon = 3,
            menu = 4,
            dialog = 5,
            string = 6,
            font_directory = 7,
            font = 8,
            accelerator = 9,
            data = 10,
            message_table = 11,
            difference = 11,
            cursor_group = cursor + difference,
            icon_group = icon + difference,
            version = 16,
            dialog_include = 17,
            plug_play = 19,
            vxd = 20,
            animated_cursor = 21,
            animated_icon = 22,
            html = 23
        };
    };

    export  enum { invalid_handle_value = -1, infinite = 0xffffffff };

    export struct overlapped
    {
        ulong internal;
        ulong offset;
        handle event;
    };

    export  typedef void(__stdcall* overlapped_completion)(uint error,
        uint transferred,
        overlapped* completion);

    export struct file_access_rights
    {
        enum
        {
            any = 0x0000, // access rights for files
            read = 0x0001,
            write = 0x0002,
            append = 0x0004,
            read_extended_attributes = 0x0008,
            write_extended_attributes = 0x0010,
            execute = 0x0020,
            directory_list = 0x0001, // access rights for directories
            directory_add_file = 0x0002,
            directory_add_subdirectory = 0x0004,
            directory_read_extended_attributes = 0x0008,
            directory_write_extended_attributes = 0x0010,
            directory_traverse = 0x0020,
            directory_delete_child = 0x0040,
            create_pipe_instance = 0x0004, // named pipe specifics
            read_attributes = 0x0080, // applicable to all file types
            write_attributes = 0x0100,
            all_file = access_type::standard_required | access_type::synchronize | 0x1ff
        };
    };

    export struct file_access
    {
        enum
        {
            none = 0,

            read = access_type::standard_read |
            access_type::synchronize |
            file_access_rights::read_attributes |
            file_access_rights::read |
            file_access_rights::read_extended_attributes,

            write = access_type::standard_write |
            access_type::synchronize |
            file_access_rights::write_attributes |
            file_access_rights::write |
            file_access_rights::append |
            file_access_rights::write_extended_attributes,

            execute = access_type::standard_read |
            access_type::synchronize |
            file_access_rights::read_attributes |
            file_access_rights::execute
        };
    };

    export struct file_security
    {
        enum
        {
            anonymous = token_level::anonymous << 16,
            identification = token_level::identification << 16,
            impersonation = token_level::impersonation << 16,
            delegation = token_level::delegation << 16,
            context_tracking = 0x00040000,
            effective_only = 0x00080000,
            present = 0x00100000
        };
    };

    export struct file_action
    {
        enum
        {
            create_new = 1,
            always_create,
            open_existing,
            always_open,
            truncate_existing
        };
    };

    export struct share_file
    {
        enum
        {
            none = 0x0000,
            read = 0x0001,
            write = 0x0002,
            _delete = 0x0004
        };
    };

    export struct file_attribute
    {
        enum
        {
            readonly = 0x00000001,
            hidden = 0x00000002,
            system = 0x00000004,
            directory = 0x00000010,
            archive = 0x00000020,
            encrypted = 0x00000040,
            normal = 0x00000080,
            temporary = 0x00000100,
            sparse = 0x00000200,
            reparse_point = 0x00000400,
            compressed = 0x00000800,
            offline = 0x00001000,
            not_indexed = 0x00002000
        };
    };

    export struct file_flag
    {
        enum
        {
            write_through_file = 0x80000000,
            overlapped_file = 0x40000000,
            no_file_buffering = 0x20000000,
            random_file = 0x10000000,
            sequential_file = 0x08000000,
            delete_file_on_close = 0x04000000,
            file_backup_semantics = 0x02000000,
            file_posix_semantics = 0x01000000,
            open_file_reparse_point = 0x00200000,
            open_file_no_recall = 0x00100000
        };
    };

    export struct duplicate_file
    {
        enum
        {
            close_source_file = 1,
            file_access_same = 2
        };
    };

    export struct file_position
    {
        enum
        {
            at_beginning = 0x0000,
            current_position = 0x0001,
            at_end = 0x0002
        };
    };

    export struct file_type
    {
        enum
        {
            unknown = 0x0000,
            disk = 0x0001,
            character = 0x0002,
            pipe = 0x0003,
            remote = 0x8000
        };
    };

    export struct lock_flag
    {
        enum
        {
            return_immediately = 0x0001,
            exclusive = 0x0002
        };
    };

    export struct standard_handle
    {
        enum
        {
            input = -10,
            output = -11,
            error = -12
        };
    };

    export struct stream_identity
    {
        uint identity;
        uint attributes;
        ulong size;
        uint name_size;
        wchar_t name[1];
    };

    export struct stream_identities
    {
        enum
        {
            invalid = 0,
            data = 1,
            data_extended_attribute = 2,
            data_security = 3,
            data_alternate = 4,
            link = 5,
            data_property = 6,
            object = 7,
            data_reparse = 8,
            sparse_block = 9
        };
    };

    export struct stream_attribute
    {
        enum
        {
            normal = 0x00000000,
            modified_when_read = 0x00000001,
            contains_security = 0x00000002,
            contains_properties = 0x00000004,
            sparse = 0x00000008
        };
    };

    export struct file_information
    {
        uint attributes;
        file_time create;
        file_time access;
        file_time write;
        uint volume;
        uint size_high;
        uint size_low;
        uint links;
        uint index_high;
        uint index_low;
    };

    export template<class character>
        struct find_data
    {
        uint attributes;
        file_time create;
        file_time access;
        file_time write;
        uint size_high;
        uint size_low;
        uint reserved1;
        uint reserved2;
        character file_name[path_length::maximum];
        character alternate[14];
    };

    export struct find_file_level { enum { standard }; };

    export struct find_file_option
    {
        enum
        {
            match_file_name,
            limit_to_directories,
            limit_to_devices
        };
    };

    export struct find_file_flag
    {
        enum
        {
            case_sensitive = 0x0001
        };
    };

    export struct file_attribute_level { enum { standard }; };

    export struct file_attribute_data
    {
        uint attributes;
        file_time create;
        file_time access;
        file_time write;
        uint size_high;
        uint size_low;
    };

    export struct progress_reason
    {
        enum
        {
            progress_section_finished = 0x0000,
            progress_stream_switch = 0x0001
        };
    };

    export struct progress_action
    {
        enum
        {
            _continue = 0,
            cancel = 1,
            stop = 2,
            quiet = 3
        };
    };

    export  typedef uint(__stdcall* progress)(long file_size,
        long transferred,
        long stream_ssize,
        long stream_transferred,
        uint stream,
        uint reason,
        handle source,
        handle destination,
        void* data);

    export struct copy_file_option
    {
        enum
        {
            fail_if_exists = 0x00000001,
            restartable = 0x00000002,
            open_source_for_write = 0x00000004
        };
    };

    export struct move_file_option
    {
        enum
        {
            replace_existing = 0x00000001,
            copy_allowed = 0x00000002,
            delay_until_reboot = 0x00000004,
            write_through = 0x00000008,
            hard_link_create = 0x00000010,
            fail_if_not_trackable = 0x00000020
        };
    };

    export struct drive_type
    {
        enum
        {
            unknown = 0,
            no_root_directory = 1,
            removable = 2,
            fixed = 3,
            remote = 4,
            compact_disk = 5,
            memory_disk = 6
        };
    };

    export struct binary_type
    {
        enum
        {
            none = -1,
            windows = 0,
            dos = 1,
            windows16 = 2,
            pif = 3,
            posix = 4,
            os2 = 5
        };
    };

    export  enum inherit_handle_flag
    {
        inherit_handle = 0x00000001,
        protect_from_close_handle = 0x00000002
    };

    export struct change_notify
    {
        enum
        {
            file_name = 0x0001,
            directory_name = 0x0002,
            attributes = 0x0004,
            size = 0x0008,
            last_write = 0x0010,
            last_access = 0x0020,
            creation = 0x0040,
            security = 0x0100
        };
    };

    export struct change_result
    {
        enum
        {
            file_added = 0x0001,
            file_removed = 0x0002,
            file_modified = 0x0003,
            file_renamed_old = 0x0004,
            file_renamed_new = 0x0005
        };
    };

    export struct mailslot
    {
        enum
        {
            no_message = -1,
            wait_forever = -1
        };
    };

    export struct device_flag
    {
        enum
        {
            raw_target_path = 0x0001,
            remove_definition = 0x0002,
            exact_match_on_remove = 0x0004,
            no_broadcast_system = 0x0008
        };
    };

    export struct get_tape_information
    {
        enum
        {
            media_information = 0,
            drive_parameters = 1
        };
    };

    export struct set_tape_information
    {
        enum
        {
            media_information = 0,
            drive_parameters = 1
        };
    };

    export struct file_notify_information
    {
        uint next;
        uint action;
        uint length;
        wchar_t file_name[1];
    };

    export struct file_mapping_access
    {
        enum
        {
            copy = section_access::query,
            write = section_access::write,
            read = section_access::read,
            all = section_access::all
        };
    };

    export struct pipe_access
    {
        enum
        {
            inbound = 0x00000001,
            outbound = 0x00000002,
            duplex = 0x00000003
        };
    };

    export struct pipe_end
    {
        enum
        {
            client = 0x00000000,
            server = 0x00000001
        };
    };

    export struct pipe_mode
    {
        enum
        {
            no_wait = 0x0001,
            wait = 0x0000,
            wait_forever = 0xffffffff,
            byte_read = 0x0000,
            message_read = 0x0002,
            byte_write = 0x0000,
            message_write = 0x0004,
            no_instance_limit = 0x00ff
        };
    };

    export struct pipe_attribute_type
    {
        enum
        {
            attribute,
            connection_attribute,
            handle_attribute
        };
    };

    export struct process_information
    {
        handle process;
        handle thread;
        uint process_identity;
        uint thread_identity;
    };

    export struct start_flag
    {
        enum
        {
            show_window = 0x0001,
            size = 0x0002,
            position = 0x0004,
            count_characters = 0x0008,
            fill_attribute = 0x0010,
            full_screen = 0x0020,
            force_feed_back_on = 0x0040,
            force_feed_back_off = 0x0080,
            standard_handles = 0x0100,
            hotkey_use = 0x0200
        };
    };

    export template<class character>
        struct start_information
    {
        uint size;
        character* reserved1;
        character* desktop;
        character* title;
        uint x;
        uint y;
        uint x_size;
        uint y_size;
        uint x_characters;
        uint y_characters;
        uint fill_attribute;
        uint flags;
        part show_window;
        part reserved2;
        byte* reserved3;
        handle standard_input;
        handle standard_output;
        handle standard_error;
    };

    export struct process_access
    {
        enum
        {
            terminate = 0x0001,
            create_thread = 0x0002,
            set_session_identity = 0x0004,
            virtual_machine_operation = 0x0008,
            read_virtual_machine = 0x0010,
            write_virtual_machine = 0x0020,
            duplicate_handle = 0x0040,
            create_process = 0x0080,
            set_quota = 0x0100,
            set_information = 0x0200,
            get_information = 0x0400,
            all = access_type::standard_required | access_type::synchronize | 0xfff
        };
    };

    export struct priority_class
    {
        enum
        {
            normal = 0x00000020,
            idle = 0x00000040,
            high = 0x00000080,
            real_time = 0x00000100
        };
    };

    export struct process_create
    {
        enum
        {
            debug = 0x00000001,
            debug_this_only = 0x00000002,
            suspended = 0x00000004,
            detached = 0x00000008,
            new_console = 0x00000010,
            new_group = 0x00000200,
            unicode_environment = 0x00000400,
            separate_virtual_machine = 0x00000800,
            shared_virtual_machine = 0x00001000,
            force_dos = 0x00002000,
            error_mode_default = 0x04000000,
            no_window = 0x08000000,
            user_profile = 0x10000000,
            kernel_profile = 0x20000000,
            server_profile = 0x40000000
        };
    };

    export struct _resources
    {
        enum
        {
            count_device_objects = 0,
            count_user_objects = 1
        };
    };

    export  enum { shutdown_no_retry = 0x0001 };

    export  typedef uint(__stdcall* thread_function)(void* parameters);

    export  typedef void(__stdcall* fiber_function)(void* parameter);

    export  typedef void(__stdcall* asynchronous_procedure)(void* parameter);

    export struct context
    {
        enum
        {
            context_portable_32_bit = 0x00100000,
            context_alpha = 0x00020000,
            context_control = context_alpha | 0x00000001,
            context_floating_point = context_alpha | 0x00000002,
            context_integer = context_alpha | 0x00000004,
            context_full = context_control | context_floating_point | context_integer
        };

        double double0;
        double double1;
        double double2;
        double double3;
        double double4;
        double double5;
        double double6;
        double double7;
        double double8;
        double double9;
        double double10;
        double double11;
        double double12;
        double double13;
        double double14;
        double double15;
        double double16;
        double double17;
        double double18;
        double double19;
        double double20;
        double double21;
        double double22;
        double double23;
        double double24;
        double double25;
        double double26;
        double double27;
        double double28;
        double double29;
        double double30;
        double double31;

        double interrupt_v0;
        double interrupt_t0;
        double interrupt_t1;
        double interrupt_t2;
        double interrupt_t3;
        double interrupt_t4;
        double interrupt_t5;
        double interrupt_t6;
        double interrupt_t7;
        double interrupt_s0;
        double interrupt_s1;
        double interrupt_s2;
        double interrupt_s3;
        double interrupt_s4;
        double interrupt_s5;
        double interrupt_fp;
        double interrupt_a0;
        double interrupt_a1;
        double interrupt_a2;
        double interrupt_a3;
        double interrupt_a4;
        double interrupt_a5;
        double interrupt_t8;
        double interrupt_t9;
        double interrupt_t10;
        double interrupt_t11;
        double interrupt_ra;
        double interrupt_t12;
        double interruptat;
        double interrupt_gp;
        double interrupt_sp;
        double interrupt_zero;

        double control;
        double soft;

        double fault;
        uint status;

        uint flags;
        uint filler[4];
    };

    export struct thread_descriptor
    {
        part limit_low;
        part base_low;
        uint base_middle : 8;
        uint type : 5;
        uint descriptor : 2;
        uint present : 1;
        uint limit_high : 4;
        uint system : 1;
        uint reserved : 1;
        uint default_big : 1;
        uint granularity : 1;
        uint base_high : 8;
    };

    export struct thread_access
    {
        enum
        {
            terminate = 0x0001,
            suspend_resume = 0x0002,
            get_context = 0x0008,
            set_context = 0x0010,
            set_information = 0x0020,
            query_information = 0x0040,
            set_token = 0x0080,
            impersonate = 0x0100,
            impersonate_direct = 0x0200,
            all = access_type::standard_required | access_type::synchronize
        };
    };

    export struct thread_create
    {
        enum
        {
            suspended = 0x00000004
        };
    };

    export struct thread_priority
    {
        enum
        {
            lowest = -2,
            low = -1,
            normal = 0,
            high = 1,
            highest = 2,
            time_critical = 15,
            idle = -15,
            error = 0x80000000
        };
    };

    export  enum { maximum_suspend = 0x7f };

    export  enum { thread_local_storage_minimum_available = 64 };

    export struct fiber_flag { enum { float_switch = 0x1 }; };

    export struct system_exception
    {
        enum
        {
            access_violation = status::access_violation,
            datatype_misalignment = status::datatype_misalignment,
            break_point = status::breakipoint,
            single_step = status::single_step,
            array_bounds_exceeded = status::array_bounds_exceeded,
            decimal_denormal_operand = status::decimal_denormal_operand,
            decimal_divide_by_zero = status::decimal_divide_by_zero,
            decimal_inexact_result = status::decimal_inexact_result,
            decimal_invalid_operation = status::decimal_invalid_operation,
            decimal_overflow = status::decimal_overflow,
            decimal_stack_check = status::decimal_stack_check,
            decimal_underflow = status::decimal_underflow,
            integer_divide_by_zero = status::integer_divide_by_zero,
            integer_overflow = status::integer_overflow,
            privileged_instruction = status::privileged_instruction,
            in_page_error = status::in_page_error,
            illegal_instruction = status::illegal_instruction,
            non_continuable = status::noncontinuable_exception,
            stack_overflow = status::stack_overflow,
            invalid_disposition = status::invalid_disposition,
            guard_page = status::guard_page_violation,
            handle_invalid = status::handle_invalid,
            control_c_exit = status::control_c_exit
        };
    };

    export struct virtual_key
    {
        enum
        {
            left_button = 0x01,
            right_button = 0x02,
            cancel = 0x03,
            middle_button = 0x04,

            back = 0x08,
            tab = 0x09,

            clear = 0x0c,
            _return = 0x0d,

            shift = 0x10,
            control = 0x11,
            menu = 0x12,
            pause = 0x13,
            capital = 0x14,

            kana = 0x15,
            hang_eul = 0x15,
            hang_ul = 0x15,
            junja = 0x17,
            final = 0x18,
            hanja = 0x19,
            kanji = 0x19,

            escape = 0x1b,
            convert = 0x1c,
            non_convert = 0x1d,
            accept = 0x1e,
            mode_change = 0x1f,

            space = 0x20,
            prior = 0x21,
            next = 0x22,
            end = 0x23,
            home = 0x24,
            left = 0x25,
            up = 0x26,
            right = 0x27,
            down = 0x28,
            select = 0x29,
            print = 0x2a,
            execute = 0x2b,
            snap_shot = 0x2c,
            insert = 0x2d,
            _delete = 0x2e,
            help = 0x2f,

            digit0 = 0x30,
            digit1 = 0x31,
            digit2 = 0x32,
            digit3 = 0x33,
            digit4 = 0x34,
            digit5 = 0x35,
            digit6 = 0x36,
            digit7 = 0x37,
            digit8 = 0x38,
            digit9 = 0x39,

            a = 0x41,
            b = 0x42,
            c = 0x43,
            d = 0x44,
            e = 0x45,
            f = 0x46,
            g = 0x47,
            h = 0x48,
            i = 0x49,
            j = 0x4a,
            k = 0x4b,
            l = 0x4c,
            m = 0x4d,
            n = 0x4e,
            o = 0x4f,
            p = 0x50,
            q = 0x51,
            r = 0x52,
            s = 0x53,
            t = 0x54,
            u = 0x55,
            v = 0x56,
            w = 0x57,
            x = 0x58,
            y = 0x59,
            z = 0x5a,

            left_window = 0x5b,
            right_window = 0x5c,
            applications = 0x5d,

            numeric_pad0 = 0x60,
            numeric_pad1 = 0x61,
            numeric_pad2 = 0x62,
            numeric_pad3 = 0x63,
            numeric_pad4 = 0x64,
            numeric_pad5 = 0x65,
            numeric_pad6 = 0x66,
            numeric_pad7 = 0x67,
            numeric_pad8 = 0x68,
            numeric_pad9 = 0x69,
            multiply = 0x6a,
            add = 0x6b,
            separator = 0x6c,
            subtract = 0x6d,
            decimal = 0x6e,
            divide = 0x6f,
            f1 = 0x70,
            f2 = 0x71,
            f3 = 0x72,
            f4 = 0x73,
            f5 = 0x74,
            f6 = 0x75,
            f7 = 0x76,
            f8 = 0x77,
            f9 = 0x78,
            f10 = 0x79,
            f11 = 0x7a,
            f12 = 0x7b,
            f13 = 0x7c,
            f14 = 0x7d,
            f15 = 0x7e,
            f16 = 0x7f,
            f17 = 0x80,
            f18 = 0x81,
            f19 = 0x82,
            f20 = 0x83,
            f21 = 0x84,
            f22 = 0x85,
            f23 = 0x86,
            f24 = 0x87,

            num_lock = 0x90,
            scroll = 0x91,

            left_shift = 0xa0,
            right_shift = 0xa1,
            left_control = 0xa2,
            right_control = 0xa3,
            left_menu = 0xa4,
            right_menu = 0xa5,

            process = 0xe5,

            attention = 0xf6,
            carriage_select = 0xf7,
            extended_select = 0xf8,
            error_end_of_file = 0xf9,
            play = 0xfa,
            zoom = 0xfb,
            no_name = 0xfc,
            pa1 = 0xfd,
            oem_clear = 0xfe
        };
    };

    export struct accelerator_flag
    {
        enum
        {
            virtual_key = 0x01,
            no_invert = 0x02,
            shift = 0x04,
            control = 0x08,
            alt = 0x10,
            last = 0x80
        };
    };

    export struct accelerator_entry
    {
        part flags;
        part key;
        uint command;
    };

    export struct peek
    {
        enum
        {
            no_remove = 0,
            remove = 1,
            no_yield = 2
        };
    };

    export struct window_message
    {
        uint identity;
        parameter parameter1;
        parameter parameter2;
    };

    export struct send_type
    {
        enum
        {
            none = 0x0000,
            send = 0x0001,
            notify = 0x0002,
            callback = 0x0004,
            replied = 0x0008
        };
    };

    export struct queue_status
    {
        enum
        {
            key = 0x001,
            mouse_move = 0x002,
            mouse_button = 0x004,
            post = 0x008,
            timer = 0x010,
            paint = 0x020,
            send = 0x040,
            hotkey = 0x080,
            all_post = 0x100,

            mouse = mouse_move |
            mouse_button,

            input = mouse |
            key,

            all_events = input |
            post |
            timer |
            paint |
            hotkey,

            all_input = send |
            paint |
            timer |
            post |
            mouse_button |
            mouse_move |
            hotkey |
            key
        };
    };

    export  typedef void(__stdcall* timer_procedure)(handle, uint, ulong, uint);

    export struct queue_message
    {
        handle window;
        uint identity;
        parameter parameter1;
        parameter parameter2;
        uint time;
        ipoint position;
    };

    //export extern "C" string services_database_active((const wchar_t*)L"ServicesActive");
    //export extern "C" string services_database_failed((const wchar_t*)L"ServicesFailed");
    //export extern "C" string service_group_identifier((const wchar_t*)L"+");

    export struct enumerate_service_state
    {
        enum
        {
            active = 1,
            inactive = 2,
            all = active | inactive
        };
    };

    export struct service_state
    {
        enum
        {
            stopped,
            pending_start,
            pending_stop,
            running,
            pending_continue,
            pending_pause,
            paused
        };
    };

    export struct service_accept
    {
        enum
        {
            stop = 0x00000001,
            pause_continue = 0x00000002,
            shutdown = 0x00000004,
            parameter_change = 0x00000008,
            net_bind_change = 0x00000010,
            hardware_profile_change = 0x00000020,
            power_event = 0x00000040,
            session_change = 0x00000080
        };
    };

    export struct service_access
    {
        enum
        {
            query_configuration = 0x0001,
            change_configuration = 0x0002,
            query_status = 0x0004,
            enumerate_dependencies = 0x0008,
            start = 0x0010,
            stop = 0x0020,
            pause_continue = 0x0040,
            interrogate = 0x0080,
            user_defined_control = 0x0100,
            all = access_type::standard_required |
            query_configuration |
            change_configuration |
            query_status |
            enumerate_dependencies |
            start |
            stop |
            pause_continue |
            interrogate |
            user_defined_control
        };
    };

    export  enum { service_runs_in_system_process = 0x00000001 };

    export struct service_preferred_node
    {
        ushort preferred_node;
        bool _delete;
    };

    export struct service_status
    {
        uint service_type;
        uint current_state;
        uint controls_accepted;
        uint windows_exit_code;
        uint service_exit_code;
        uint check_point;
        uint wait_hint;
    };

    export struct service_status_process
    {
        uint service_type;
        uint current_state;
        uint controls_accepted;
        uint windows_exit_code;
        uint service_exit_code;
        uint check_point;
        uint wait_hint;
        uint process_identity;
        uint service_flags;
    };

    export template<class character>
        struct enumerate_service_status
    {
        character* service_name;
        character* display_name;
        service_status status;
    };

    export template<class character>
        struct enumerate_service_status_process
    {
        character* service_name;
        character* display_name;
        service_status_process status;
    };

    export template<class character>
        struct service_lock_status
    {
        uint is_locked;
        character* lock_owner;
        uint lock_duration;
    };

    export template<class character>
        struct service_configuration
    {
        uint service_type;
        uint start_type;
        uint error_control;
        character* binary_path_name;
        character* load_order_group;
        uint tag_identity;
        character* dependencies;
        character* service_start_name;
        character* display_name;
    };

    export struct service_configuration_level
    {
        enum
        {
            description = 1,
            failure_actions = 2
        };
    };

    export struct service_action_type
    {
        enum
        {
            none = 0,
            restart = 1,
            reboot = 2,
            run_command = 3
        };
    };

    export struct service_description
    {
        character* description;
    };

    export struct service_action
    {
        uint type;
        uint delay;
    };

    export template<class character>
        struct service_failure_actions
    {
        uint reset_period;
        character* reboot_message;
        character* command;
        uint count;
        service_action* actions;
    };

    export  typedef void(__stdcall* service_procedure)(uint service_parameters,
        character** service_parameter_vectors);

    export template<class character>
        struct service_table_entry
    {
        character* service_name;
        service_procedure service_main;
    };

    export  typedef void(__stdcall* service_handler)(uint control);

    export  typedef uint(__stdcall* service_handler_extended)(uint control,
        uint event_type,
        void* event_data,
        void* context);

    export struct service_manager_access
    {
        enum
        {
            connect = 0x0001,
            create_service = 0x0002,
            enumerate_service = 0x0004,
            lock = 0x0008,
            lock_status = 0x0010,
            boot_configuration = 0x0020,
            all = access_type::standard_required |
            connect |
            create_service |
            enumerate_service |
            lock |
            lock_status |
            boot_configuration
        };
    };

    export struct service_control
    {
        enum
        {
            stop,
            pause,
            _continue,
            interrogate,
            shutdown,
            parameter_change,
            net_bind_add,
            net_bind_remove,
            net_bind_enable,
            net_bind_disable,
            devikeyvent,
            hardware_profile_change,
            power_event,
            session_change
        };
    };

    export  enum { service_no_change = 0xffffffff };

    export struct service_type
    {
        enum
        {
            kernel_driver = 0x00000001,
            file_system_driver = 0x00000002,
            adapter = 0x00000004,
            recognized_driver = 0x00000008,
            driver = kernel_driver | file_system_driver | recognized_driver,
            process_own = 0x00000010,
            process_share = 0x00000020,
            process = process_own | process_share,
            interactive = 0x00000100,
            all = process | adapter | driver | interactive
        };
    };

    export struct service_start
    {
        enum
        {
            boot = 0x00000000,
            system = 0x00000001,
            automatic = 0x00000002,
            demand = 0x00000003,
            disabled = 0x00000004
        };
    };

    export struct service_error
    {
        enum
        {
            ignore = 0x00000000,
            normal = 0x00000001,
            severe = 0x00000002,
            critical = 0x00000003
        };
    };

    export struct service_status_type
    {
        enum
        {
            process_information = 0
        };
    };

    export struct sevice_enumeration_type
    {
        enum
        {
            process_information = 0
        };
    };

    export struct system_information
    {
        part processor_architecture;
        part reserved;
        uint system_page_size;
        void* minimum_address;
        void* maximum_address;
        uint active_processor_mask;
        uint number_of_processors;
        uint processor_type;
        uint allocation_granularity;
        part processor_level;
        part processor_revision;
    };

    export struct processor_architecture
    {
        enum
        {
            intel = 0,
            mips = 1,
            alpha = 2,
            ppc = 3,
            shx = 4,
            arm = 5,
            ia64 = 6,
            alpha64 = 7,
            unknown = 0xffff
        };
    };

    export struct system_exception_type
    {
        enum
        {
            access_violation = status::access_violation,
            datatype_misalignment = status::datatype_misalignment,
            breakipoint = status::breakipoint,
            single_step = status::single_step,
            array_bounds_exceeded = status::array_bounds_exceeded,
            decimal_denormal_operand = status::decimal_denormal_operand,
            decimal_divide_by_zero = status::decimal_divide_by_zero,
            decimal_inexact_result = status::decimal_inexact_result,
            decimal_invalid_operation = status::decimal_invalid_operation,
            decimal_overflow = status::decimal_overflow,
            decimal_stack_check = status::decimal_stack_check,
            decimal_underflow = status::decimal_underflow,
            integer_divide_by_zero = status::integer_divide_by_zero,
            integer_overflow = status::integer_overflow,
            privileged_instruction = status::privileged_instruction,
            in_page_error = status::in_page_error,
            illegal_instruction = status::illegal_instruction,
            non_continuable = status::noncontinuable_exception,
            stack_overflow = status::stack_overflow,
            invalid_disposition = status::invalid_disposition,
            guard_page = status::guard_page_violation,
            handle_invalid = status::handle_invalid,
            control_c_exit = status::control_c_exit
        };
    };

    export struct exception_type
    {
        enum
        {
            continuable = 0x0,
            noncontinuable = 0x1
        };
    };

    export  enum { exception_parameters_maximum = 15 };

    export struct exception_record
    {
        uint code;
        uint flags;
        exception_record* next;
        void* address;
        uint parameters;
        uint information[exception_parameters_maximum];
    };

    export struct exception_pointers
    {
        exception_record* record;
        void* context;
    };

    export  typedef int(__stdcall* top_level_exception_filter)(exception_pointers*);

    export struct exception_flag
    {
        enum
        {
            execute_handler = 1,
            continue_search = 0,
            continue_execution = -1
        };
    };

    export struct debug_event_flag
    {
        enum
        {
            exception = 1,
            create_thread = 2,
            create_process = 3,
            exit_thread = 4,
            exit_process = 5,
            load_library = 6,
            unload_library = 7,
            output_string = 8,
            system = 9
        };
    };

    export struct debug_information_exception
    {
        exception_record record_debug;
        uint first_chance;
    };

    export struct debug_information_create_thread
    {
        handle thread;
        void* base;
        void* address;
    };

    export struct debug_information_create_process
    {
        handle file;
        handle process;
        handle thread;
        void* image;
        uint offset;
        uint information;
        void* base;
        void* address;
        void* name;
        bool unicode;
    };

    export struct debug_information_exit_thread
    {
        uint exit_code;
    };

    export struct debug_information_exit_process
    {
        uint exit_code;
    };

    export struct debug_information_load_library
    {
        handle file;
        void* base;
        uint offset;
        uint information;
        void* name;
        part unicode;
    };

    export struct debug_information_unload_library
    {
        void* base;
    };

    export template<class character>
        struct debug_information_output_string
    {
        character* data;
        part unicode;
        part length;
    };

    export struct debug_information_system
    {
        uint error;
        uint type;
    };

    export template<class character>
        struct debug_event
    {
        uint code;
        uint process;
        uint thread;

        union
        {
            debug_information_exception       exception;
            debug_information_create_thread   create_thread;
            debug_information_exit_thread     exit_thread;
            debug_information_create_process  create_process;
            debug_information_load_library    load_library;
            debug_information_unload_library  unload_library;
            debug_information_output_string<character>   output_string;
            debug_information_system          system;
        };
    };

    export struct debug_action
    {
        enum
        {
            _continue = 0x00010002,
            terminate_thread = 0x40010003,
            terminate_process = 0x40010004,
            control_c = 0x40010005,
            control_break = 0x40010008,
            exception_not_handled = 0x80010001
        };
    };

    export struct  keyboard_layout_name { enum { length = 9 }; };

    export struct keyboard_layout_select
    {
        enum
        {
            previous = 0,
            next = 1
        };
    };

    export struct keyboard_flag
    {
        enum
        {
            activate = 0x0001,
            substitute_ok = 0x0002,
            unload_previous = 0x0004,
            reorder = 0x0008,
            replace_language = 0x0010,
            no_shell_notify = 0x0080,
            process = 0x0100
        };
    };

    export template<class character>
        struct version_information
    {
        uint size;
        uint major;
        uint minor;
        uint build;
        uint platform_identity;
        character service_version[128];
        part service_pack_major;
        part service_pack_minor;
        part reserved[2];

        enum
        {
            version_win32s = 0,
            version_win32_windows = 1,
            version_win_nt = 2
        };
    };

    export template<class character>
        struct load_parameters
    {
        character* environment;
        character* command;
        character* show;
        uint reserved;
    };

    export struct item_identity
    {
        enum
        {
            ok = 1,
            cancel,
            abort,
            retry,
            ignore,
            yes,
            no,
            close,
            help
        };
    };

    export struct message_box_style
    {
        enum
        {
            ok = 0x00000000,
            ok_cancel = 0x00000001,
            abort_retry_ignore = 0x00000002,
            yes_no_cancel = 0x00000003,
            yes_no = 0x00000004,
            retry_cancel = 0x00000005,
            icon_hand = 0x00000010,
            icon_question = 0x00000020,
            icon_exclamation = 0x00000030,
            icon_asterisk = 0x00000040,
            icon_user = 0x00000080,
            icon_warning = icon_exclamation,
            icon_error = icon_hand,
            icon_information = icon_asterisk,
            icon_stop = icon_hand,
            default_button1 = 0x00000000,
            default_button2 = 0x00000100,
            default_button3 = 0x00000200,
            default_button4 = 0x00000300,
            application_modal = 0x00000000,
            system_modal = 0x00001000,
            task_modal = 0x00002000,
            help = 0x00004000,
            no_focus = 0x00008000,
            set_foreground = 0x00010000,
            default_desktop_only = 0x00020000,
            message_box_top_most = 0x00040000,
            message_box_right = 0x00080000,
            message_box_right_to_left = 0x00100000,
            service_notification = 0x00200000,
            mask_type = 0x0000000f,
            mask_icon = 0x000000f0,
            mask_default = 0x00000f00,
            mask_mode = 0x00003000,
            mask_miscellaneous = 0x0000c000
        };
    };

    export template<class character>
        struct multikey_help
    {
        uint size;
        character key_list_character;
        character key_phrase[1];
    };

    export template<class character>
        struct help_window_information
    {
        int size;
        int x;
        int y;
        int width;
        int height;
        int show;
        character member[2];
    };

    export struct help_command
    {
        enum
        {
            context = 0x0001,
            quit = 0x0002,
            index = 0x0003,
            contents = 0x0003,
            on_help = 0x0004,
            set_index = 0x0005,
            set_contents = 0x0005,
            context_popup = 0x0008,
            force_file = 0x0009,
            key = 0x0101,
            command = 0x0102,
            partial_key = 0x0105,
            multikey = 0x0201,
            set_window_position = 0x0203,
            context_menu = 0x000a,
            finder = 0x000b,
            message_help = 0x000c,
            set_popup_position = 0x000d,
            training_card = 0x8000,
            training_card_data = 0x0010,
            training_card_other_caller = 0x0011
        };
    };

    export struct help_identity
    {
        enum
        {
            none = 28440,
            context_missing = 28441,
            generic_button = 28442,
            ok = 28443,
            cancel = 28444,
            identity = 28445
        };
    };

    export struct help_information_type
    {
        enum
        {
            window = 0x0001,
            menu_item = 0x0002
        };
    };

    export struct help_information
    {
        uint size;
        int context_type;
        int control_identity;
        handle item_handle;
        uint context_identity;
        ipoint mouse_position;
    };

    export  typedef void(__stdcall* message_box_callback)(help_information*);

    export template<class character>
        struct message_box_parameters
    {
        uint size;
        handle owner;
        handle module;
        character* text;
        character* caption;
        uint style;
        const character* icon;
        uint help;
        message_box_callback callback;
        uint language;
    };

    export struct serial_providor
    {
        enum { comm = 1 };
    };

    export struct providor_subtype
    {
        enum
        {
            unspecified = 0x00000000,
            rs232 = 0x00000001,
            parallel_port = 0x00000002,
            rs422 = 0x00000003,
            rs423 = 0x00000004,
            rs449 = 0x00000005,
            modem = 0x00000006,
            fax = 0x00000021,
            scanner = 0x00000022,
            network_bridge = 0x00000100,
            lat = 0x00000101,
            tcpip_telnet = 0x00000102,
            x25 = 0x00000103
        };
    };

    export struct providor_capabilities
    {
        enum
        {
            data_terminal_ready_dataset_ready = 0x0001,
            request_to_send_clear_to_send = 0x0002,
            receive_line_signal_detect = 0x0004,
            parity_check = 0x0008,
            xon_xoff = 0x0010,
            set_x_character = 0x0020,
            total_timeouts = 0x0040,
            interval_timeouts = 0x0080,
            special_characters = 0x0100,
            sixteen_bit_mode = 0x0200
        };
    };

    export struct settable_parameters
    {
        enum
        {
            parity = 0x0001,
            baud = 0x0002,
            data_bits = 0x0004,
            stop_bits = 0x0008,
            hand_shaking = 0x0010,
            parity_check = 0x0020,
            receive_line_signal_detect = 0x0040
        };
    };

    export  enum baud
    {
        baud_075 = 0x00000001,
        baud_110 = 0x00000002,
        baud_1345 = 0x00000004,
        baud_150 = 0x00000008,
        baud_300 = 0x00000010,
        baud_600 = 0x00000020,
        baud_1200 = 0x00000040,
        baud_1800 = 0x00000080,
        baud_2400 = 0x00000100,
        baud_4800 = 0x00000200,
        baud_7200 = 0x00000400,
        baud_9600 = 0x00000800,
        baud_14400 = 0x00001000,
        baud_19200 = 0x00002000,
        baud_38400 = 0x00004000,
        baud_56k = 0x00008000,
        baud_128k = 0x00010000,
        baud_115200 = 0x00020000,
        baud_57600 = 0x00040000,
        baud_user = 0x10000000
    };

    export  enum baud_rate
    {
        baud_rate_110 = 110,
        baud_rate_300 = 300,
        baud_rate_600 = 600,
        baud_rate_1200 = 1200,
        baud_rate_2400 = 2400,
        baud_rate_4800 = 4800,
        baud_rate_9600 = 9600,
        baud_rate_14400 = 14400,
        baud_rate_19200 = 19200,
        baud_rate_38400 = 38400,
        baud_rate_56000 = 56000,
        baud_rate_57600 = 57600,
        baud_rate_115200 = 115200,
        baud_rate_128000 = 128000,
        baud_rate_256000 = 256000
    };

    export  enum data_bits
    {
        data_bits_5 = 0x0001,
        data_bits_6 = 0x0002,
        data_bits_7 = 0x0004,
        data_bits_8 = 0x0008,
        data_bits_16 = 0x0010,
        data_bits_16x = 0x0020
    };

    export  enum stop_bits
    {
        stop_bits_10 = 0x0001,
        stop_bits_15 = 0x0002,
        stop_bits_20 = 0x0004
    };

    export  enum stop_bit_index
    {
        stop_bits1 = 0,
        stop_bits15 = 1,
        stop_bits2 = 2
    };

    export struct parity
    {
        enum
        {
            none = 0x0100,
            odd = 0x0200,
            even = 0x0400,
            mark = 0x0800,
            space = 0x1000
        };
    };

    export struct parity_index
    {
        enum
        {
            none = 0,
            odd = 1,
            even = 2,
            mark = 3,
            space = 4
        };
    };

    export struct communications_properties
    {
        part packet_length;
        part packet_version;
        uint service_mask;
        uint reserved1;
        uint maximum_transmit_x_queue;
        uint maximum_receive_x_queue;
        uint maximum_baud;
        uint providor_subtype;
        uint providor_capabilities;
        uint settable_parameters;
        uint settable_baud;
        part settable_data;
        part settable_stop_parity;
        uint current_transmit_x_queue;
        uint current_receive_x_queue;
        uint providor_specification1;
        uint providor_specification2;
        wchar_t providor[1];
    };

    export struct communications_statistics
    {
        uint clear_to_send_hold : 1;
        uint dataset_ready_hold : 1;
        uint receive_line_signal_detect_hold : 1;
        uint x_off_hold : 1;
        uint x_off_sent : 1;
        uint end_of_file : 1;
        uint transmit_immediate : 1;
        uint reserved : 25;
        uint in_queue_length;
        uint out_queue_length;
    };

    export template<class character>
        struct data_control_block
    {
        uint size;
        uint baud_rate;
        uint binary : 1;
        uint parity : 1;
        uint out_x_clear_to_send_flow : 1;
        uint out_x_dataset_ready_flow : 1;
        uint data_terminal_ready_control1 : 1;
        uint data_terminal_ready_control2 : 1;
        uint dataset_read_sensitivity : 1;
        uint transmit_continue_x_off : 1;
        uint out_x : 1;
        uint in_x : 1;
        uint error_character : 1;
        uint null : 1;
        uint request_to_send_control1 : 1;
        uint request_to_send_control2 : 1;
        uint cancel_on_error : 1;
        uint dummy2 : 17;
        part reserved;
        part x_on_limit;
        part x_off_limit;
        byte size_byte;
        byte parity_byte;
        byte stop_bits;
        character x_on;
        character x_off;
        character error;
        character end_of_file;
        character event;
        part reserved1;
    };

    export template <class character>
        struct communications_configuration
    {
        uint size;
        part version;
        part reserved;
        data_control_block<character> dcb;
        uint providor_subtype;
        uint providor_offset;
        uint providor_size;
        wchar_t providor_data[1];
    };

    export struct communications_timeouts
    {
        uint read_interval_timeout;
        uint read_total_timeout_multiplier;
        uint read_total_timeout_constant;
        uint write_total_timeout_multiplier;
        uint write_total_timeout_constant;
    };

    export  enum { communications_properly_initialized = 0xe73cf52e };

    export struct data_terminal_ready
    {
        enum
        {
            control_disable = 0x00,
            control_enable = 0x01,
            control_handshake = 0x02
        };
    };

    export struct request_to_send
    {
        enum
        {
            disable = 0x00,
            enable = 0x01,
            handshake = 0x02,
            toggle = 0x03
        };
    };

    export struct communications_error
    {
        enum
        {
            receive_overflow = 0x0001,
            over_run = 0x0002,
            receive_parity = 0x0004,
            frame = 0x0008,
            _break = 0x0010,
            transmit_full = 0x0100,
            printer_timeout = 0x0200,
            input_output = 0x0400,
            device_not_selected = 0x0800,
            out_of_paper = 0x1000,
            mode = 0x8000
        };
    };

    export struct communications_escape
    {
        enum
        {
            set_x_off = 1,
            set_x_on = 2,
            set_request_to_send = 3,
            clear_request_to_send = 4,
            set_data_terminal_ready = 5,
            clear_data_terminal_ready = 6,
            reset_device = 7,
            set_break = 8,
            clear_break = 9
        };
    };

    export struct communications_event
    {
        enum
        {
            character_received = 0x0001,
            flag_received = 0x0002,
            transmit_empty = 0x0004,
            clear_to_send = 0x0008,
            data_set_ready = 0x0010,
            receive_line_signal_detect = 0x0020,
            _break = 0x0040,
            error = 0x0080,
            ring = 0x0100,
            printer_error = 0x0200,
            receive80_full = 0x0400,
            event1 = 0x0800,
            event2 = 0x1000
        };
    };

    export struct modem_status
    {
        enum
        {
            clear_to_send_on = 0x0010,
            data_set_ready_on = 0x0020,
            ring_on = 0x0040,
            receive_line_signal_detection = 0x0080
        };
    };

    export struct modem_capabilities
    {
        uint actual_size;
        uint required_size;
        uint device_specific_offset;
        uint device_specific_size;
        uint providor_version;
        uint manufacturer_offset;
        uint manufacturer_size;
        uint model_offset;
        uint model_size;
        uint version_offset;
        uint version_size;
        uint dial_options;
        uint call_setup_fail_timer;
        uint inactivity_timeout;
        uint speaker_volume;
        uint speaker_mode;
        uint options;
        uint maximum_rate_dte;
        uint maximum_rate_dce;
        byte variable[1];
    };

    export struct modem_settings
    {
        uint actual_size;
        uint required_size;
        uint device_specific_offset;
        uint device_specific_size;
        uint call_setup_fail_timer;
        uint inactivity_timeout;
        uint speaker_volume;
        uint speaker_mode;
        uint preferred_options;
        uint negotiated_options;
        uint negotiated_rate_dce;
        byte variable[1];
    };

    export struct dial_option
    {
        enum
        {
            billing = 0x0040,
            quiet = 0x0080,
            dial_tone = 0x0100,
        };
    };

    export struct modem_volume_support
    {
        enum
        {
            low = 0x0001,
            medium = 0x0002,
            high = 0x0004
        };
    };

    export struct modem_volume
    {
        enum
        {
            low = 0x0000,
            medium = 0x0001,
            high = 0x0002
        };
    };

    export struct modem_speaker_support
    {
        enum
        {
            off = 0x00000001,
            dial = 0x00000002,
            on = 0x00000004,
            call_setup = 0x00000008
        };
    };

    export struct modem_speaker
    {
        enum
        {
            off = 0x0000,
            dial = 0x0001,
            on = 0x0002,
            call_setup = 0x0003
        };
    };

    export struct modem_option
    {
        enum
        {
            compression = 0x0001,
            error_control = 0x0002,
            forced_ec = 0x0004,
            cellular = 0x0008,
            flow_control_hard = 0x0010,
            flow_control_soft = 0x0020,
            ccitt_override = 0x0040,
            adjust_speed = 0x0080,
            tone_dial = 0x0100,
            blind_dial = 0x0200,
            v23_override = 0x0400
        };
    };

    export struct purge
    {
        enum
        {
            tx_cancel = 0x0001,
            rx_cancel = 0x0002,
            tx_clear = 0x0004,
            rx_clear = 0x0008
        };
    };

    export extern "C" long long key_classes_root(0x80000000);
    export extern "C" long long key_current_user(0x80000001);
    export extern "C" long long key_local_machine(0x8000000);
    export extern "C" long long key_users(0x80000003);
    export extern "C" long long key_performance_data(0x80000004);
    export extern "C" long long key_current_configuration(0x80000005);
    export extern "C" long long key_dynamic_data(0x80000006);

    export struct key_access
    {
        enum
        {
            query_value = 0x0001,
            set_value = 0x0002,
            create_subkey = 0x0004,
            enumerate_subkeys = 0x0008,
            notify = 0x0010,
            create_link = 0x0020,
            read = access_type::standard_read | query_value | enumerate_subkeys | notify & ~access_type::synchronize,
            write = access_type::standard_write | set_value | create_subkey & ~access_type::synchronize,
            execute = read,
            all = access_type::all_standard | query_value | set_value | create_subkey | enumerate_subkeys | notify | create_link & ~access_type::synchronize
        };
    };

    export struct key_option
    {
        enum
        {
            nonvolatile = 0x0000,
            _volatile = 0x0001,
            create_link = 0x0002,
            restore_backup = 0x0004,
            open_link = 0x0008,
        };
    };

    export struct key_disposition
    {
        enum
        {
            created = 0x0001,
            opened = 0x0002
        };
    };

    export struct registry_restore
    {
        enum
        {
            hive_volatile = 0x0001,
            hive_refresh = 0x0002,
            no_lazy_flush = 0x0004
        };
    };

    export template<class character>
        struct value_entry
    {
        character* name;
        uint size;
        void* data;
        uint type;
    };

    export struct key_type
    {
        enum
        {
            none = 0,
            string = 1,
            string_expand = 2,
            binary = 3,
            integer = 4,
            integer_reverse = 5,
            link = 6,
            multiple_string = 7,
            resource_list = 8,
            full_resource_descriptor = 9,
            resource_requirements_list = 10,
        };
    };

    export struct registry_notify
    {
        enum
        {
            name = 0x00000001,
            attributes = 0x00000002,
            value = 0x00000004,
            security = 0x00000008
        };
    };

    export struct event_log_read
    {
        enum
        {
            sequential = 0x0001,
            seek = 0x0002,
            forwards = 0x0004,
            backwards = 0x0008
        };
    };

    export struct event_type
    {
        enum
        {
            success = 0x0000,
            error = 0x0001,
            warning = 0x0002,
            information = 0x0004,
            audit_success = 0x0008,
            audit_failure = 0x0010
        };
    };

    export struct event_paired
    {
        enum
        {
            start = 0x0001,
            end = 0x0002,
            end_all = 0x0004,
            active = 0x0008,
            inactive = 0x0010
        };
    };

    export struct event_record
    {
        uint size;
        uint reserved;
        uint record_number;
        uint time_generated;
        uint time_written;
        uint event_identity;
        part event_type;
        part number_ofstrings;
        part event_category;
        part reserved1;
        uint closing_record_number;
        uint string_offset;
        uint identity_length;
        uint identity_offset;
        uint data_length;
        uint data_offset;

        // wchar_t source_name[];
        // wchar_t computer_name[];
        // identity user_identity;
        // wchar_t strings[];
        // byte data[]
    };

    export struct tape_parameters
    {
        enum
        {
            media_information = 0,
            drive_information = 1,
        };
    };

    export struct tape_drive_get_parameters
    {
        bool error_correction;
        bool compression;
        bool data_padding;
        bool report_set_marks;
        uint default_block_size;
        uint maximum_block_size;
        uint minimum_block_size;
        uint maximum_partition_count;
        uint features_low;
        uint features_high;
        uint end_of_tape_warning_zone_size;
    };

    export struct tape_drive_set_parameters
    {
        bool error_correction;
        bool compression;
        bool data_padding;
        bool report_set_marks;
        uint end_of_tape_warning_zone_size;
    };

    export struct tape_media_get_parameters
    {
        large_integer capacity;
        large_integer remaining;
        uint block;
        uint partition_count;
        bool write_protected;
    };

    export struct tape_media_set_parameters
    {
        uint block;
    };

    export struct tape_erase_flag
    {
        enum
        {
            _short = 0,
            _long = 1
        };
    };

    export struct tape_erase
    {
        uint type;
        bool immediate;
    };

    export struct tape_position_type
    {
        enum
        {
            absolute = 0,
            logical = 1,
            pseudological = 2
        };
    };

    export struct tape_get_position
    {
        uint type;
        uint partition;
        large_integer offset;
    };

    export struct tape_set_window_position
    {
        uint method;
        uint partition;
        large_integer offset;
        bool immediate;
    };

    export struct tape_position
    {
        enum
        {
            rewind = 0,
            absolute_block = 1,
            logical_block = 2,
            pseudological_block = 3,
            end_ofdata = 4,
            relative_blocks = 5,
            file_marks = 6,
            sequential_file_marks = 7,
            set_marks = 8,
            sequential_set_marks = 9
        };
    };

    export struct tape_operation
    {
        enum
        {
            load = 0,
            unload = 1,
            tension = 2,
            lock = 3,
            unlock = 4,
            format = 5
        };
    };

    export struct tape_prepare
    {
        uint operation;
        bool immediate;
    };

    export struct tape_marks
    {
        enum
        {
            set_marks = 0,
            file_marks = 1,
            file_marks_short = 2,
            file_marks_long = 3
        };
    };

    export struct tape_write_marks
    {
        uint type;
        uint count;
        bool immediate;
    };

    export struct tape_features_low
    {
        enum
        {
            fixed = 0x00000001,
            select = 0x00000002,
            initiator = 0x00000004,
            erase_short = 0x00000010,
            erase_long = 0x00000020,
            erase_partition_only = 0x00000040,
            erase_immediate = 0x00000080,
            capacity = 0x00000100,
            remaining = 0x00000200,
            fixed_block = 0x00000400,
            variable_block = 0x00000800,
            write_protect = 0x00001000,
            end_of_tape_warning_size = 0x00002000,
            error_correction = 0x00010000,
            compression = 0x00020000,
            padding = 0x00040000,
            report_set_marks = 0x00080000,
            get_absolute_block = 0x00100000,
            get_logical_block = 0x00200000,
            set_end_oftape_warning_size = 0x00400000,
            eject_media = 0x01000000,
            clean_requests = 0x02000000,
            set_compare_partition_only = 0x04000000,
            reserved = 0x80000000
        };
    };

    export struct tape_features_high
    {
        enum
        {
            load_unload = 0x80000001,
            tension = 0x80000002,
            lock_unlock = 0x80000004,
            rewind_immediate = 0x80000008,
            set_block_size = 0x80000010,
            load_unload_immediate = 0x80000020,
            tension_immediate = 0x80000040,
            lock_unlock_immediate = 0x80000080,
            set_error_correction = 0x80000100,
            set_compression = 0x80000200,
            set_padding = 0x80000400,
            set_report_set_marks = 0x80000800,
            absolute_block = 0x80001000,
            absolute_block_immediate = 0x80002000,
            logical_block = 0x80004000,
            logical_block_immediate = 0x80008000,
            end_of_data = 0x80010000,
            relative_blocks = 0x80020000,
            file_marks = 0x80040000,
            sequential_file_marks = 0x80080000,
            set_marks = 0x80100000,
            sequential_set_marks = 0x80200000,
            reverse_position = 0x80400000,
            space_immediate = 0x80800000,
            write_set_marks = 0x81000000,
            write_file_marks = 0x82000000,
            write_short_file_marks = 0x84000000,
            write_long_file_marks = 0x88000000,
            write_mark_immediate = 0x90000000,
            format = 0xa0000000,
            format_immediate = 0xc0000000,
        };
    };

    export struct tape_partition
    {
        enum
        {
            select = 1,
            initiate = 2
        };
    };

    export struct raster_operation
    {
        enum
        {
            source_copy = 0x00cc0020, // destination = source
            source_paint = 0x00ee0086, // destination = source or destination
            source_and = 0x008800c6, // destination = source and destination
            source_invert = 0x00660046, // destination = source xor destination
            sourkeyrase = 0x00440328, // destination = source and (not destination)
            not_source_copy = 0x00330008, // destination = (not source)
            not_source_erase = 0x001100a6, // destination = (not source) and (not destination)
            merge_copy = 0x00c000ca, // destination = (source and pattern)
            merge_paint = 0x00bb0226, // destination = (not source) or destination
            pattern_copy = 0x00f00021, // destination = pattern
            pattern_paint = 0x00fb0a09, // destination = pattern or destination
            pattern_invert = 0x005a0049, // destination = pattern xor destination
            destination_invert = 0x00550009, // destination = (not destination)
            black = 0x00000042, // destination = physical palette color 0
            white = 0x00ff0062, // destination = physical palette color 1
        };
    };

    export  uint make_raster4(uint foreground, uint background)
    {
        return ((background << 8) & 0xff000000) | foreground;
    }

    export  enum { error_graphics = 0xffffffff };

    export  long long error_handle(0xffffffff);

    export struct color_space
    {
        enum
        {
            enable = 0x0001,
            disable = 0x0002,
            transform_delete = 0x0003
        };
    };

    // logical color space types

    export  long long sRGB('sRGB');
    export  long long Win('Win ');

    export struct color_space_type
    {
        enum
        {
            s_red_green_blue = 'sRGB',
            windows = 'Win ',
            calibrated_red_green_blue = 0x00000000,
            device_red_green_blue = 0x00000001,
            device_cmyk = 0x00000002
        };
    };

    export  enum color_gamut_flags
    {
        color_in_gamut = 255,
        color_not_in_gamut = 0
    };

    export  byte k_value(uint cmyk) { return (byte)cmyk; }
    export  byte yellow_value(uint cmyk) { return (byte)((cmyk) >> 8); }
    export  byte magenta_value(uint cmyk) { return (byte)((cmyk) >> 16); }
    export  byte cyan_value(uint cmyk) { return (byte)((cmyk) >> 24); }

    //inline color cyan_magentayellow(byte c, byte m, byte y, byte k)
    //{return ((color)(((k|((part)y<<8))|(((uint)m)<<16))|(((uint)c)<<24)));}

    export struct gammut
    {
        enum
        {
            saturated = 0x00000001,
            relative = 0x00000002,
            contrast = 0x00000004,
            absolute = 0x00000008
        };
    };

    export  enum { color_invalid = 0xffffffff };

    // #define design_vector_stamp (0x8000000 + 'd' + ('v' << 8))
    // #define axes_list_stamp     (0x8000000 + 'a' + ('l' << 8))

    export struct gradient_fill_flag
    {
        enum
        {
            rectangle_horizontal = 0x0000,
            rectangle_vertical = 0x0001,
            triangle = 0x0002
        };
    };

    export struct image_color_management_flag
    {
        enum
        {
            off = 1,
            on = 2,
            query = 3,
            outside_device = 4
        };
    };

    export struct glyph_metric
    {
        idimensions box;
        ipoint origin;
        part x_increment;
        part y_increment;
    };

    export  enum { device_name_length = 32, form_name_length = 32, device_string_length = 128 };

    export template<class character>
        struct device_mode
    {
        enum member
        {
            member_orientation = 0x00000001,
            member_paper_size = 0x00000002,
            member_paper_length = 0x00000004,
            member_paper_width = 0x00000008,
            member_scale = 0x00000010,
            member_position = 0x00000020,
            member_copies = 0x00000100,
            member_default_source = 0x00000200,
            member_print_quality = 0x00000400,
            member_color = 0x00000800,
            member_duplex = 0x00001000,
            member_y_resolution = 0x00002000,
            member_true_type_option = 0x00004000,
            member_collate = 0x00008000,
            member_form_name = 0x00010000,
            member_logical_pixels = 0x00020000,
            member_bits_per_pixel = 0x00040000,
            member_pixel_width = 0x00080000,
            member_pixel_height = 0x00100000,
            member_display_flags = 0x00200000,
            member_display_frequency = 0x00400000,
            member_image_color_method = 0x00800000,
            member_image_color_intent = 0x01000000,
            member_media_type = 0x02000000,
            member_dither_type = 0x04000000,
            member_panning_width = 0x08000000,
            member_panning_height = 0x10000000
        };

        enum paper
        {
            paper_letter = 1,
            paper_letter_small = 2,
            paper_tabloid = 3,
            paper_ledger = 4,
            paper_legal = 5,
            paper_statement = 6,
            paper_executive = 7,
            paper_a3 = 8,
            paper_a4 = 9,
            paper_a4_small = 10,
            paper_a5 = 11,
            paper_b4 = 12,
            paper_b5 = 13,
            paper_folio = 14,
            paper_quarto = 15,
            paper_10x14 = 16,
            paper_11x17 = 17,
            paper_note = 18,
            paper_envelope9 = 19,
            paper_envelope10 = 20,
            paper_envelope11 = 21,
            paper_envelope12 = 22,
            paper_envelope14 = 23,
            paper_c_sheet = 24,
            paper_d_sheet = 25,
            paper_e_sheet = 26,
            paper_envelope_dl = 27,
            paper_envelope_c5 = 28,
            paper_envelope_c3 = 29,
            paper_envelope_c4 = 30,
            paper_envelope_c6 = 31,
            paper_envelope_c65 = 32,
            paper_envelope_b4 = 33,
            paper_envelope_b5 = 34,
            paper_envelope_b6 = 35,
            paper_envelope_italy = 36,
            paper_envelope_monarch = 37,
            paper_envelope_personal = 38,
            paper_fanfold_us = 39,
            paper_fanfold_german_standard = 40,
            paper_fanfold_german_legal = 41,
            paper_iso_b4 = 42,
            paper_japanese_postcard = 43,
            paper_9x11 = 44,
            paper_10x11 = 45,
            paper_5x11 = 46,
            paper_envelope_invite = 47,
            paper_letter_extra = 50,
            paper_legal_extra = 51,
            paper_tabloid_extra = 52,
            paper_a4extra = 53,
            paper_letter_transverse = 54,
            paper_a4_transverse = 55,
            paper_letter_extra_transverse = 56,
            paper_a_plus = 57,
            paper_b_plus = 58,
            paper_letter_plus = 59,
            paper_a4plus = 60,
            paper_a5_transverse = 61,
            paper_b5_transverse = 62,
            paper_a30_extra = 63,
            paper_a5_extra = 64,
            paper_b5_extra = 65,
            paper_a2 = 66,
            paper_b3_transverse = 67,
            paper_a3_extra_transverse = 68,
            paper_double_japanese_postcard = 69,
            paper_a6 = 70,
            paper_japanese_envelope_kaku2 = 71,
            paper_japanese_envelope_kaku3 = 72,
            paper_japanese_envelope_chou3 = 73,
            paper_japanese_envelope_chou4 = 74,
            paper_letter_rotated = 75,
            paper_a3_rotated = 76,
            paper_a4_rotated = 77,
            paper_a5_rotated = 78,
            paper_b4_jis_rotated = 79,
            paper_b5_jis_rotated = 80,
            paper_japanese_postcard_rotated = 81,
            paper_double_japanese_postcard_rotated = 82,
            paper_a6_rotated = 83,
            paper_japanese_envelope_kaku2_rotated = 84,
            paper_japanese_envelope_kaku3_rotated = 85,
            paper_japanese_envelope_chou3_rotated = 86,
            paper_japanese_envelope_chou4_rotated = 87,
            paper_b6_jis = 88,
            paper_b6_jis_rotated = 89,
            paper1_2x11 = 90,
            paper_japanese_envelope_you4 = 91,
            paper_japanese_envelope_you4_rotated = 92,
            paper_chinese_16k = 93,
            paper_chinese_32k = 94,
            paper_chinese_32k_big = 95,
            paper_chinese_envelope1 = 96,
            paper_chinese_envelope2 = 97,
            paper_chinese_envelope3 = 98,
            paper_chinese_envelope4 = 99,
            paper_chinese_envelope5 = 100,
            paper_chinese_envelope6 = 101,
            paper_chinese_envelope7 = 102,
            paper_chinese_envelope8 = 103,
            paper_chinese_envelope9 = 104,
            paper_chinese_envelope10 = 105,
            paper_chinese16k_rotated = 106,
            paper_chinese32k_rotated = 107,
            paper_chinese32k_big_rotated = 108,
            paper_chinese_envelope1_rotated = 109,
            paper_chinese_envelope2_rotated = 110,
            paper_chinese_envelope3_rotated = 111,
            paper_chinese_envelope4_rotated = 112,
            paper_chinese_envelope5_rotated = 113,
            paper_chinese_envelope6_rotated = 114,
            paper_chinese_envelope7_rotated = 115,
            paper_chinese_envelope8_rotated = 116,
            paper_chinese_envelope9_rotated = 117,
            paper_chinese_envelope10_rotated = 118,
            paper_user = 256
        };

        enum bin
        {
            bin_upper = 1,
            bin_lower = 2,
            bin_middle = 3,
            bin_manual = 4,
            bin_envelope = 5,
            bin_envelope_manual = 6,
            bin_auto = 7,
            bin_tractor = 8,
            bin_small_format = 9,
            bin_large_format = 10,
            bin_large_capacity = 11,
            bin_cassette = 14,
            bin_form_source = 15,
            bin_user = 256
        };

        enum resolution
        {
            resolution_draft = -1,
            resolution_low = -2,
            resolution_medium = -3,
            resolution_high = -4,
        };

        enum { monochrome = 1, colored };

        enum duplex_enum {
            simplex = 1,
            duplex_vertical,
            duplex_horizontal
        };

        enum true_type {
            true_type_bitmap = 1,
            true_type_download = 2,
            true_type_device_substitute,
            true_type_download_outline
        };

        enum collate_enum { collate_off = 0, collate_on = 1 };

        enum image { greyscale = 1, interlaced = 2, text_mode = 4 };

        enum image_color_management_method
        {
            image_color_management_none = 1,
            image_color_management_system = 2,
            image_color_management_driver = 3,
            image_color_management_device = 4,
            image_color_management_method_user = 256
        };

        enum image_color_management_intent
        {
            image_color_management_saturate = 1,
            image_color_management_contrast = 2,
            image_color_management_color_i_metric = 3,
            image_color_management_absolute_color_i_metric = 4,
            image_color_management_intent_user = 256
        };

        enum media_type
        {
            media_type_standard = 1,
            media_type_transparency = 2,
            media_type_glossy = 3,
            media_type_user = 256
        };

        enum dither_type
        {
            dither_none = 1,
            dither_coarse = 2,
            dither_fine = 3,
            dither_fine_art = 4,
            dither_error_diffusion = 5,
            dither_reserved6 = 6,
            dither_reserved7 = 7,
            dither_reserved8 = 8,
            dither_reserved9 = 9,
            dither_gray_scale = 10,
            dither_user = 256
        };

        enum orientation_enum
        {
            portrait = 1,
            landscape = 2
        };

        character device_name[device_name_length];
        part specific_version;
        part driver_version;
        part size;
        part driver_extra;
        uint members;
        union
        {
            struct
            {
                short orientation;
                short paper_size;
                short paper_length;
                short paper_width;
            };
            struct
            {
                int x;
                int y;
            };
        };
        short scale;
        short copies;
        short default_source;
        short print_quality;
        short color;
        short duplex;
        short y_resolution;
        short true_type_option;
        short collate;
        character form_name[form_name_length];
        part logical_pixels;
        uint bits_per_pixel;
        uint pixel_width;
        uint pixel_height;
        uint display_flags;
        uint display_frequency;
        uint image_color_method;
        uint image_color_intent;
        uint media_type;
        uint dither_type;
        uint reserved1;
        uint reserved2;
        uint panning_width;
        uint panning_height;
    };

    export struct pitch_and_family
    {
        enum
        {
            variable = 0x01,
            vector = 0x02,
            true_type = 0x04,
            device = 0x08
        };
    };

    export template<class character>
        struct text_metrics
    {
        int height;
        int ascent;
        int descent;
        int internal_leading;
        int external_leading;
        int average_character_width;
        int maximum_character_width;
        int weight;
        int over_hang;
        int aspect_x;
        int aspect_y;
        character first_character;
        character last_character;
        character default_character;
        character break_character;
        byte italic;
        byte underline;
        byte strikeout;
        byte pitch_and_family;
        byte character_set;
    };

    export struct text_flags
    {
        enum
        {
            italic = 0x01,
            bold = 0x20,
            regular = 0x40
        };
    };

    export struct text_metric_flags
    {
        enum
        {
            nonnegative_ac = 0x00010000,
            open_type = 0x00020000,
            multiple_master = 0x00040000,
            map_mode_instance = 0x00080000,
            type1 = 0x00100000,
            signature = 0x00200000
        };
    };

    export struct font_flags
    {
        enum
        {
            italic = 0,
            underscore = 1,
            negative = 2,
            outline = 3,
            strikeout = 4,
            bold = 5
        };
    };

    export template<class character>
        struct new_text_metrics : public text_metrics<character>
    {
        uint flags;
        uint em_size;
        uint cell_height;
        uint average_width;
    };

    export struct font_signature
    {
        uint unicode_bits[4];
        uint codepage[2];
    };

    export template<class character>
        struct text_metrics_signature : public new_text_metrics<character>
    {
        font_signature signature;
    };

    export struct character_set_information
    {
        uint character_set;
        uint ansi_codepage;
        font_signature signature;
    };

    export struct locale_signature
    {
        uint unicode_bit_field[4];
        uint default_codepage[2];
        uint supportedcodepage[2];
    };

    export struct translate_character_set_flag
    {
        enum
        {
            source = 1,
            codepage = 2,
            font_signature = 3
        };
    };

    export struct pixel_array
    {
        int x_count;
        int y_count;
        int x_extent;
        int y_extent;
        byte red_green_blue;
    };

    export  byte red_value(uint red_green_blue) { return ((byte)(red_green_blue)); }
    export  byte green_value(uint red_green_blue) { return ((byte)(((part)(red_green_blue)) >> 8)); }
    export  byte blue_value(uint red_green_blue) { return ((byte)((red_green_blue) >> 16)); }

    export struct abc
    {
        int  a;
        uint b;
        int  c;
    };

    export struct decimal_abc
    {
        double a;
        double b;
        double c;
    };

    export struct poly_curve
    {
        part type;
        part fixed;
        ipoint curve[1];

        ipoint& operator[](uint index) { return curve[index]; }
    };

    export struct polygon_header
    {
        uint size;
        uint type;
        ipoint start;
    };

    export struct pixel_format_descriptor
    {
        enum pixel { pixel_red_green_blue_a = 0, pixel_index = 1 };

        enum layer { layer_main = 0, overlay = 1, underlay = -1 };

        enum format_descriptor
        {
            format_double_buffer = 0x00000001,
            format_stereo = 0x00000002,
            format_draw_to_window = 0x00000004,
            format_draw_to_bitmap = 0x00000008,
            format_support_graphics = 0x00000010,
            format_support_open__language = 0x00000020,
            format_generic = 0x00000040,
            format_palette_required = 0x00000080,
            format_system_palette_required = 0x00000100,
            format_swap_exchange = 0x00000200,
            format_swap_copy = 0x00000400,
            format_swap_layer_buffers = 0x00000800,
            format_generic_accelerated = 0x00001000,
            format_direct_draw_support = 0x00002000,
            format_depth_any = 0x20000000,
            format_double_buffer_any = 0x40000000,
            format_stereo_any = 0x80000000
        };

        part size;
        part version;
        uint flags;
        byte pixel_type;
        byte color_bits;
        byte red_bits;
        byte red_shift;
        byte green_bits;
        byte green_shift;
        byte blue_bits;
        byte blue_shift;
        byte alpha_bits;
        byte alpha_shift;
        byte accumulated_bits;
        byte accumulated_red_bits;
        byte accumulated_green_bits;
        byte accumulated_blue_bits;
        byte accumulated_alpha_bits;
        byte depth_bits;
        byte stencil_bits;
        byte auxiliary_buffers;
        byte layer_type;
        byte reserved_byte;
        uint layer_mask;
        uint visible_mask;
        uint damage_mask;
    };

    export struct color_adjustment
    {
        enum {
            adjustment_negative = 0x0001,
            adjustment_logical_filter = 0x0002
        };

        enum illuminant
        {
            illuminant_default = 0,
            illuminant_a = 1,
            illuminant_b = 2,
            illuminant_c = 3,
            illuminant_d50 = 4,
            illuminant_d55 = 5,
            illuminant_d65 = 6,
            illuminant_d75 = 7,
            illuminant_f2 = 8,

            illuminant_tungsten = illuminant_a,
            illuminant_daylight = illuminant_c,
            illuminant_fluorescent = illuminant_f2,
            illuminant_ntsc = illuminant_c
        };

        enum {
            red_green_blue_gamma_minimum = 2500,
            red_green_blue_gamma_maximum = 65000,
            red_green_blue_gamma_none = 10000
        };

        enum {
            reference_white_minimum = 6000,
            reference_white_maximum = 10000,
            reference_black_minimum = 0,
            reference_black_maximum = 4000
        };

        enum {
            color_adjustment_minimum = -100,
            color_adjustment_maximum = 100
        };

        part size;
        part flags;
        part illuminant;
        part red_gamma;
        part green_gamma;
        part blue_gamma;
        part reference_black;
        part reference_white;
        short contrast;
        short brightness;
        short saturation;
        short red_green_tint;
    };

    export struct display_device_flags
    {
        enum
        {
            attached_to_desktop = 0x00000001,
            multiple_driver = 0x00000002,
            primary_device = 0x00000004,
            mirroring_driver = 0x00000008,
            vga_compatible = 0x00000010
        };
    };

    export template<class character>
        struct display_device
    {
        uint size;
        character device_name[device_name_length];
        character device_string[device_string_length];
        uint state;

        display_device() : size(sizeof(display_device)) {}
    };

    export  typedef int(__stdcall* enumerate__object)(void*, parameter);

    export  typedef void(__stdcall* plot)(int, int, parameter);

    export  typedef uint(__stdcall* device_mode_callback)(handle,
        handle,
        device_mode<wchar_t>*,
        character*,
        character*,
        device_mode<wchar_t>*,
        character*,
        uint);

    export  typedef bool(__stdcall* cancellation_callback)(handle h,
        int error);

    export  typedef int(__stdcall* enumerate_image_color)(character*,
        parameter);

    export struct trivertex
    {
        int x;
        int y;
        part red;
        part green;
        part blue;
        part alpha;
    };

    export struct gradient_triangle
    {
        uint vertex1;
        uint vertex2;
        uint vertex3;
    };

    export struct gradient_rectangle
    {
        uint upper_left;
        uint lower_right;
    };

    export struct blend_function
    {
        byte blend_operation;
        byte blend_flags;
        byte source_constant_alpha;
        byte alpha_format;
    };

    export  enum alpha_blend_operation { alpha_channel_source_over = 0x00 };

    export struct alpha_format_flag
    {
        enum
        {
            source_no_premultiply_alpha = 0x01,
            source_no_alpha = 0x02,
            destination_no_premultiply_alpha = 0x10,
            destination_no_alpha = 0x20
        };
    };

    export  int logical_color_space_signature = 'PSOC';

    export struct color_xyz
    {
        int x;
        int y;
        int z;
    };

    export struct color_red_green_blue
    {
        color_xyz red;
        color_xyz green;
        color_xyz blue;
    };

    export template<class character>
        struct logical_color_space
    {
        uint signature;
        uint version;
        uint size;
        int color_space_type;
        int gamut_match_intent;
        color_red_green_blue color_end_points;
        uint red_gamma;
        uint green_gamma;
        uint blue_gamma;
        character file_name[path_length::maximum];

        logical_color_space()
            : signature(logical_color_space_signature),
            version(0x400),
            size(sizeof(logical_color_space)) {}
    };

    export struct palette_property
    {
        enum
        {
            reserved = 0x01,
            _explicit = 0x02,
            no_collapse = 0x04
        };
    };

    export struct palette_entry
    {
        byte red;
        byte green;
        byte blue;
        byte flags;
    };

    export struct logical_palette
    {
        part version;
        part count;
        palette_entry entries[1];

        palette_entry& operator[](int index) { return entries[index]; }
    };

    export struct system_palette_value { enum { _default = 15 }; };

    export  uint red_green_blue(uint r, uint g, uint b) { return (icolor)(r | g << 8 | b << 16); }
    export  uint palette_red_green_blue(uint r, uint g, uint b) { return (icolor)((r | g << 8 | b << 16) | 0x02000000); }
    export  uint palette_index(uint i) { return (uint)(0x01000000 | (uint)(part)(i)); }

    export  enum face_sizes
    {
        face_size = 32,
        face_size_full = 64,
        face_size_vendor = 4
    };

    export struct panose
    {
        enum { member_count = 10 };

        enum panose_member
        {
            member_family_type = 0,
            member_serifstyle = 1,
            member_weight = 2,
            member_proportion = 3,
            member_contrast = 4,
            member_stroke_variation = 5,
            member_arm_style = 6,
            member_letter_form = 7,
            member_midline = 8,
            member_x_height = 9
        };

        enum panose_culture { culture_latin = 0 };

        enum panose_fit { fit_any = 0, fit_none };

        enum panose_family
        {
            family_text_display = 2,
            family_script = 3,
            family_decorative = 4,
            family_pictorial = 5
        };

        enum panose_serif
        {
            serif_cove = 2,
            serif_obtuse_cove = 3,
            serif_square_cove = 4,
            serif_obtuse_square_cove = 5,
            serif_square = 6,
            serif_thin = 7,
            serif_bone = 8,
            serif_exaggerated = 9,
            serif_triangle = 10,
            serif_normal_sans = 11,
            serif_obtuse_sans = 12,
            serif_perpendicular_sans = 13,
            serif_flared = 14,
            serif_rounded = 15
        };

        enum panose_weight
        {
            weight_very_light = 2,
            weight_light = 3,
            weight_thin = 4,
            weight_book = 5,
            weight_medium = 6,
            weight_demi = 7,
            weight_bold = 8,
            weight_heavy = 9,
            weight_black = 10,
            weight_nord = 11
        };

        enum panose_proportion
        {
            proportion_old_style = 2,
            proportion_modern = 3,
            proportion_even_width = 4,
            proportion_expanded = 5,
            proportion_condensed = 6,
            proportion_very_expanded = 7,
            proportion_very_condensed = 8,
            proportion_monospaced = 9
        };

        enum panose_contrast
        {
            contrast_none = 2,
            contrast_very_low = 3,
            contrast_low = 4,
            contrast_medium_low = 5,
            contrast_medium = 6,
            contrast_medium_high = 7,
            contrast_high = 8,
            contrast_very_high = 9
        };

        enum panose_stroke
        {
            stroke_gradual_diagonal = 2,
            stroke_gradual_transverse = 3,
            stroke_gradual_vertical = 4,
            stroke_gradual_horizontal = 5,
            stroke_rapid_vertical = 6,
            stroke_rapid_horizontal = 7,
            stroke_instant_vertical = 8
        };

        enum panose_arm
        {
            arm_straight_horizontal = 2,
            arm_straight_wedge = 3,
            arm_straight_vertical = 4,
            arm_straight_serif_single = 5,
            arm_straight_serif_double = 6,
            arm_bent_horizontal = 7,
            arm_bent_wedge = 8,
            arm_bent_vertical = 9,
            arm_bent_serif_single = 10,
            arm_bent_serif_double = 11
        };

        enum panose_letter_form
        {
            letter_form_normal_contact = 2,
            letter_form_normal_weighted = 3,
            letter_form_normal_boxed = 4,
            letter_form_normal_flattened = 5,
            letter_form_normal_rounded = 6,
            letter_form_normal_offcenter = 7,
            letter_form_normal_square = 8,
            letter_form_oblique_contact = 9,
            letter_form_oblique_weighted = 10,
            letter_form_oblique_boxed = 11,
            letter_form_oblique_flattened = 12,
            letter_form_oblique_rounded = 13,
            letter_form_oblique_off_center = 14,
            letter_form_oblique_square = 15
        };

        enum panose_midline
        {
            midline_standard_trimmed = 2,
            midline_standard_pointed = 3,
            midline_standard_serifed = 4,
            midline_high_trimmed = 5,
            midline_high_pointed = 6,
            midline_high_serifed = 7,
            midline_constant_trimmed = 8,
            midline_constant_pointed = 9,
            midline_constant_serifed = 10,
            midline_low_trimmed = 11,
            midline_low_pointed = 12,
            midline_low_serifed = 13
        };

        enum panose_x_height
        {
            x_height_constant_small = 2,
            x_height_constant_standard = 3,
            x_height_constant_large = 4,
            x_height_ducking_small = 5,
            x_height_ducking_standard = 6,
            x_height_ducking_large = 7
        };

        byte family_type;
        byte serif_style;
        byte weight;
        byte proportion;
        byte contrast;
        byte stroke_variation;
        byte arm_style;
        byte letter_form;
        byte midline;
        byte x_height;
    };

    export template<class character>
        struct outline_text_metrics
    {
        uint size;
        text_metrics<character> outline_metrics;
        byte filler;
        panose panose_number;
        uint selection;
        uint type;
        int gradient_rise;
        int gradient_run;
        int italic_angle;
        uint em_square;
        int ascent;
        int descent;
        uint line_gap;
        uint capital_em_height;
        uint x_height;
        irectangle font_box;
        int macintosh_ascent;
        int macintosh_descent;
        uint macintosh_line_gap;
        uint minimum_pixels_per_em;
        ipoint subscript_size;
        ipoint subscript_offset;
        ipoint superscript_size;
        ipoint superscript_offset;
        uint strikeout_size;
        int strikeout_position;
        int underscore_size;
        int underscore_position;
        character* family;
        character* face_name;
        character* style_name;
        character* full_name;
    };

    export struct font_characters
    {
        enum
        {
            ansi = 0,
            _default = 1,
            symbol = 2,
            macintosh = 77,
            shift_jis = 128,
            hang_eul = 129,
            johab = 130,
            gb2312 = 134,
            chinese_big5 = 136,
            greek = 161,
            turkish = 162,
            vietnamese = 163,
            hebrew = 177,
            arabic = 178,
            baltic = 186,
            russian = 204,
            thai = 222,
            east_europe = 238,
            oem = 255
        };
    };

    export struct font_output
    {
        enum
        {
            _default = 0,
            string = 1,
            character = 2,
            stroke = 3,
            true_type = 4,
            device = 5,
            raster = 6,
            true_type_only = 7,
            outline = 8,
            screen_outline = 9
        };
    };

    export struct font_clip
    {
        enum
        {
            _default = 0,
            character = 1,
            stroke = 2,
            mask = 0xf,
            angles_left_handed = 1 << 4,
            true_type_always = 2 << 4,
            embedded = 8 << 4
        };
    };

    export struct font_quality
    {
        enum
        {
            _default = 0,
            draft = 1,
            proof = 2,
            nonantialiased = 3,
            antialiased = 4
        };
    };

    export struct font_pitch
    {
        enum
        {
            _default = 0,
            fixed = 1,
            variable = 2,
            mono = 8
        };
    };

    export struct font_family
    {
        enum
        {
            any = 0 << 4,
            roman = 1 << 4,
            swiss = 2 << 4,
            modern = 3 << 4,
            script = 4 << 4,
            decorative = 5 << 4
        };
    };

    export struct font_weight
    {
        enum
        {
            any = 0,
            thin = 100,
            extra_light = 200,
            light = 300,
            normal = 400,
            medium = 500,
            semi_bold = 600,
            bold = 700,
            extra_bold = 800,
            heavy = 900,
            ultra_light = extra_light,
            regular = normal,
            demi_bold = semi_bold,
            ultra_bold = extra_bold,
            black = heavy
        };
    };

    export template<class character>
        struct logical_font
    {
        int height;
        int width;
        int escapement;
        int orientation;
        int weight;
        byte italic;
        byte underline;
        byte strikeout;
        byte character_set;
        byte output_precision;
        byte clip_precision;
        byte quality;
        byte pitch_and_family;
        character face_name[face_size];

        logical_font()
            : width(0),
            height(0),
            escapement(0),
            orientation(0),
            weight(0),
            italic(0),
            underline(0),
            strikeout(0),
            character_set(0),
            output_precision(0),
            clip_precision(0),
            quality(0),
            pitch_and_family(0)
        {
            for (int i = 0; i < face_size; i++)
                face_name[i] = '\0';
        }
    };

    export template<class character>
        struct logical_font_extended : public logical_font<character>
    {
        enum { culture_latin = 0 };

        character full_name[face_size_full];
        character style[face_size];
        uint version;
        uint style_size;
        uint match;
        uint reserved;
        byte vendor_identity[face_size_vendor];
        uint culture;
        panose panose_font;
    };

    export template<class character>
        struct enumerate_logical_font_simple : public logical_font<character>
    {
        character full_name[face_size_full];
        character style[face_size];
    };

    export template<class character>
        struct enumerate_logical_font : public logical_font<character>
    {
        character full_name[face_size_full];
        character style[face_size];
        character script[face_size];
    };

    export struct standard_font
    {
        enum
        {
            fixed_oem = 10,
            fixed_ansi = 11,
            variable_ansi = 12,
            system = 13,
            device_default = 14,
            fixed_system = 16,
            _default = 17
        };
    };

    export struct wide_character_range
    {
        wchar_t low;
        part glyphs;
    };

    export struct glyph_set
    {
        uint size;
        uint accelerator;
        uint supported;
        uint count;
        wide_character_range ranges[1];
    };

    export  enum { glyph_set_indices_8bit = 0x00000001 };

    export  enum { glyphs_mark_nonexisting = 0x0001 };

    export  enum { axes_maximum = 16 };

    export struct design_vector
    {
        uint reserved;
        uint axes;
        int values[axes_maximum];
    };

    export struct font_resource_type
    {
        enum
        {
            _private = 0x10,
            not_enumerated = 0x20
        };
    };

    export  enum { axis_maximum_name_length = 16 };

    export template<class character>
        struct axis_information
    {
        int minimum;
        int maximum;
        character axis_name[axis_maximum_name_length];
    };

    export template<class character>
        struct axis_list
    {
        uint reserved;
        uint axes;
        axis_information<character> array[axes_maximum];
    };

    export template<class character>
        struct logical_font_design_vector : public enumerate_logical_font<character>,
        public design_vector
    {
        logical_font_design_vector(const enumerate_logical_font<character>& logical_font_copy,
            const design_vector& design_vector_copy)
            : enumerate_logical_font(logical_font_copy),
            design_vector(design_vector_copy) {}
    };

    export template<class character>
        struct enumerate_text_metrics : public new_text_metrics<character>,
        public axis_list<character>
    {
        enumerate_text_metrics(const new_text_metrics<character>& text_metrics_copy,
            const axis_list<character>& axis_list_copy)
            : new_text_metrics(text_metrics_copy),
            axis_list(axis_list_copy) {}
    };

    export struct logical_pen
    {
        uint style;
        idimensions size;
        uint pen_color;
    };

    export struct logical_pen_extended
    {
        uint style;
        uint width;
        uint brush;
        uint pen_color;
        void* hatch;
        uint entries;
        uint array[1];
    };

    export struct standard_pen
    {
        enum
        {
            white = 6,
            black,
            null,
            device
        };
    };

    export struct pen_style
    {
        enum
        {
            solid = 0,
            dash = 1,   //*** -------
            dot = 2,   //*** .......
            dash_dot = 3,   //*** ...
            dash_dot_dot = 4,   //*** ....
            blank = 5,
            inside_frame = 6,
            user = 7,
            alternate = 8,
            end_round = 0x00000000,
            end_square = 0x00000100,
            end_flat = 0x00000200,
            join_round = 0x00000000,
            join_bevel = 0x00001000,
            join_mitre = 0x00002000,
            cosmetic = 0x00000000,
            geometric = 0x00010000,
        };
    };

    export struct logical_brush
    {
        uint style;
        uint color;
        void* hatch;
    };

    export struct standard_brush
    {
        enum
        {
            white = 0,
            light_gray = 1,
            gray = 2,
            dark_gray = 3,
            black = 4,
            null = 5,
            device = 18,
        };
    };

    export struct brush_style
    {
        enum
        {
            solid = 0,
            hollow = 1,
            hatched = 2,
            pattern = 3,
            indexed = 4,
            pattern_bitmap = 5,
            pattern_bitmap_pointer = 6,
            pattern_8x8 = 7,
            pattern_bitmap_8x8 = 8,
            pattern_mono = 9,
        };
    };

    export struct hatch_style
    {
        enum
        {
            horizontal = 0,  //** ----- **
            vertical = 1,  //** ||||| ** 
            diagonal_forward = 2,  //** \\\\\ ** 
            diagonal_backward = 3,  //** ///// ** 
            cross = 4,  //** +++++ ** 
            diagonal_cross = 5,  //** xxxxx ** 
            color_solid = 6,
            color_dithered = 7,
            text_color_solid = 8,
            text_color_dithered = 9,
            background_color_solid = 10,
            background_color_dithered = 11
        };
    };

    export  enum { metafile_system = 0x80000000 };

    export struct meta_command
    {
        enum
        {
            set_background_color = 0x0201,
            set_background_mode = 0x0102,
            set_map_mode = 0x0103,
            set_foreground_mix = 0x0104,
            set_relative_absolute = 0x0105,
            set_polyfill_mode = 0x0106,
            set_block_stretch_mode = 0x0107,
            set_text_character_extra = 0x0108,
            set_text_color = 0x0209,
            set_text_justification = 0x020a,
            set_window_origin = 0x020b,
            set_window_extent = 0x020c,
            set_viewport_origin = 0x020d,
            set_viewport_extent = 0x020e,
            offset_window_origin = 0x020f,
            scale_window_extent = 0x0410,
            offset_viewport_origin = 0x0211,
            scale_viewport_extent = 0x0412,
            draw_line_to = 0x0213,
            move_to = 0x0214,
            exclude_clipping_rectangle = 0x0415,
            intersect_clipping_rectangle = 0x0416,
            draw_arc = 0x0817,
            draw_ellipse = 0x0418,
            flood_fill = 0x0419,
            draw_sector = 0x081a,
            draw_rectangle = 0x041b,
            draw_rounded_rectangle = 0x061c,
            pattern_block = 0x061d,
            save_device_context = 0x001e,
            set_pixel = 0x041f,
            offset_clipping_region = 0x0220,
            text_out = 0x0521,
            bit_block = 0x0922,
            stretch_block = 0x0b23,
            draw_polygon = 0x0324,
            draw_lines = 0x0325,
            escape = 0x0626,
            restore_device_context = 0x0127,
            fill_region = 0x0228,
            frame_region = 0x0429,
            invert_region = 0x012a,
            paint_region = 0x012b,
            select_clipping_region = 0x012c,
            select_object = 0x012d,
            set_text_alignment = 0x012e,
            draw_chord = 0x0830,
            set_mapper_flags = 0x0231,
            text_out_extended = 0x0a32,
            set_bitmap_to_device = 0x0d33,
            select_palette = 0x0234,
            realize_palette = 0x0035,
            animate_palette = 0x0436,
            set_palette_entries = 0x0037,
            draw_polygons = 0x0538,
            resize_palette = 0x0139,
            bitmap_bit_block = 0x0940,
            stretch_bitmap_block = 0x0b41,
            create_bitmap_pattern_brush = 0x0142,
            stretch_bitmap = 0x0f43,
            flood_fill_extended = 0x0548,
            delete_object = 0x01f0,
            create_palette = 0x00f7,
            create_pattern_brush = 0x01f9,
            create_pen_indirect = 0x02fa,
            create_font_indirect = 0x02fb,
            create_brush_indirect = 0x02fc,
            create_region = 0x06ff
        };
    };

    export struct metaold
    {
        uint size;
        part function;
        part parameter[1];

        part& operator[](uint index) { return parameter[index]; }
    };

    export struct metatype
    {
        enum
        {
            header = 1,
            draw_splines = 2,
            draw_polygon = 3,
            draw_lines = 4,
            draw_splines_to = 5,
            draw_lines_to = 6,
            draw_polylines = 7,
            draw_polygons = 8,
            set_window_extent = 9,
            set_window_origin = 10,
            set_viewport_extent = 11,
            set_viewport_origin = 12,
            set_brush_origin = 13,
            end_of_file = 14,
            set_pixel_v = 15,
            set_mapper_flags = 16,
            set_mapping_mode = 17,
            set_background_mode = 18,
            set_polyfill_mode = 19,
            set_foreground_mix = 20,
            set_block_stretch_mode = 21,
            set_text_alignment = 22,
            set_color_adjustment = 23,
            set_text_color = 24,
            set_background_color = 25,
            offset_clipping_region = 26,
            set_window_position = 27,
            set_metaregion = 28,
            exclude_clipping_rectangle = 29,
            intersect_clipping_rectangle = 30,
            scale_viewport_extent = 31,
            scale_window_extent = 32,
            save = 33,
            restore = 34,
            set_world_transform = 35,
            modify_world_transform = 36,
            select_object = 37,
            create_pen = 38,
            create_brush_indirect = 39,
            delete_object = 40,
            draw_angle_arc = 41,
            draw_ellipse = 42,
            drawrectangle = 43,
            draw_roundedrectangle = 44,
            draw_arc = 45,
            draw_chord = 46,
            draw_sector = 47,
            select_palette = 48,
            create_palette = 49,
            set_palette_entries = 50,
            resize_palette = 51,
            realize_palette = 52,
            flood_fill_extended = 53,
            draw_line = 54,
            set_arc = 55,
            polydraw = 56,
            set_arc_direction = 57,
            set_mitre_limit = 58,
            begin_path = 59,
            end_path = 60,
            close_figure = 61,
            fill_path = 62,
            stroke_and_fill_path = 63,
            stroke_path = 64,
            flatten_path = 65,
            widen_path = 66,
            select_clipping_path = 67,
            cancel_path = 68,
            comment = 70,
            fill_region = 71,
            frame_region = 72,
            invert_region = 73,
            paint_region = 74,
            select_clipping_region = 75,
            bit_block_transfer = 76,
            stretch_bit_block_transfer = 77,
            mask_bit_block_transfer = 78,
            parallelogram_bit_block_transfer = 79,
            bits_to_device = 80,
            stretch_bits = 81,
            create_font_indirect_wide = 82,
            text_out_extended_normal = 83,
            text_out_extended_wide = 84,
            create_mono_brush = 93,
            create_bitmap_pattern_brush = 94,
            create_pen_extended = 95,
            polytext_out_normal = 96,
            polytext_out_wide = 97,
            set_image_color_mode = 98,
            create_color_space = 99,
            set_color_space = 100,
            delete_color_space = 101,
            gls_record = 102,
            gls_bounded_record = 103,
            pixel_format = 104,
            draw_escape = 105,
            draw_escape_extended = 106,
            start_document = 107,
            small_text_out = 108,
            force_ufi_mapping = 109,
            namedescape = 110,
            correct_color_palette = 111,
            image_color_profile_set_normal = 112,
            image_color_profile_set_wide = 113,
            alpha_blend = 114,
            alpha_bitmap_blend = 115,
            transparent_bit_block_transfer = 116,
            transparent_bitmap_block_transfer = 117,
            gradient_fill = 118,
            set_linked_ufis = 119,
            set_text_justification = 120
        };
    };

    export struct meta
    {
        uint type;
        uint size;
    };

    export  typedef int(__stdcall* metafile_callback)(handle h,
        handle* handle_table,
        meta* record,
        int objects,
        parameter callback_parameter);

    export struct meta_picture
    {
        int mapping_mode;
        idimensions extent;
        handle metafile;
    };

    export struct meta_header_old
    {
        part type;
        part header_size;
        part version;
        uint size;
        part objects;
        uint record_maximum;
        part parameters;
    };

    export struct meta_header
    {
        uint type;
        uint size;
        irectangle bounds;
        irectangle frame;
        uint signature;
        uint version;
        uint bytes;
        uint records;
        part handles;
        part reserved;
        uint description;
        uint description_offset;
        uint palette_entries;
        idimensions device;
        idimensions millimeters;
        uint pixel_format_size;
        uint pixel_format_offset;
        bool open__language;
    };

    export struct meta_text
    {
        ipoint reference;
        uint characters;
        uint string_offset;
        uint options;
        irectangle text;
        uint character_increments_offset;
    };

    //typedef meta meta_cancel_path;
    //typedef meta meta_begin_path;
    //typedef meta meta_end_path;
    //typedef meta meta_widen_path;
    //typedef meta meta_close_figure;
    //typedef meta meta_flatten_path;
    //typedef meta meta_widen_path;

    export  typedef meta meta_set_metaregion;
    export  typedef meta meta_save_device_context;
    export  typedef meta meta_realize_palette;

    export struct metamode : public meta
    {
        uint mode;
    };

    export struct meta_set_background_mode : public meta
    {
        uint mode;
    };

    export struct meta_set_mapping_mode : public meta
    {
        uint mode;
    };

    export struct meta_set_polyfill_mode : public meta
    {
        uint mode;
    };

    export struct meta_set_foreground_mix : public meta
    {
        uint mode;
    };

    export struct meta_set_block_stretch_mode : public meta
    {
        uint mode;
    };

    export struct meta_set_image_color_mode : public meta
    {
        uint mode;
    };

    export struct meta_set_text_alignment : public meta
    {
        uint mode;
    };

    export struct meta_set_mitre_limit : public meta
    {
        float mitre_limit;
    };

    export struct meta_restore_device_context : public meta
    {
        int relative;
    };

    export struct meta_set_arc_direction : public meta
    {
        uint arc_direction;
    };

    export struct meta_set_mapper_flags : public meta
    {
        uint flags;
    };

    export struct meta_set_text_color : public meta
    {
        icolor text_color;
    };

    export struct meta_set_background_color : public meta
    {
        icolor background_color;
    };

    export struct meta_select_object : public meta
    {
        uint object;
    };

    export struct meta_delete_object : public meta
    {
        uint object;
    };

    export struct meta_select_color_space : public meta
    {
        uint color_space;
    };

    export struct meta_delete_color_space : public meta
    {
        uint color_space;
    };

    export struct meta_select_palette : public meta
    {
        uint palette;
    };

    export struct meta_resize_palette : public meta
    {
        uint palette;
        uint entries;
    };

    export struct meta_set_palette_entries : public meta
    {
        uint palette;
        uint start;
        uint entries;
        palette_entry array[1];

        palette_entry& operator[](uint index) { return array[index]; }
    };

    export struct meta_set_color_adjustment : public meta
    {
        color_adjustment color_adjustment_set;
    };

    export struct metacomment : public meta
    {
        uint size;
        byte data[1];

        byte& operator[](uint index) { return data[index]; }
    };

    export struct meta_end_of_file : public meta
    {
        uint palette_entries;
        uint palette_entries_offset;
        uint last_size;
    };

    export struct meta_draw_line : public meta
    {
        ipoint end;
    };

    export struct meta_move : public meta
    {
        ipoint move;
    };

    export struct meta_offset_clipping_region : public meta
    {
        ipoint offset;
    };

    export struct meta_fill_path : public meta
    {
        irectangle bounds;
    };

    export struct meta_stroke_path : public meta
    {
        irectangle bounds;
    };

    export struct meta_stroke_and_fill_path : public meta
    {
        irectangle bounds;
    };

    export struct meta_exclude_clipping_rectangle : public meta
    {
        irectangle clip;
    };

    export struct meta_intersect_clipping_rectangle : public meta
    {
        irectangle clip;
    };

    export struct meta_set_viewport_origin : public meta
    {
        ipoint origin;
    };

    export struct meta_set_window_origin : public meta
    {
        ipoint origin;
    };

    export struct meta_set_brush_origin : public meta
    {
        ipoint origin;
    };

    export struct meta_set_viewport_extent : public meta
    {
        idimensions extent;
    };

    export struct meta_set_window_extent : public meta
    {
        idimensions extent;
    };

    export struct meta_scale_viewport_extent : public meta
    {
        int numerator_x;
        int denominator_x;
        int numerator_y;
        int denominator_y;
    };

    export struct meta_scale_window_extent : public meta
    {
        int numerator_x;
        int denominator_x;
        int numerator_y;
        int denominator_y;
    };

    export struct meta_set_world_transform : public meta
    {
        xform world_transform;
    };

    export struct meta_modify_world_transform : public meta
    {
        xform world_transform;
        uint mode;
    };

    export struct meta_set_pixel : public meta
    {
        ipoint pixel;
        icolor new_color;
    };

    export struct meta_flood_fill : public meta
    {
        ipoint start;
        icolor flood;
        uint mode;
    };

    //struct meta_draw_ellipse : public meta
    //{
    //  irectangle box;
    //};

    //struct meta_drawrectangle : public meta
    //{
    //  irectangle box;
    //};

    //struct meta_draw_roundedrectangle : public meta
    //{
    //  irectangle box;
    //  idimensions corner;
    //};

    export struct meta_draw_arc : public meta
    {
        irectangle box;
        ipoint start;
        ipoint end;
    };

    export struct meta_draw_arc_to : public meta
    {
        irectangle box;
        ipoint start;
        ipoint end;
    };

    export struct meta_draw_chord : public meta
    {
        irectangle box;
        ipoint start;
        ipoint end;
    };

    export struct meta_draw_sector : public meta
    {
        irectangle box;
        ipoint start;
        ipoint end;
    };

    export struct meta_draw_angle_arc : public meta
    {
        ipoint center;
        uint radius;
        float start;
        float sweep;
    };

    export struct meta_draw_lines : public meta
    {
        irectangle bounds;
        uint count;
        ipoint points[1];
    };

    export struct meta_draw_lines_to : public meta
    {
        irectangle bounds;
        uint count;
        ipoint points[1];
    };

    export struct meta_draw_splines : public meta
    {
        irectangle bounds;
        uint count;
        ipoint points[1];
    };

    export struct meta_draw_splines_to : public meta
    {
        irectangle bounds;
        uint count;
        ipoint points[1];

        ipoint& operator[](uint index) { return points[index]; }
    };

    export struct meta_draw_polygon : public meta
    {
        irectangle bounds;
        uint count;
        ipoint points[1];

        ipoint& operator[](uint index) { return points[index]; }
    };

    export struct meta_polydraw : public meta
    {
        irectangle bounds;
        uint count;
        ipoint points[1];
        byte types[1];
    };

    //struct meta_draw_polylines : public meta
    //{
    //  irectangle bounds;
    //  uint polygons;
    //  uint total;
    //  uint counts[1];
    //  ipoint points[1];
    //};

    //typedef meta_draw_polylines meta_draw_polygons;

    export struct meta_invert_region : public meta
    {
        irectangle bounds;
        uint size;
        byte region_data[1];

        byte& operator[](uint index) { return region_data[index]; }
    };

    export  typedef meta_invert_region metapaint_region;

    export struct meta_fill_region : public meta
    {
        irectangle bounds;
        uint size;
        uint brush_index;
        byte region_data[1];
    };

    export struct meta_frame_region : public meta
    {
        irectangle bounds;
        uint size;
        uint brush_index;
        idimensions stroke;
        byte region_data[1];
    };

    export struct meta_gradient_fill : public meta
    {
        irectangle bounds;          // inclusive-inclusive bounds in device units
        uint vertices;
        uint figures;
        uint mode;
        trivertex vertex_array[1];
    };

    export struct meta_select_clipping_region : public meta
    {
        uint size;
        uint mode;
        byte region_data[1];
    };

    export struct meta_text_out_extended : public meta
    {
        irectangle bounds;
        uint _mode;
        float scale_x;
        float scale_y;
        meta_text meta_text_out;
    };

    export struct meta_polytext_out : public meta
    {
        irectangle bounds;
        uint _mode;
        float scale_x;
        float scale_y;
        int strings;
        meta_text array_meta_text[1];
    };

    export struct metabit_block_transfer : public meta
    {
        irectangle bounds;
        ipoint position;
        idimensions size;
        uint raster;
        ipoint source;
        xform source_transform;
        icolor source_background_color;
        uint source_usage;
        uint source_bitmap_information_offset;
        uint source_bitmap_information;
        uint source_bits_offset;
        uint source_bits;
    };

    export struct meta_stretch_bit_block_transfer : public metabit_block_transfer
    {
        idimensions source;
    };

    export struct metamask_bit_block_transfer : public metabit_block_transfer
    {
        int mask_x;
        int mask_y;
        uint mask_usage;
        uint mask_bitmap_information_offset;
        uint mask_bitmap_information;
        uint mask_bits_offset;
        uint mask_bits;
    };

    export struct meta_parallelogram_bit_block_transfer : public meta
    {
        irectangle bounds;
        ipoint destination[3];
        ipoint position;
        idimensions size;
        xform source_transform;
        icolor source_background_color;
        uint source_usage;
        uint source_bitmap_information_offset;
        uint source_bitmap_information;
        uint source_bits_offset;
        uint source_bits;
        ipoint mask;
        uint mask_usage;
        uint mask_bitmap_information_offset;
        uint mask_bitmap_information;
        uint mask_bits_offset;
        uint mask_bits;
    };

    export struct meta_bitmap_bits_to_device : public meta
    {
        irectangle bounds;
        int destination_x;
        int destination_y;
        int source_x;
        int source_y;
        int source_width;
        int source_height;
        uint source_bitmap_information_offset;
        uint source_bitmap_information;
        uint source_bits_offset;
        uint source_bits;
        uint source_usage;
        uint start;
        uint scans;
    };

    export struct meta_stretch_bitmap_bits : public meta
    {
        irectangle bounds;
        ipoint destination;
        ipoint position;
        idimensions source;
        uint source_bitmap_information_offset;
        uint source_bitmap_information;
        uint source_bits_offset;
        uint source_bits;
        uint source_usage;
        uint start;
        uint scans;
        uint raster;
        ipoint target_position;
    };

    export struct meta_alpha_blend : public meta
    {
        irectangle bounds;
        ipoint position;
        idimensions size;
        uint raster;
        ipoint source;
        xform source_transform;
        icolor source_background_color;
        uint source_usage;
        uint source_bitmap_information_offset;
        uint source_bitmap_information;
        uint source_bits_offset;
        uint source_bits;
        idimensions source_size;
    };

    export struct meta_transparent_bit_block_transfer : public meta
    {
        irectangle bounds;
        ipoint destination;
        idimensions destination_size;
        uint raster;
        ipoint source;
        xform source_transform;
        icolor source_background_color;
        uint source_usage;
        uint source_bitmap_information_offset;
        uint source_bitmap_information;
        uint source_bits_offset;
        uint source_bits;
        idimensions source_size;
    };

    export template<class character>
        struct meta_create_font_indirect : public meta
    {
        uint font_index;
        logical_font<character> logical_font_create;
    };

    export struct meta_create_palette : public meta
    {
        uint palette_index;
        logical_palette logical_palette_create;
    };

    export template <class character>
        struct meta_create_logical_color_space : public meta
    {
        uint color_space;
        logical_color_space<character> logical_color_space_create;
    };

    export struct meta_create_pen : public meta
    {
        uint pen_index;
        logical_pen logical_pen_create;
    };

    export struct meta_create_pen_extended : public meta
    {
        uint pen_index;
        uint bitmap_information_offset;
        uint bitmap_information;
        uint bits_offset;
        uint bits;
        logical_pen_extended logical_pen_create;
    };

    export struct meta_create_brush_indirect : public meta
    {
        uint brush_index;
        logical_brush logical_brush_create;
    };

    export struct meta_create_mono_brush : public meta
    {
        uint brush_index;
        uint usage;
        uint bitmap_information_offset;
        uint bitmap_information;
        uint bits_offset;
        uint bits;
    };

    export  typedef meta_create_mono_brush meta_create_bitmap_pattern_brush;

    export struct metafile_signature
    {
        enum
        {
            enhanced_metafile_mac = 0x464d4520,
            enhanced_metafile = 0x20454d46
        };
    };

    export struct meta_format
    {
        uint signature;
        uint version;
        uint data;
        uint data_offset;
    };

    export struct meta_pixel_format : public meta
    {
        pixel_format_descriptor pixel_descriptor;
    };

    export  enum { set_image_color_profile_embedded = 0x00000001 };

    export struct meta_set_image_color_profile : public meta
    {
        uint flags;
        uint length;
        uint size;
        byte data[1];
    };

    export struct vector_text_option
    {
        enum
        {
            opaque = 0x0002,
            clipped = 0x0004,
            glyph_index = 0x0010,
            right_to_left = 0x0080,
            numbers_local = 0x0400,
            numbers_latin = 0x0800,
            language_ignore = 0x1000
        };
    };

    export struct draw_state_type
    {
        enum
        {
            complex = 0x0000,
            text = 0x0001,
            text_prefix = 0x0002,
            icon = 0x0003,
            bitmap = 0x0004
        };
    };

    export struct draw_state_appearance
    {
        enum
        {
            normal = 0x0000,
            _union = 0x0010,
            disabled = 0x0020,
            mono = 0x0080,
            right = 0x8000
        };
    };

    export struct point_type
    {
        enum
        {
            close_figure = 0x01,
            line = 0x02,
            spline = 0x04,
            move = 0x06
        };
    };

    export struct palette_use
    {
        enum
        {
            error = 0,
            _static,
            nonstatic,
            nonstatic256
        };
    };

    export struct _object_type
    {
        enum
        {
            pen = 1,
            brush = 2,
            device_context = 3,
            metafile_device_context = 4,
            palette = 5,
            font = 6,
            bitmap = 7,
            region = 8,
            metafile = 9,
            memory_device_context = 10,
            pen_extended = 11,
            enhanced_metafile_device_context = 12,
            enhanced_metafile = 13
        };
    };

    export struct glyph_type
    {
        enum
        {
            metrics = 0,
            image = 0,
            bitmap = 1,
            outline = 2,
            spline = 3
        };
    };

    export struct glyph_format
    {
        enum
        {
            image = 1,
            gray2 = 4,
            gray4,
            gray8
        };
    };

    export struct glyph_metrics
    {
        uint glyph;
        idimensions box;
        ipoint origin;
        part x_increment;
        part y_increment;
    };

    export struct glyph_outline
    {
        uint glyph;
        uint size;
        void* buffer;

        operator uint() const { return size; }
    };

    export struct glyph_bitmap
    {
        uint glyph;
        uint size;
        void* buffer;
        imatrix matrix;
        uint format;

        operator uint() const { return size; }
    };

    export struct true_type_polygon
    {
        uint size;
        uint type;
        ipoint start;             // these points are fixed points
    };                            // the x and y coordinates are fixed decimals

    export struct true_type_polycurve
    {
        part type;
        part count;             // these points are fixed points
        ipoint points[1];      // the x and y coordinates are fixed decimals

        ipoint& operator[](uint index) { return points[index]; }
    };

    export struct _mode
    {
        enum { compatible = 1, advanced };
    };

    export struct font_data
    {
        uint metric;
        uint offset;
        uint size;
        void* buffer;
    };

    export  typedef int(__stdcall* enumerate_font_simple)(const enumerate_logical_font_simple<wchar_t>*,
        const void*,
        uint,
        parameter);

    export  typedef int(__stdcall* enumerate_font)(const enumerate_logical_font<wchar_t>*,
        const void*,
        uint,
        parameter);

    export  typedef int(__stdcall* metafile_callback)(handle h,
        handle* handle_table,
        meta* record,
        int objects,
        parameter callback_parameter);

    export template<class character>
        struct font_families_simple
    {
        character* family;
        enumerate_font_simple callback;
        parameter parameter_enumerate;
        int result;
    };

    export template<class character>
        struct font_families
    {
        const logical_font<character>* pointer;
        enumerate_font callback;
        parameter parameter_enumerate;
        int result;
    };

    export  enum { font_mapper_maximum = 10 };

    export struct _escape
    {
        enum
        {
            new_frame = 1,
            cancel_document = 2,
            next_band = 3,
            set_color_table = 4,
            get_color_table = 5,
            flush_output = 6,
            draft_mode = 7,
            query_support = 8,
            set_cancel_document_function = 9,
            start_document = 10,
            end_document = 11,
            get_physical_page_size = 12,
            get_printing_offset = 13,
            get_scaling_factor = 14,
            comment = 15,
            get_pen_width = 16,
            set_pen_width = 17,
            select_paper_source = 18,
            device_data = 19,
            pass_through = 19,
            get_technology = 20,
            set_lineend = 21,
            set_line_join = 22,
            set_mitre_limit = 23,
            band_information = 24,
            draw_pattern_rectangle = 25,
            get_vector_pen_size = 26,
            get_vector_brush_size = 27,
            enable_duplex = 28,
            get_paper_bins = 29,
            printer_orientation = 30,
            enable_paper_bins = 31,
            set_bitmap_scaling = 32,
            encapsulated_postscript_printing = 33,
            enumerate_paper_metrics = 34,
            paper_metrics = 35,
            postscript_data = 37,
            ignore_postscript = 38,
            mouse_trails = 39,
            get_device_units = 42,
            get_extended_text_metrics = 256,
            get_extent_table = 257,
            get_close_pair_table = 258,
            get_close_pair_table_tracking = 259,
            text_out = 512,
            get_face_name = 513,
            download_face = 514,
            enable_relative_widths = 768,
            enable_close_pairs = 769,
            set_close_pair_tracking = 770,
            set_justification = 771,
            set_characters = 772,
            stretch_block = 2048,
            screen_parameters = 3072,
            get_bitmap_support = 3073,
            begin_path = 4096,
            clip_to_path = 4097,
            end_path = 4098,
            device_capabilities = 4099,
            ctm_restore = 4100,
            ctm_save = 4101,
            set_arc_direction = 4102,
            set_background_color = 4103,
            set_polymode = 4104,
            set_screen_angle = 4105,
            set_spread = 4106,
            ctm_transform = 4107,
            set_clip_box = 4108,
            set_bounds = 4109,
            set_mirror_mode = 4110,
            open_channel = 4110,
            download_header = 4111,
            close_channel = 4112,
            postscript_pass_through = 4115,
            postscript_encapsulated = 4116,
            postscript_identify = 4117,
            postscript_injection = 4118
        };
    };

    export struct postscript_identity
    {
        enum
        {
            graphics = 0,
            postscript = 1
        };
    };

    export struct postscript_injection_point
    {
        enum
        {
            begin_stream = 0,
            adobe = 1,
            comments = 2,
            begin_defaults = 3,
            end_defaults = 4,
            begin_prolog = 5,
            end_prolog = 6,
            begin_setup = 7,
            end_setup = 8,
            end_page_comments = 9,
            begin_page_setup = 10,
            end_page_setup = 11,
            show_page = 12,
            page_trailer = 13,
            trailer = 14,
            end_of_file = 15,
            end_stream = 16,
            save_vm = 17,
            restore_vm = 18,
            document_resource_needed = 19,
            document_resource_supplied = 20,
            pages = 21,
            page_order = 22,
            orientation = 23,
            bounding_box = 24,
            page_number = 25,
            page_box = 26
        };
    };

    export struct postscript_inject_data
    {
        uint data;
        uint position;
        uint flags;
        uint reserved;
    };

    export struct postscript_add
    {
        enum
        {
            append = 0,
            replace = 1
        };
    };

    export struct postscript_inject
    {
        enum
        {
            document_needed_resource = 19,
            document_supplied_resource = 20,
            pages = 21,
            page_order = 22,
            orientation = 23,
            bounding_box = 24,
            page_number = 25,
            page_box = 26,
            maximum = 27
        };
    };

    export  enum { font_language_mask = 0x103b };

    export struct bitmap_support
    {
        enum // for escape::get_bitmap_support
        {
            set_bits = 1,
            get_bits = 2,
            to_screen = 4,
            stretch = 8
        };
    };

    export struct fill_type
    {
        enum { border = 0, surface };
    };

    export struct frame_type
    {
        enum
        {
            caption = 1,
            menu = 2,
            scroll = 3,
            button = 4,
            popup = 5
        };
    };

    export struct frame_caption
    {
        enum
        {
            close = 0x0000,
            minimize = 0x0001,
            maximize = 0x0002,
            restore = 0x0003,
            help = 0x0004
        };
    };

    export struct frame_menu
    {
        enum
        {
            arrow = 0x0000,
            check = 0x0001,
            bullet = 0x0002,
            arrow_right = 0x0004
        };
    };

    export struct frame_scroll
    {
        enum
        {
            up = 0x0000,
            down = 0x0001,
            left = 0x0002,
            right = 0x0003,
            combobox = 0x0005,
            size_grip = 0x0008,
            size_grip_right = 0x0010
        };
    };

    export struct frame_button
    {
        enum
        {
            check = 0x0000,
            radio_image = 0x0001,
            radio_mask = 0x0002,
            radio = 0x0004,
            three_state = 0x0008,
            push = 0x0010,
            inactive = 0x0100,
            pushed = 0x0200,
            checked = 0x0400,
            transparent = 0x0800,
            hot = 0x1000,
            adjust_rectangle = 0x2000,
            flat = 0x4000,
            mono = 0x8000
        };
    };

    export struct edge_type
    {
        enum
        {
            outer_raised = 0x0001,
            outer_sunken = 0x0002,
            inner_raised = 0x0004,
            inner_sunken = 0x0008,
            raised = outer_raised | inner_raised,
            sunken = outer_sunken | inner_sunken,
            etched = outer_sunken | inner_raised,
            bump = outer_raised | inner_sunken
        };
    };

    export struct edge_flag
    {
        enum
        {
            left = 0x0001,
            top = 0x0002,
            right = 0x0004,
            bottom = 0x0008,
            diagonal = 0x0010,
            middle = 0x0800,
            soft = 0x1000,
            adjust = 0x2000,
            flat = 0x4000,
            mono = 0x8000,
            rectangle = left | top | right | bottom
        };
    };

    export struct windows_metafile_comment
    {
        uint identity;
        uint comment;
        uint version;
        uint checksum;
        uint flags;
        uint data;
    };

    export struct begin_group_comment
    {
        uint identity;
        uint comment;
        irectangle output;
        uint description;
    };

    export struct end_group_comment
    {
        uint identity;
        uint comment;
    };

    export struct multiple_formats_comment
    {
        uint identity;
        uint comment;
        irectangle output;
        uint count;
        meta_format formats[1];
    };

    export struct _comment
    {
        enum
        {
            identifier = 0x43494447,
            windows_metafile = 0x80000001,
            begin_group = 0x00000002,
            end_group = 0x00000003,
            multiple_formats = 0x40000004
        };
    };

    export struct bounds_flag
    {
        enum
        {
            reset = 0x0001,
            accumulate = 0x0002,
            set = 0x0003,
            enable = 0x0004,
            disable = 0x0008
        };
    };

    export  enum { line_no_position = 0, line_position = 1 };

    export struct arc_direction
    {
        enum { counter_clockwise = 1, clockwise = 2 };
    };

    export struct stretch_block_mode
    {
        enum
        {
            _and = 1,
            _or = 2,
            drop = 3,
            halftone = 4
        };
    };

    export struct mix
    {
        enum
        {
            black = 1,
            not_merge_pen = 2,
            mask_not_pen = 3,
            not_copy_pen = 4,
            mask_pen_not = 5,
            _not = 6,
            exclusive_or_pen = 7,
            not_mask_pen = 8,
            mask_pen = 9,
            not_exclusive_or_pen = 10,
            no_operation = 11,
            merge_not_pen = 12,
            copy_pen = 13,
            merge_pen_not = 14,
            merge_pen = 15,
            white = 16
        };
    };

    export struct background
    {
        enum
        {
            transparent = 1,
            opaque = 2
        };
    };

    export  typedef bool(__stdcall* cancel_document_callback)(handle device,
        int error);

    export  typedef bool(__stdcall* draw_state_callback)(handle device,
        parameter parameter2,
        parameter parameter1,
        int width,
        int height);

    export  typedef bool(__stdcall* gray_text_callback)(handle device,
        parameter string,
        int length);

    export struct unit
    {
        enum
        {
            pixel = 1,
            low_metric,
            high_metric,
            low_english,
            high_english,
            twips,
            isotropic,
            anisotropic,
            last
        };
    };

    export struct modify_transform_flag
    {
        enum
        {
            identity = 1,
            multiply_left = 2,
            multiply_right = 3
        };
    };

    export struct capability_technology
    {
        enum
        {
            plotter = 0,
            display = 1,
            printer = 2,
            camera = 3,
            character = 4,
            metafile = 5,
            display_file = 6
        };
    };

    export struct capability_curve
    {
        enum
        {
            none = 0,
            circles = 1,
            sector = 2,
            chord = 4,
            ellipses = 8,
            wide = 16,
            styled = 32,
            wide_styled = 64,
            interiors = 128,
            rectangle_round = 256
        };
    };

    export struct capability_line
    {
        enum
        {
            none = 0,
            poly = 2,
            marker = 4,
            marker_poly = 8,
            wide = 16,
            styled = 32,
            wide_styled = 64,
            interiors = 128
        };
    };

    export struct capability_poly
    {
        enum
        {
            none = 0,
            polygon = 1,
            rectangle = 2,
            winding_polygon = 4,
            trapezoid = 4,
            scan_line = 8,
            wide = 16,
            styled = 32,
            wide_styled = 64,
            interiors = 128,
            polypolygon = 256,
            paths = 512
        };
    };

    export struct capability_text
    {
        enum
        {
            output_character = 0x00000001,
            output_stroke = 0x00000002,
            clip_stroke = 0x00000004,
            rotate90 = 0x00000008,
            rotate_any = 0x00000010,
            scale_independent = 0x00000020,
            scale_double = 0x00000040,
            scale_integer = 0x00000080,
            scale_continuous = 0x00000100,
            embolden = 0x00000200,
            italic = 0x00000400,
            underline = 0x00000800,
            strikeout = 0x00001000,
            raster = 0x00002000,
            vector = 0x00004000,
            no_scroll = 0x00010000
        };
    };

    export struct capability_clip
    {
        enum
        {
            none = 0,
            rectangle = 1,
            region = 2
        };
    };

    export struct capability_raster
    {
        enum
        {
            none = 0,
            bit_block = 1,
            banding = 2,
            scaling = 4,
            bitmap64 = 8,
            _output = 0x0010,
            _state = 0x0020,
            save_bitmap = 0x0040,
            bitmap_bits = 0x0080,
            palette = 0x0100,
            device_bits = 0x0200,
            big_font = 0x0400,
            bitmap_stretch = 0x0800,
            flood_fill = 0x1000,
            block_stretch = 0x2000,
            op_dx_output = 0x4000,
            _device_bits = 0x8000
        };
    };

    export struct capability_shade_and_blend
    {
        enum
        {
            none = 0x00000000,
            constant_alpha = 0x00000001,
            pixel_alpha = 0x00000002,
            premultiply_alpha = 0x00000004,
            gradient_rectangle = 0x00000010,
            gradient_triangle = 0x00000020
        };
    };

    export struct capability
    {
        enum
        {
            driver = 0,
            technology = 2,
            horizontal_size = 4,
            vertical_size = 6,
            horizontal_resolution = 8,
            vertical_resolution = 10,
            bits_pixel = 12,
            planes = 14,
            brushes = 16,
            pens = 18,
            markers = 20,
            fonts = 22,
            colors = 24,
            physical_size = 26,
            curve = 28,
            line = 30,
            polygon = 32,
            text = 34,
            clip = 36,
            raster = 38,
            aspect_x = 40,
            aspect_y = 42,
            aspect_xy = 44,
            shading_and_blending = 45,
            logical_pixels_x = 88,
            logical_pixels_y = 90,
            palette_size = 104,
            palette_reserved = 106,
            color_resolution = 108,
            physical_width = 110,
            physical_height = 111,
            physical_offset_x = 112,
            physical_offset_y = 113,
            scaling_factor_x = 114,
            scaling_factor_y = 115,
            vertical_refresh = 116,
            desktop_vertical_resolution = 117,
            desktop_horizontal_resolution = 118,
            block_alignment = 119
        };
    };

    export struct caption_flag
    {
        enum
        {
            active = 0x0001,
            small_capitals = 0x0002,
            icon = 0x0004,
            text = 0x0008,
            button = 0x0010,
            gradient = 0x0020
        };
    };

    export struct text_alignment_flag
    {
        enum
        {
            position_no_update = 0,
            position_update = 1,
            left = 0,
            right = 2,
            center = 6,
            top = 0,
            bottom = 8,
            baseline = 24,
            right_to_left = 256,
            mask = baseline | center | position_update,
            vertical_baseline = baseline,
            vertical_left = bottom,
            vertical_right = top,
            vertical_center = center,
            vertical_bottom = right,
            vertical_top = left
        };
    };

    export struct draw_text_format
    {
        enum
        {
            top = 0x00000000,
            left = 0x00000000,
            center = 0x00000001,
            right = 0x00000002,
            vertical_center = 0x00000004,
            bottom = 0x00000008,
            word_break = 0x00000010,
            single_line = 0x00000020,
            expand_tabs = 0x00000040,
            tabstop = 0x00000080,
            no_clip = 0x00000100,
            external_leading = 0x00000200,
            calculate_rectangle = 0x00000400,
            no_prefix = 0x00000800,
            _internal = 0x00001000,
            edit_control = 0x00002000,
            path_ellipsis = 0x00004000,
            end_ellipsis = 0x00008000,
            modify_string = 0x00010000,
            right_to_left = 0x00020000,
            wordellipsis = 0x00040000
        };
    };

    export struct character_placement_flag
    {
        enum
        {
            double_byte = 0x0001,
            reorder = 0x0002,
            kerning = 0x0008,
            glyph_shape = 0x0010,
            ligature = 0x0020,
            diacritic = 0x0100,
            kashida = 0x0400,
            error = 0x8000,
            justify = 0x00010000,
            extraglyphs = 0x00040000,
            classification = 0x00080000,
            maximum_extent = 0x00100000,
            justify_in = 0x00200000,
            display_zwg = 0x00400000,
            symbol_swap_off = 0x00800000,
            numeric_override = 0x01000000,
            neutral_override = 0x02000000,
            numerics_latin = 0x04000000,
            numerics_local = 0x08000000,
        };
    };

    export struct character_class
    {
        enum
        {
            latin = 1,
            hebrew = 2,
            arabic = 2,
            neutral = 3,
            local_number = 4,
            latin_number = 5,
            latin_numeric_terminator = 6,
            latin_numeric_separator = 7,
            numeric_separator = 8,
            prebound_left_to_right = 0x80,
            prebound_right_to_left = 0x40,
            postbound_left_to_right = 0x20,
            postbound_right_to_left = 0x10
        };
    };

    export struct glyph_linkage
    {
        enum
        {
            before = 0x8000,
            after = 0x4000
        };
    };

    export template<class character>
        struct polytext_information
    {
        ipoint position;
        uint size;
        const character* string;
        uint flags;
        irectangle bounds;
        int* increments;
    };

    export struct draw_text_parameters
    {
        uint size;
        int tab;
        int left;
        int right;
        uint length;
    };

    export template<class character>
        struct character_placement
    {
        uint size;
        character* output;
        uint* order;
        int* increments;
        int* caret;
        character* class_name;
        wchar_t* glyphs;
        uint count;
        int fit;
    };

    export struct close_pair
    {
        part first;
        part second;
        int amount;
    };

    export struct paint_icon_flag
    {
        enum
        {
            mask = 0x0001,
            image = 0x0002,
            normal = 0x0003,
            compatible = 0x0004,
            default_size = 0x0008
        };
    };

    export struct document_information_flag
    {
        enum
        {
            application_banding = 0x00000001,
            read_raster_destination = 0x00000002
        };
    };

    export template<class character>
        struct document_information
    {
        int size;
        const character* document;
        const character* file;
        const character* data;
        uint type;
    };

    export struct _device_mode
    {
        enum
        {
            update = 1,
            copy = 2,
            prompt = 4,
            modify = 8,
            in_buffer = modify,
            in_prompt = prompt,
            out_buffer = copy,
            out_default = update
        };
    };

    export struct spooler_error
    {
        enum
        {
            error = -1,
            cancel_by_application = -2,
            cancel_by_user = -3,
            out_of_disk_space = -4,
            out_of_memory = -5,
            not_reported = 0x4000
        };
    };

    export struct text_option
    {
        enum
        {
            grayed = 0x0001,
            opaque = 0x0002,
            clipped = 0x0004
        };
    };

    export struct coordinate_mode
    {
        enum
        {
            absolute = 1,
            relative = 2
        };
    };

    export struct font_type
    {
        enum
        {
            raster = 0x1,
            device = 0x2,
            true_type = 0x4
        };
    };

    export struct device_extended
    {
        enum
        {
            window = 0x00000001,
            cache = 0x00000002,
            no_reset_attributes = 0x00000004,
            clip_children = 0x00000008,
            clip_siblings = 0x00000010,
            clip_parent = 0x00000020,
            exclude_region = 0x00000040,
            intersect_region = 0x00000080,
            exclude_update = 0x00000100,
            intersect_update = 0x00000200,
            lock_window_update = 0x00000400,
            no_recompute = 0x00100000,
            validate = 0x00200000
        };
    };

    export struct capability_index
    {
        enum
        {
            members = 1,
            papers = 2,
            paper_size = 3,
            minimum_extent = 4,
            maximum_extent = 5,
            bins = 6,
            duplex = 7,
            size = 8,
            extra = 9,
            version = 10,
            driver = 11,
            bin_names = 12,
            eumerate_resolutions = 13,
            file_dependencies = 14,
            true_type = 15,
            paper_names = 16,
            orientation = 17,
            copies = 18,
            bin_adjust = 19,
            metafile_compliant = 20,
            datatype_produced = 21,
            collate = 22,
            manufacturer = 23,
            model = 24,
            color_device = 23,
            nup = 24,
            personality = 25,
            print_rate = 26,
            print_rate_unit = 27,
            printer_memory = 28,
            media_ready = 29
        };
    };

    export struct print_rate_unit
    {
        enum
        {
            pages_per_minute = 1,
            characters_per_second = 2,
            lines_per_minute = 3,
            inches_per_minute = 4
        };
    };

    export struct true_type_flag
    {
        enum
        {
            bitmap = 0x0001,
            download = 0x0002,
            device_substitute = 0x0004,
            download_outline = 0x0008
        };
    };

    export struct bin_face
    {
        enum
        {
            face_up_none = 0x0000,
            face_up_center = 0x0001,
            face_up_left = 0x0002,
            face_up_right = 0x0003,
            face_down_none = 0x0100,
            face_down_center = 0x0101,
            face_down_left = 0x0102,
            face_down_right = 0x0103
        };
    };

    export struct rasterizer_flags
    {
        enum
        {
            true_type_available = 0x0001,
            true_type_enabled = 0x0002
        };
    };

    export struct rasterizer_status
    {
        short size;
        short flags;
        short language;

        rasterizer_status() : size(sizeof(rasterizer_status)) {}
    };

    export struct colors
    {
        enum
        {
            red_green_blue = 0,
            palette = 1,
            palette_indices = 2,
            physical_palette = 2,
            logical_palette = 4
        };
    };

    export struct red_green_blue_triple
    {
        byte blue;
        byte green;
        byte red;
    };

    export struct bitmap_core
    {
        uint size;
        part width;
        part height;
        part planes;
        part bit_count;
    };

    export struct bitmap_compress
    {
        enum
        {
            red_green_blue = 0,
            run_length_encoded_8 = 1,
            run_length_encoded_4 = 2,
            bit_fields = 3,
            jpeg = 4
        };
    };

    export struct bitmap_information
    {
        uint size;
        int width;
        int height;
        part planes;
        part bit_count;
        uint compression;
        uint image;
        int x_resolution;
        int y_resolution;
        uint used;
        uint important;
    };

    export struct bitmap_information4 : public bitmap_information
    {
        uint red_mask;
        uint green_mask;
        uint blue_mask;
        uint alphamask;
        uint color_space_type;
        color_red_green_blue color_endpoints;
        uint red_gamma;
        uint green_gamma;
        uint blue_gamma;
    };

    export  long long profile_linked('LINK');
    export  long long profile_embedded('MBED');

    export struct bitmap_information5 : public bitmap_information4
    {
        uint intent;
        uint profile_data;
        uint profile_size;
        uint reserved;
    };

    export struct bitmap_file
    {
        part type;
        uint size;
        uint reserved;
        uint offset;
    };

    export struct bitmap_definition
    {
        int type;
        int width;
        int height;
        int bytes;
        part planes;
        part bits;
        void* data;
    };

    export struct bitmap_section : public bitmap_definition,
        public bitmap_information
    {
        uint mask[3];
        handle section;
        uint offset;
    };

    export struct bit_buffer
    {
        uint size;
        void* bits;
    };

    export struct bitmap_bits
    {
        uint start;
        uint lines;
        void* data;
        bitmap_information* information;
        uint usage;
        handle device;
    };

    export struct bitmap_identity
    {
        enum
        {
            close = 32754,
            arrow_up = 32753,
            arrow_down = 32752,
            arrow_right = 32751,
            arrow_left = 32750,
            reduce = 32749,
            zoom = 32748,
            restore = 32747,
            reduced = 32746,
            d_zoom = 32745,
            restored = 32744,
            d_arrow_up = 32743,
            d_arrow_down = 32742,
            d_arrow_right = 32741,
            d_arrow_left = 32740,
            arrow_main = 32739,
            combo = 32738,
            i_arrow_up = 32737,
            i_arrow_down = 32736,
            i_arrow_right = 32735,
            i_arrow_left = 32734,
            close_old = 32767,
            size = 32766,
            arrow_up_old = 32765,
            arrow_down_old = 32764,
            arrow_right_old = 32763,
            arrow_left_old = 32762,
            button_size = 32761,
            check = 32760,
            check_boxes = 32759,
            button_corners = 32758,
            reduce_old = 32757,
            zoom_old = 32756,
            restore_old = 32755
        };
    };

    export  enum { bitmap_initialize = 0x4 };

    export struct fill_mode
    {
        enum { alternate = 1, winding };
    };

    export struct region_data
    {
        enum { typerectangles = 1 };

        uint size;
        uint type;
        uint count;
        uint region;
        irectangle bounds;

        irectangle& operator[](uint index) { return (&bounds + 1)[index]; }
        irectangle operator()(uint index) const { return (&bounds + 1)[index]; }
    };


    export struct region_combine
    {
        enum
        {
            _and = 1,
            _or,
            exclusive_or,
            difference,
            copy
        };
    };

    export  typedef result(__stdcall* procedure)(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export  typedef result(__stdcall* dialog_procedure)(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export template<class character>
        struct window_class
    {
        uint style;
        procedure procedure;
        int extra;
        int window;
        handle module;
        handle icon;
        handle cursor;
        handle brush;
        const character* menu;
        const character* name;

        window_class() : style(0),
            procedure(0),
            extra(0),
            window(0),
            icon(0),
            cursor(0),
            brush(0),
            menu(0),
            name(0),
            module(0) {}

    };

    export template<class character>
        struct window_class_new
    {
        uint size;
        uint style;
        procedure procedure;
        int extra;
        int window;
        handle module;
        handle icon;
        handle cursor;
        handle brush;
        const character* menu;
        const character* name;
        handle small_icon;
    };

    export struct class_style
    {
        enum
        {
            vertical_redraw = 0x0001,
            horizontal_redraw = 0x0002,
            key_convert = 0x0004,
            double_clicks = 0x0008,
            own_device_context = 0x0020,
            class_device_context = 0x0040,
            parent_device_context = 0x0080,
            no_key_convert = 0x0100,
            no_close = 0x0200,
            save_bits = 0x0800,
            align_client = 0x1000,
            align_window = 0x2000,
            global_class = 0x4000,
            ime = 0x00010000,
            drop_shadow = 0x00020000
        };
    };

    export  typedef int(__stdcall* hook)(int, parameter, parameter);

    export struct hook_type
    {
        enum
        {
            message = -1,
            journal_record = 0,
            journal_playback = 1,
            keyboard = 2,
            get_message = 3,
            call_window = 4,
            computer_training = 5,
            system_message = 6,
            mouse = 7,
            hardware = 8,
            debug = 9,
            shell = 10,
            foreground_idle = 11,
            window_return = 12,
            keyboard_low_level = 13,
            mouse_low_level = 14
        };
    };

    export struct hook_code
    {
        enum
        {
            action = 0,
            get_next = 1,
            skip = 2,
            no_remove = 3,
            system_modal_on = 4,
            system_modal_off = 5
        };
    };

    export struct hook_computer_training_code
    {
        enum
        {
            move_size = 0,
            minimum_maximum = 1,
            synchronize_queue = 2,
            create_window = 3,
            destroy_window = 4,
            activate = 5,
            click_skipped = 6,
            key_skipped = 7,
            system_command = 8,
            set_focus = 9
        };
    };

    export struct hook_message_filter
    {
        enum
        {
            dialog_box = 0,
            message_box = 1,
            menu = 2,
            move = 3,
            size = 4,
            scrollbar = 5,
            next_window = 6,
            main_loop = 8,
            maximum = 8,
            user = 4096
        };
    };

    export struct hook_shell_flag
    {
        enum
        {
            window_created = 1,
            window_destroyed = 2,
            activate_window = 3,
            window_activated = 4,
            get_minimum_rectangle = 5,
            redraw = 6,
            task_manager = 7,
            language = 8,
            accessibility_state = 11
        };
    };

    export struct accessibility_state
    {
        enum
        {
            sticky_keys = 0x0001,
            filter_keys = 0x0002,
            mouse_keys = 0x0003
        };
    };

    export struct hook_training_create_window
    {
        handle window_create;
        handle insert_after;
    };

    export struct hook_activate_window
    {
        bool mouse;
        handle active;
    };

    export struct hook_message_event
    {
        uint message;
        uint low;
        uint high;
        uint time;
        handle window;
    };

    export struct hook_call_window_information
    {
        parameter parameter2;
        parameter parameter1;
        uint message;
        handle window;
    };

    export struct hook_window_return_information
    {
        result result;
        parameter parameter2;
        parameter parameter1;
        uint message;
        handle window;
    };

    export struct hook_debug_information
    {
        uint thread_identity;
        uint thread_installer;
        parameter parameter2;
        parameter parameter1;
        int code;
    };

    export struct hook_mouse_information
    {
        ipoint mouse;
        handle window;
        uint hit_test;
        void* extra;
    };

    export struct hook_keyboard_flag
    {
        enum
        {
            extended = 0x0001,
            injected = 0x0010,
            alt_down = 0x0020,
            up = 0x0080
        };
    };

    export struct hook_keyboard_low_level
    {
        uint virtual_key;
        uint scan_code;
        uint flags;
        uint time;
        void* extra;
    };

    export struct hook_mouse_flag
    {
        enum
        {
            injected = 0x00000001
        };
    };

    export struct hook_mouse_low_level
    {
        ipoint mouse;
        uint data;
        uint flags;
        uint time;
        void* extra;
    };

    export struct hook_hardware_information
    {
        handle window;
        uint message;
        parameter parameter1;
        parameter parameter2;
    };

    export struct menu_item_flag
    {
        enum
        {
            insert = 0x0000,
            change = 0x0080,
            append = 0x0100,
            _delete = 0x0200,
            remove = 0x1000,

            by_command = 0x0000,
            by_position = 0x0400,

            separator = 0x0800,

            enabled = 0x0000,
            grayed = 0x0001,
            disabled = 0x0002,

            unchecked = 0x0000,
            checked = 0x0008,
            use_check_bitmaps = 0x0200,

            string = 0x0000,
            bitmap = 0x0004,
            owner_draw = 0x0100,

            submenu = 0x0010,
            menubar_break = 0x0020,
            menu_break = 0x0040,

            unhighlight = 0x0000,
            highlight = 0x0080,
            radio_check = 0x0200,

            _default = 0x1000,

            system_menu = 0x2000,
            right_order = 0x2000,
            help = 0x4000,
            right_justify = 0x4000,
            mouse_select = 0x8000,

            mask = 0x0000108b,
            hot_track_drawn = 0x10000000,
            cached_bitmap = 0x20000000,
            gap_drop_bottom = 0x40000000,
            gap_drop_top = 0x80000000,
            gap_drop = 0xc0000000
        };
    };

    export struct item_mask
    {
        enum
        {
            state = 0x00000001,
            identity = 0x00000002,
            submenu = 0x00000004,
            check_marks = 0x00000008,
            type = 0x00000010,
            data = 0x00000020,
            string = 0x00000040,
            bitmap = 0x00000080,
            ftype = 0x00000100
        };
    };

    export template<class character>
        struct menu_item_information
    {
        uint size;
        uint mask;
        uint type;
        uint state;
        uint identity;
        handle submenu;
        handle checked;
        handle unchecked;
        void* item;
        character* type_data;
        uint length;
        handle bitmap;
    };

    export struct menu_default_item
    {
        enum
        {
            disabled = 0x0001,
            submenus = 0x0002
        };
    };

    export struct menu_chacter
    {
        enum
        {
            ignore = 0,
            close = 1,
            execute = 2,
            select = 3
        };
    };

    export struct track_flag
    {
        enum
        {
            button_left = 0x0000,
            button_right = 0x0002,
            align_left = 0x0000,
            align_center = 0x0004,
            align_right = 0x0008,
            align_top = 0x0000,
            align_middle = 0x0010,
            align_bottom = 0x0020,
            align_horizontal = 0x0000,
            align_vertical = 0x0040,
            align_no_notify = 0x0080,
            align_return_command = 0x0100,
            align_recurse = 0x0001
        };
    };

    export struct track_parameters
    {
        uint size;
        irectangle exclude;
    };

    export  long long menu_bitmap_callback(-1);
    export  long long menu_bitmap_system(1);
    export  long long menubar_bitmap_restore(2);
    export  long long menubar_bitmap_minimize(3);
    export  long long menubar_bitmap_close(5);
    export  long long menubar_bitmap_closed(6);
    export  long long menubar_bitmap_minimized(7);
    export  long long menu_bitmap_popup_close(8);
    export  long long menu_bitmap_popup_restore(9);
    export  long long menu_bitmap_popup_maximize(10);
    export  long long menu_bitmap_popup_minimize(11);

    export struct menu_template_header
    {
        part version;
        part offset;
    };

    export struct menu_item_template
    {
        part options;
        part identity;
        wchar_t text[1];

        wchar_t& operator[](uint index) { return text[index]; }
    };

    export struct menu_item_template_extended : public menu_item_template
    {
        uint help;
    };

    export struct menu_template_header_extended
    {
        part version;
        part offset;
        uint help;
    };

    export struct scrollbar_information
    {
        uint size;
        uint mask;
        int minimum;
        int maximum;
        uint page;
        uint position;
        int track;
    };

    export  enum { use_default = 0x80000000 };

    export struct place
    {
        enum
        {
            no_size = 0x0001,
            no_move = 0x0002,
            no_zorder = 0x0004,
            no_redraw = 0x0008,
            no_activate = 0x0010,
            frame_changed = 0x0020,
            show = 0x0040,
            hide = 0x0080,
            no_copy_bits = 0x0100,
            no_owner_zorder = 0x0200,
            no_send_changing = 0x0400,
            defer_erase = 0x2000,
            asynchronous = 0x4000,
            frame_draw = frame_changed,
            no_reposition = no_owner_zorder
        };
    };

    export struct place_restore
    {
        enum
        {
            minimum = 0x0001,
            maximum = 0x0002
        };
    };

    export struct placement
    {
        uint size;
        uint flags;
        uint show;
        ipoint minimum;
        ipoint maximum;
        irectangle normal;
    };

    export  typedef bool(__stdcall* property_callback)(handle, const character*, handle);

    export  typedef bool(__stdcall* extended_property_callback)(handle, const character*, handle, parameter);

    export  typedef void(__stdcall* completion)(handle, uint, void*, result);

    export  typedef bool(__stdcall* enumerate_window)(handle, parameter);

    export  typedef int(__stdcall* word_break)(character*, int, int, int);

    export struct show_flag
    {
        enum
        {
            hide = 0,
            normal = 1,
            show_minimized = 2,
            show_maximized = 3,
            maximize = 3,
            show_no_activate = 4,
            show = 5,
            minimize = 6,
            show_minimize_no_activate = 7,
            show_no_active = 8,
            restore = 9,
            _default = 10,
            minimize_force = 11
        };
    };

    export struct class_offset
    {
        enum
        {
            menu_name = -8,
            background_brush = -10,
            cursor = -12,
            icon = -14,
            module_handle = -16,
            window_extra = -18,
            class_extra = -20,
            window_procedure = -24,
            style = -26,
            atom = -32,
            small_icon = -34,
        };
    };

    export struct offset
    {
        enum
        {
            window_procedure = -4,
            instance = -6,
            parent = -8,
            style = -16,
            extended_style = -20,
            user_data = -21,
            identity = -12,
        };
    };

    export struct hotkeys
    {
        enum
        {
            shift = 0x01,
            control = 0x02,
            alt = 0x04,
            extended = 0x08
        };
    };

    export struct system_window
    {
        enum
        {
            desktop = 0,
            top = 0,
            bottom = 1,
            top_most = -1,
            last = -1,
            no_top_most = -2,
            message = -3,
            broadcast = 0xffff,
        };
    };

    export struct directory_attribute
    {
        enum
        {
            read_write = 0x0000,
            read_only = 0x0001,
            hidden = 0x0002,
            system = 0x0004,
            directory = 0x0010,
            archive = 0x0020,
            post_messages = 0x2000,
            drives = 0x4000,
            exclusive = 0x8000
        };
    };

    export struct skip_flag
    {
        enum
        {
            none = 0x0000,
            invisible = 0x0001,
            disabled = 0x0002,
            transparent = 0x0004
        };
    };

    export struct system_command
    {
        enum
        {
            size = 0xf000,
            move = 0xf010,
            minimize = 0xf020,
            maximize = 0xf030,
            next_window = 0xf040,
            previous_window = 0xf050,
            close = 0xf060,
            vertical_scroll = 0xf070,
            horizontal_scroll = 0xf080,
            menu_mouse = 0xf090,
            menu_key = 0xf100,
            arrange = 0xf110,
            restore = 0xf120,
            task_list = 0xf130,
            save_screen = 0xf140,
            hotkey = 0xf150,
            _default = 0xf160,
            monitor_power = 0xf170,
            context_help = 0xf180,
            separator = 0xf00f
        };
    };

    export struct message
    {
        enum
        {
            null = 0x0000,
            create = 0x0001,
            destroy = 0x0002,
            move = 0x0003,
            size = 0x0005,
            activate = 0x0006,
            set_focus = 0x0007,
            remove_focus = 0x0008,
            enable = 0x000a,
            set_redraw = 0x000b,
            set_text = 0x000c,
            get_text = 0x000d,
            get_text_length = 0x000e,
            paint = 0x000f,
            close = 0x0010,
            query_session_end = 0x0011,
            quit = 0x0012,
            query_open = 0x0013,
            erase_background = 0x0014,
            system_color_change = 0x0015,
            end_session = 0x0016,
            show = 0x0018,
            win_ini_change = 0x001a,
            setting_change = 0x001a,
            device_mode_change = 0x001b,
            activate_application = 0x001c,
            font_change = 0x001d,
            time_change = 0x001e,
            cancel_mode = 0x001f,
            set_cursor = 0x0020,
            mouse_activate = 0x0021,
            activate_child = 0x0022,
            queue_synchronize = 0x0023,
            get_minimum_maximum_information = 0x0024,
            paint_icon = 0x0026,
            erase_icon_background = 0x0027,
            next_dialog_control = 0x0028,
            spooler_status = 0x002a,
            draw_item = 0x002b,
            measure_item = 0x002c,
            delete_item = 0x002d,
            virtual_key_to_item = 0x002e,
            character_to_item = 0x002f,
            set_font = 0x0030,
            get_font = 0x0031,
            set_hotkey = 0x0032,
            get_hotkey = 0x0033,
            query_drag_icon = 0x0037,
            compare_item = 0x0039,
            get_object = 0x003d,
            compacting = 0x0041,
            window_position_changing = 0x0046,
            window_position_changed = 0x0047,
            power = 0x0048,
            copy_data = 0x004a,
            cancel_journal = 0x004b,

            notify = 0x004e,
            input_language_change_request = 0x0050,
            input_language_change = 0x0051,
            training_card = 0x0052,
            help = 0x0053,
            user_changed = 0x0054,
            notify_format = 0x0055,

            context_menu = 0x007b,
            style_changing = 0x007c,
            style_changed = 0x007d,
            display_change = 0x007e,
            get_icon = 0x007f,
            set_icon = 0x0080,

            nonclient_create = 0x0081,
            nonclient_destroy = 0x0082,
            nonclient_calculate_size = 0x0083,
            nonclient_hit_test = 0x0084,
            nonclient_paint = 0x0085,
            nonclient_activate = 0x0086,
            get_dialog_code = 0x0087,
            synchronize_paint = 0x0088,

            nonclient_mouse_move = 0x00a0,
            nonclient_left_button_down = 0x00a1,
            nonclient_left_button_up = 0x00a2,
            nonclient_left_button_double_click = 0x00a3,
            nonclient_right_button_down = 0x00a4,
            nonclient_right_button_up = 0x00a5,
            nonclient_right_button_double_click = 0x00a6,
            nonclient_middle_button_down = 0x00a7,
            nonclient_middle_button_up = 0x00a8,
            nonclient_middle_button_double_click = 0x00a9,

            key_first = 0x0100,
            key_down = 0x0100,
            key_up = 0x0101,
            character = 0x0102,
            accent_character = 0x0103,
            system_key_down = 0x0104,
            system_key_up = 0x0105,
            system_character = 0x0106,
            system_accent_character = 0x0107,
            key_last = 0x0108,

            initialize_dialog = 0x0110,
            command = 0x0111,
            system_command = 0x0112,
            timer = 0x0113,
            horizontal_scroll = 0x0114,
            vertical_scroll = 0x0115,
            initialize_menu = 0x0116,
            initialize_popup_menu = 0x0117,
            select_menu = 0x011f,
            menu_character = 0x0120,
            enter_idle = 0x0121,

            menu_right_button_up = 0x0122,
            drag_menu = 0x0123,
            get_menu_object = 0x0124,
            uninitialize_popup_menu = 0x0125,
            menu_command = 0x0126,

            color_message_box = 0x0132,
            color_edit = 0x0133,
            color_listbox = 0x0134,
            color_button = 0x0135,
            color_dialog = 0x0136,
            color_scrollbar = 0x0137,
            color_display = 0x0138,

            mouse_first = 0x0200,
            mouse_move = 0x0200,
            left_button_down = 0x0201,
            left_button_up = 0x0202,
            left_button_double_click = 0x0203,
            right_button_down = 0x0204,
            right_button_up = 0x0205,
            right_button_double_click = 0x0206,
            middle_button_down = 0x0207,
            middle_button_up = 0x0208,
            middle_button_double_click = 0x0209,
            mouse_wheel = 0x020a,
            mouse_last = 0x020a,

            notify_parent = 0x0210,
            enter_menu_loop = 0x0211,
            exit_menu_loop = 0x0212,
            next_menu = 0x0213,
            sizing = 0x0214,
            capture_changed = 0x0215,
            moving = 0x0216,
            power_broadcast = 0x0218,
            device_change = 0x0219,

            multidocument_create = 0x0220,
            multidocument_destroy = 0x0221,
            multidocument_activate = 0x0222,
            multidocument_restore = 0x0223,
            multidocument_next = 0x0224,
            multidocument_maximize = 0x0225,
            multidocument_tile = 0x0226,
            multidocument_cascade = 0x0227,
            multidocument_arrange_icon = 0x0228,
            multidocument_get_active = 0x0229,
            multidocument_set_menu = 0x0230,

            enter_size_move = 0x0231,
            exit_size_move = 0x0232,
            drop_files = 0x0233,
            multidocument_refresh_menu = 0x0234,

            mouse_hover = 0x02a1,
            mouse_leave = 0x02a3,

            cut = 0x0300,
            copy = 0x0301,
            paste = 0x0302,
            clear = 0x0303,
            undo = 0x0304,
            render_format = 0x0305,
            render_all_formats = 0x0306,

            destroy_clipboard = 0x0307,
            draw_clipboard = 0x0308,
            paint_clipboard = 0x0309,
            vertical_scroll_clipboard = 0x030a,
            size_clipboard = 0x030b,
            clipboard_format_name = 0x030c,
            clipboard_chain_changed = 0x030d,
            horizontal_scroll_clipboard = 0x030e,

            get_new_palette = 0x030f,
            palette_is_changing = 0x0310,
            palette_changed = 0x0311,

            hotkey = 0x0312,

            print = 0x0317,
            print_client = 0x0318,

            pen_win_first = 0x0380,
            pen_win_last = 0x038f,

            user = 0x0400,
        };
    };

    export struct show_identity
    {
        enum
        {
            parent_closing = 1,
            other_maximize = 2,
            parent_opening = 3,
            other_unmaximize = 4
        };
    };

    export struct key_flag
    {
        enum
        {
            extended = 0x0100,
            dialog_mode = 0x0800,
            menu_mode = 0x1000,
            alt_down = 0x2000,
            repeat = 0x4000,
            up = 0x8000
        };
    };

    export struct hit_test
    {
        enum
        {
            error = -2,
            transparent = -1,
            nowhere = 0,
            client = 1,
            caption = 2,
            system_menu = 3,
            size = 4,
            menu = 5,
            horizontal_scroll = 6,
            vertical_scroll = 7,
            button_minimize = 8,
            button_maximize = 9,
            left = 10,
            right = 11,
            top = 12,
            top_left = 13,
            top_right = 14,
            bottom = 15,
            bottom_left = 16,
            bottom_right = 17,
            border = 18,
            object = 19,
            close = 20,
            help = 21,

            reduce = button_minimize,
            maximize = button_maximize,
            size_first = left,
            size_last = bottom_right
        };
    };

    export struct power_request
    {
        enum
        {
            ok = 1,
            fail = -1,
            suspend_request = 1,
            suspend_resume = 2,
            critical_resume = 3
        };
    };

    export struct power_broadcast_type
    {
        enum
        {
            query_suspend = 0x0000,
            query_standby = 0x0001,
            query_suspend_failed = 0x0002,
            query_standby_failed = 0x0003,
            suspend = 0x0004,
            standby = 0x0005,
            critical_resume = 0x0006,
            suspend_resume = 0x0007,
            standby_resume = 0x0008,
            battery_low = 0x0009,
            power_status_change = 0x000a,
            oem_event = 0x000b,
            automatic_resume = 0x0012
        };
    };

    export struct power_flag { enum { resume_from_failure = 0x00000001 }; };

    export struct mouse_activate
    {
        enum
        {
            activate = 1,
            activate_and_eat = 2,
            no_activate = 3,
            no_activate_and_eat = 4
        };
    };

    export struct window_activate
    {
        enum
        {
            deactivate = 0,
            activate = 1,
            activate_click = 2
        };
    };

    export struct window_size
    {
        enum
        {
            restored = 0,
            minimized = 1,
            maximized = 2,
            maximize_show = 3,
            maximize_hide = 4
        };
    };

    export struct window_valid_rectangle
    {
        enum
        {
            align_top = 0x0010,
            align_left = 0x0020,
            align_bottom = 0x0040,
            align_right = 0x0080,
            horizontal_redraw = 0x0100,
            vertical_redraw = 0x0200,
            valid = 0x0400,
            redraw_all = horizontal_redraw | vertical_redraw
        };
    };

    export struct mouse_state
    {
        enum
        {
            left_button = 0x0001,
            right_button = 0x0002,
            shift = 0x0004,
            control = 0x0008,
            middle_button = 0x0010,
            x_button1 = 0x0020,
            x_button2 = 0x0040
        };
    };

    export struct owner_draw_type
    {
        enum
        {
            menu = 1,
            listbox = 2,
            combobox = 3,
            button = 4,
            display = 5
        };
    };

    export struct owner_draw_action
    {
        enum
        {
            entire = 0x0001,
            select = 0x0002,
            focus = 0x0004
        };
    };

    export struct owner_draw_state
    {
        enum
        {
            selected = 0x0001,
            grayed = 0x0002,
            disabled = 0x0004,
            checked = 0x0008,
            focus = 0x0010,
            _default = 0x0020,
            combobox_edit = 0x1000,
            hotlight = 0x0040,
            inactive = 0x0080
        };
    };

    export struct notify_command
    {
        enum
        {
            response_single_byte = 1,
            response_double_byte = 2,
            query = 3,
            requery = 4
        };
    };

    export struct style_change
    {
        uint previous;
        uint next;
    };

    export struct icon_size
    {
        enum
        {
            small = 0,
            large = 1
        };
    };

    export struct next_menu
    {
        handle in;
        handle menu;
        handle window;
    };

    export struct sizing_edge
    {
        enum
        {
            left = 1,
            right = 2,
            top = 3,
            top_left = 4,
            top_right = 5,
            bottom = 6,
            bottom_left = 7,
            bottom_right = 8
        };
    };

    export struct multidocument_flag { enum { all_child_styles = 0x0001 }; };

    export struct system_command_hotkey
    {
        enum
        {
            snap_window = -1,
            snap_desktop = -2
        };
    };

    export struct print_flag
    {
        enum
        {
            check_visible = 0x0001,
            nonclient = 0x0002,
            client = 0x0004,
            erase_background = 0x0008,
            children = 0x0010,
            owned = 0x0020
        };
    };

    export struct mouse_wheel_flag
    {
        enum
        {
            delta = 120,
            page_scroll = 0xfffffff
        };
    };

    export struct send_message_with_timeout
    {
        enum
        {
            normal = 0x0000,
            block = 0x0001,
            cancel_if_hung = 0x0002,
            no_timeout_if_not_hung = 0x0008
        };
    };

    export template<class character>
        bool integer_to_string(long long convert,
            character* string,
            long long base = 10)
    {
        if (base >= 36 || base < 2)
            return false;
        else
        {
            character digits[] = { '0','1','2','3','4','5','6','7','8','9',
                'a','b','c','d','e','f','g','h','i','j',
                'k','l','m','n','o','p','q','r','s','t',
                'u','v','w','x','y','z' };

            if (!convert)
            {
                *string = '0';
                *(string + 1) = '\0';
            }
            else
            {
                long long i = 0;

                if (base == 10 && convert < 0)
                {
                    string[i] = '-';
                    convert = -convert;
                    i++;
                }
                ulong u = (ulong)convert;
                while (u)
                {
                    long long remainder = u % base;

                    string[i] = digits[remainder];
                    u /= base;
                    i++;
                }
                string[i] = '\0';
                if (string[0] == '-')
                    reverse(string + 1);
                else
                    reverse(string);
            }
        }
        return true;
    }

    export struct scrollbar_identity
    {
        enum
        {
            horizontal = 0,
            vertical = 1,
            control = 2,
            both = 3
        };
    };

    //export extern "C" string display_class_name((const wchar_t*)L"static");

    export struct display_style
    {
        enum
        {
            left = 0x0000,
            center = 0x0001,
            right = 0x0002,
            icon = 0x0003,
            rectangle_black = 0x0004,
            rectangle_gray = 0x0005,
            rectangle_white = 0x0006,
            frame_black = 0x0007,
            frame_gray = 0x0008,
            frame_white = 0x0009,
            user_item = 0x000a,
            simple = 0x000b,
            left_no_word_wrap = 0x000c,
            owner_draw = 0x000d,
            bitmap = 0x000e,
            metafile = 0x000f,
            etched_horizontal = 0x0010,
            etched_vertical = 0x0011,
            etched_frame = 0x0012,
            type_mask = 0x001f,
            no_prefix = 0x0080,
            notify = 0x0100,
            center_image = 0x0200,
            right_justify = 0x0400,
            image_real_size = 0x0800,
            sunken = 0x1000,
            end_ellipsis = 0x4000,
            path_ellipsis = 0x8000,
            word_ellipsis = 0xc000,
            ellipsis_mask = 0xc000
        };
    };

    export struct display_message
    {
        enum
        {
            set_icon = 0x0170,
            get_icon = 0x0171,
            set_image = 0x0172,
            get_image = 0x0173
        };
    };

    export struct display_notify
    {
        enum
        {
            clicked = 0,
            double_clicked = 1,
            enable = 2,
            disable = 3
        };
    };

    export struct button_style
    {
        enum
        {
            push_button = 0x0000,
            push_button_default = 0x0001,
            check_box = 0x0002,
            auto_check_box = 0x0003,
            radio_button = 0x0004,
            three_state = 0x0005,
            auto_three_state = 0x0006,
            group_box = 0x0007,
            user_button = 0x0008,
            auto_radio_button = 0x0009,
            owner_draw = 0x000b,
            text_left = 0x0020,
            text = 0x0000,
            icon = 0x0040,
            bitmap = 0x0080,
            left = 0x0100,
            right = 0x0200,
            center = 0x0300,
            top = 0x0400,
            bottom = 0x0800,
            center_vertical = 0x0c00,
            push_like = 0x1000,
            multiline = 0x2000,
            notify = 0x4000,
            flat = 0x8000,
            button_right = text_left
        };
    };

    export struct button_message
    {
        enum
        {
            get_check = 0x00f0,
            set_check = 0x00f1,
            get_state = 0x00f2,
            set_state = 0x00f3,
            set_style = 0x00f4,
            click = 0x00f5,
            get_image = 0x00f6,
            set_image = 0x00f7
        };
    };


    export struct edit_style
    {
        enum
        {
            left = 0x0000,
            center = 0x0001,
            right = 0x0002,
            multiple_line = 0x0004,
            upper_case = 0x0008,
            lower_case = 0x0010,
            password = 0x0020,
            auto_scroll_vertical = 0x0040,
            auto_scroll_horizontal = 0x0080,
            no_hide_selection = 0x0100,
            convert = 0x0400,
            read_only = 0x0800,
            _return = 0x1000,
            number = 0x2000
        };
    };

    export struct edit_notify
    {
        enum
        {
            set_focus = 0x0100,
            remove_focus = 0x0200,
            change = 0x0300,
            update = 0x0400,
            space_error = 0x0500,
            text_maximum = 0x0501,
            horizontal_scroll = 0x0601,
            vertical_scroll = 0x0602
        };
    };

    export struct edit_message
    {
        enum
        {
            get_selection = 0x00b0,
            set_selection = 0x00b1,
            get_rectangle = 0x00b2,
            set_rectangle = 0x00b3,
            set_rectangle_no_paint = 0x00b4,
            scroll = 0x00b5,
            scroll_line = 0x00b6,
            scroll_caret = 0x00b7,
            get_modify = 0x00b8,
            set_modify = 0x00b9,
            get_line_count = 0x00ba,
            line_index = 0x00bb,
            set_handle = 0x00bc,
            get_handle = 0x00bd,
            get_slider = 0x00be,
            line_length = 0x00c1,
            replace_selection = 0x00c2,
            get_line = 0x00c4,
            set_text_limit = 0x00c5,
            get_undo = 0x00c6,
            undo = 0x00c7,
            format_lines = 0x00c8,
            line_from_character = 0x00c9,
            set_tabstops = 0x00cb,
            set_password_character = 0x00cc,
            empty_undo_buffer = 0x00cd,
            get_first_visible_line = 0x00ce,
            set_read_only = 0x00cf,
            set_word_break_function = 0x00d0,
            get_word_break_function = 0x00d1,
            get_passwordcharacter = 0x00d2,
            set_margins = 0x00d3,
            get_margins = 0x00d4,
            get_text_limit = 0x00d5,
            position_from_character = 0x00d6,
            character_from_position = 0x00d7,

            set_input_edit_status = 0x00d8,
            get_input_edit_status = 0x00d9
        };
    };

    export struct input_method_edit_status { enum { edit_composition_string = 0x0001 }; };

    export struct  edit_composition
    {
        enum
        {
            get_at_once = 0x0001,
            cancel_on_focus = 0x0002,
            complete_when_focus_cancel = 0x0004
        };
    };

    export struct edit_margin
    {
        enum
        {
            left = 0x0001,
            right = 0x0002,
            font = 0xffff
        };
    };

    export struct word_break_flags
    {
        enum
        {
            left = 0,
            right = 1,
            delimiter = 2
        };
    };

    export struct listbox_style
    {
        enum
        {
            notify = 0x0001,
            sort = 0x0002,
            no_redraw = 0x0004,
            multiple_select = 0x0008,
            owner_draw_fixed = 0x0010,
            owner_draw_variable = 0x0020,
            strings = 0x0040,
            tabstops = 0x0080,
            no_integral_height = 0x0100,
            multiple_column = 0x0200,
            keyboard_input = 0x0400,
            extended_select = 0x0800,
            disable_no_scroll = 0x1000,
            no_data = 0x2000,
            no_select = 0x4000,
            standard = notify | sort | style::vertical_scroll | style::border
        };
    };

    export struct listbox_notify
    {
        enum
        {
            error_space = -2,
            selection_change = 1,
            double_click = 2,
            cancel_selection = 3,
            set_focus = 4,
            cancel_focus = 5
        };
    };

    export struct listbox_message
    {
        enum
        {
            add_string = 0x0180,
            insert_string = 0x0181,
            delete_string = 0x0182,
            set_selection_range_extended = 0x0183,
            reset_content = 0x0184,
            set_selection_state = 0x0185,
            set_selection = 0x0186,
            get_selection_state = 0x0187,
            get_selection = 0x0188,
            get_text = 0x0189,
            get_text_length = 0x018a,
            get_count = 0x018b,
            select_string = 0x018c,
            directory = 0x018d,
            get_top_index = 0x018e,
            find_string = 0x018f,
            get_selection_count = 0x0190,
            get_selection_range = 0x0191,
            set_tabstops = 0x0192,
            get_horizontal_extent = 0x0193,
            set_horizontal_extent = 0x0194,
            set_column_width = 0x0195,
            add_file = 0x0196,
            set_top_index = 0x0197,
            get_item_rectangle = 0x0198,
            get_item_data = 0x0199,
            set_item_data = 0x019a,
            set_selection_range = 0x019b,
            set_anchor = 0x019c,
            get_anchor = 0x019d,
            set_caret = 0x019e,
            get_caret = 0x019f,
            set_item_height = 0x01a0,
            get_item_height = 0x01a1,
            find_string_exact = 0x01a2,
            set_locale = 0x01a5,
            get_locale = 0x01a6,
            set_count = 0x01a7,
            initialize_memory = 0x01a8,
            item_from_point = 0x01a9
        };
    };

    export struct listbox_return
    {
        enum
        {
            ok = 0,
            error = -1,
            error_space = -2
        };
    };

    export struct button_notify
    {
        enum
        {
            clicked = 0,
            paint = 1,
            highlight = 2,
            unhighlight = 3,
            disable = 4,
            double_clicked = 5,
            set_focus = 6,
            lose_focus = 7
        };
    };

    export struct button_state
    {
        enum
        {
            unchecked = 0x0000,
            checked = 0x0001,
            indeterminate = 0x0002,
            highlighted = 0x0004,
            focus = 0x0008
        };
    };

    export struct combobox_style
    {
        enum
        {
            simple = 0x0001,
            drop_down = 0x0002,
            drop_down_list = 0x0003,
            owner_draw_fixed = 0x0010,
            owner_draw_variable = 0x0020,
            horizontal_scroll_auto = 0x0040,
            convert = 0x0080,
            sort = 0x0100,
            strings = 0x0200,
            no_integral_height = 0x0400,
            disable_no_scroll = 0x0800,
            upper_case = 0x2000,
            lower_case = 0x4000
        };
    };

    export struct combobox_notify
    {
        enum
        {
            error_space = -1,
            selection_change = 1,
            double_click = 2,
            set_focus = 3,
            cancel_focus = 4,
            edit_change = 5,
            edit_update = 6,
            drop_down = 7,
            close_up = 8,
            selection_end_ok = 9,
            selection_end_cancel = 10
        };
    };

    export struct combobox_message
    {
        enum
        {
            get_edit_selection = 0x0140,
            set_text_limit = 0x0141,
            set_edit_selection = 0x0142,
            add_string = 0x0143,
            delete_string = 0x0144,
            directory = 0x0145,
            get_count = 0x0146,
            get_selection = 0x0147,
            get_text = 0x0148,
            get_text_length = 0x0149,
            insert_string = 0x014a,
            reset_content = 0x014b,
            find_string = 0x014c,
            select_string = 0x014d,
            set_selection = 0x014e,
            show_drop_down = 0x014f,
            get_item_data = 0x0150,
            set_item_data = 0x0151,
            get_dropped_rectangle = 0x0152,
            set_item_height = 0x0153,
            get_item_height = 0x0154,
            set_extended_interface = 0x0155,
            get_extended_interface = 0x0156,
            get_dropped_state = 0x0157,
            find_string_exact = 0x0158,
            set_locale = 0x0159,
            get_locale = 0x015a,
            get_top_index = 0x015b,
            set_top_index = 0x015c,
            get_horizontal_extent = 0x015d,
            set_horizontal_extent = 0x015e,
            get_dropped_width = 0x015f,
            set_dropped_width = 0x0160,
            initialize_memory = 0x0161
        };
    };

    export struct combobox_return
    {
        enum
        {
            ok = 0,
            error = -1,
            error_space = -2
        };
    };

    export struct common_message
    {
        enum common_messages
        {
            first = 0x2000,
            set_background_color = first + 1,
            set_color_scheme = first + 2,
            get_color_scheme = first + 3,
            get_drop_target = first + 4,
            set_unicode_format = first + 5,
            get_unicode_format = first + 6,
            set_version = first + 0x7,
            get_version = first + 0x8,
            set_notify_window = first + 0x9,
            set_window_theme = first + 0xb,
            dots_per_inch_scale = first + 0xc,
        };
    };

    export struct common_notify
    {
        enum
        {
            first = 0,
            out_of_memory = first - 1,
            click = first - 2,
            double_click = first - 3,
            _return = first - 4,
            click_right = first - 5,
            double_click_right = first - 6,
            set_focus = first - 7,
            lose_focus = first - 8,
            draw = first - 12,
            hover = first - 13,
            nonclient_hit_test = first - 14,
            key_down = first - 15,
            capture_released = first - 16,
            set_cursor = first - 17,
            character = first - 18,
        };
    };

    export struct notify_header
    {
        handle from;
        uint identity;
        uint code;
    };

    export struct notify_mouse : public notify_header
    {
        uint specification;
        uint data;
        ipoint mouse;
        uint hit;
    };

    export  typedef notify_mouse notify_click;

    export struct notify_key : public notify_header
    {
        uint virtual_key;
        uint flags;
    };

    export struct object_notify : public notify_header
    {
        int  item;
        const void* identity;
        void* object;
        result result;
        uint flags;
    };

    export struct notify_custom_draw : public notify_header
    {
        uint stage;
        handle device;
        irectangle draw;
        uint specification;
        uint state;
        parameter parameter_notify;
    };

    export struct color_scheme
    {
        uint size;
        icolor highlight;
        icolor shadow;
    };

    export struct common_notify_object : public notify_header
    {
        int item;
        void* identity;
        void* object;
        result result;
        uint flags;
    };

    export struct initialize_common_controls_classes
    {
        enum
        {
            list_view_classes = 0x00000001,
            tree_view_classes = 0x00000002,
            bar_classes = 0x00000004,
            tab_classes = 0x00000008,
            up_down_class = 0x00000010,
            progress_class = 0x00000020,
            hot_key_class = 0x00000040,
            animate_class = 0x00000080,
            windows95_classes = 0x000000ff,
            date_classes = 0x00000100,
            user_extended_classes = 0x00000200,
            cool_classes = 0x00000400,
            internet_classes = 0x00000800,
            page_scroller_class = 0x00001000,
            native_font_control_class = 0x00002000,
            standard_classes = 0x00004000,
            link_class = 0x00008000
        };
    };

    export struct initialize_common_controls_data
    {
        uint size;
        uint classes;
    };

    //export extern "C" bool __stdcall initialize_common_controls_extended(const initialize_common_controls_data*);

    export struct notify_tool_tips_created : public notify_header
    {
        handle tool_tips;
    };

    export struct common_notify_mouse : public notify_header
    {
        ulong item_specific;
        ulong item_data;
        ipoint ipoint;
        parameter hit_information;
    };

    //typedef notify_mouse common_notify_click;

    export struct notify_object : public notify_header
    {
        int  item;
        const void* identity;
        void* object;
        result result;
        uint flags;
    };

    export struct notify_character : public notify_header
    {
        uint character;
        uint previous_item;
        uint next_item;
    };

    export struct notify_custom_text : public notify_header
    {
        handle device_context;
        wchar_t* string;
        int count;
        irectangle* rectange;
        uint format;
        bool link;
    };

    export struct notify_code
    {
        enum
        {
            begin_drag = 0x4200,
            size_header = 0x4201,
            drag_select = 0x4202,
            tool_bar_customize = 0x4203,
        };
    };

    export struct custom_draw_return
    {
        enum
        {
            do_default = 0x00000000,
            new_font = 0x00000002,
            skip_default = 0x00000004,
            do_erase = 0x00000008,
            skip_post_paint = 0x00000100,
        };
    };

    export struct custom_draw_notify
    {
        enum
        {
            post_paint = 0x00000010,
            item_draw = 0x00000020,
            subitem_draw = 0x00000020,
            post_erase = 0x00000040,
        };
    };

    export struct custom_draw_stage
    {
        enum
        {
            pre_paint = 0x00000001,
            post_paint = 0x00000002,
            preerase = 0x00000003,
            post_erase = 0x00000004,
            item = 0x00010000,
            item_pre_paint = item | pre_paint,
            item_post_paint = item | post_paint,
            item_pre_erase = item | preerase,
            item_post_erase = item | post_erase,
            subitem = 0x00020000,
        };
    };

    export struct custom_draw_item_state
    {
        enum
        {
            selected = 0x0001,
            grayed = 0x0002,
            disabled = 0x0004,
            checked = 0x0008,
            focus = 0x0010,
            _default = 0x0020,
            hot = 0x0040,
            marked = 0x0080,
            indeterminate = 0x0100,
            show_keyboard = 0x0200,
            near_hot = 0x0400,
            other_side_hot = 0x0800,
            drop_highlighted = 0x1000,
        };
    };

    export struct notify_message_custom_draw : public notify_header
    {
        uint draw_stage;
        handle device_context;
        irectangle rectangle_draw;
        ulong item_specific;
        uint item_state;
        parameter item_parameter;
    };

    export struct notify_message_tool_tips_custom_draw : public notify_message_custom_draw
    {
        uint draw_flags;
    };

    export struct notify_message_custom_split_rectangle_information : public notify_header
    {
        irectangle client;
        irectangle button;
        irectangle split;
    };

    //enum {notify_message_get_custom_split_rectangle = bcn_first + 0x0003};

    export extern "C" uint index_to_state_mask(uint i) { return i << 12; }

    export struct tree_view_style
    {
        enum
        {
            buttons = 0x0001,
            lines = 0x0002,
            lines_at_root = 0x0004,
            edit_labels = 0x0008,
            drag_drop_disabled = 0x0010,
            show_selection = 0x0020,
            right_to_left = 0x0040,
            no_tooltips = 0x0080,
            check_boxes = 0x0100,
            track_select = 0x0200,
            single_expand = 0x0400,
            information_tip = 0x0800,
            full_row_select = 0x1000,
            no_scroll = 0x2000,
            noneven_height = 0x4000
        };
    };

    export struct tree_view_item_flag
    {
        enum
        {
            text = 0x0001,
            image = 0x0002,
            parameter = 0x0004,
            state = 0x0008,
            handle = 0x0010,
            image_selected = 0x0020,
            children = 0x0040,
            integral = 0x0080
        };
    };

    export struct tree_view_item_state
    {
        enum
        {
            selected = 0x0002,
            cut = 0x0004,
            drop_highlighted = 0x0008,
            bold = 0x0010,
            expanded = 0x0020,
            expanded_once = 0x0040,
            expanded_partial = 0x0080
        };
    };

    export  int text_callback(-1);
    export  int image_callback(-1);
    export  int children_callback(-1);

    export struct tree_view_change
    {
        enum
        {
            unknown = 0x0000,
            by_mouse = 0x0001,
            by_keyboard = 0x0002
        };
    };

    export template<class character>
        struct tree_view_item
    {
        uint mask;
        handle handle;
        uint state;
        uint state_mask;
        character* text;
        int text_maximum;
        int image;
        int image_selected;
        uint children;
        parameter parameter2;
    };

    export template<class character>
        struct tree_view_item_extended : public tree_view_item<character>
    {
        int integral;
    };

    export  long long tree_view_item_root(0xffff0000);
    export  long long tree_view_item_first(0xffff0001);
    export  long long tree_view_item_last(0xffff0002);
    export  long long tree_view_item_sort(0xffff0003);

    export template<class character>
        struct tree_view_insert
    {
        handle parent;
        handle after;
        tree_view_item_extended<character> tree_item;
    };

    export struct tree_view_message
    {
        enum
        {
            first = 0x1100,
            delete_item = first + 1,
            expand = first + 2,
            itemrectangle = first + 4,
            get_count = first + 5,
            get_indent = first + 6,
            set_indent = first + 7,
            get_image_list = first + 8,
            set_image_list = first + 9,
            get_next_item = first + 10,
            select_item = first + 11,
            get_edit_control = first + 15,
            get_visible_count = first + 16,
            hit_test = first + 17,
            create_drag_image = first + 18,
            sort = first + 19,
            make_visible = first + 20,
            sort_function = first + 21,
            end_label_edit = first + 22,
            set_tooltips = first + 24,
            get_tooltips = first + 25,
            set_insert_mark = first + 26,
            set_item_height = first + 27,
            get_item_height = first + 28,
            set_background_color = first + 29,
            set_text_color = first + 30,
            get_background_color = first + 31,
            get_text_color = first + 32,
            set_scroll_time = first + 33,
            get_scroll_time = first + 34,
            set_insert_mark_color = first + 37,
            get_insert_mark_color = first + 38,
            get_unicode_format = common_message::get_unicode_format,
            set_unicode_format = common_message::set_unicode_format,
            insert_item = first + 50,
            get_item = first + 62,
            set_item = first + 63,
            edit_label = first + 65,
            get_search_string = first + 64,
        };
    };

    export struct tree_view_notify
    {
        enum
        {
            first = -400,
            last = -499,
            key_down = first - 12,
            single_expand = first - 15,
            selection_changing = first - 50,
            selection_changed = first - 51,
            get_display_information = first - 52,
            set_display_information = first - 53,
            item_expanding = first - 54,
            item_expanded = first - 55,
            begin_drag = first - 56,
            begin_drag_right = first - 57,
            delete_item = first - 58,
            begin_label_edit = first - 59,
            end_label_edit = first - 60,
            information_tip = first - 14,
        };
    };

    export struct tree_view_hit_test_flag
    {
        enum
        {
            nowhere = 0x0001,
            on_item_icon = 0x0002,
            on_item_label = 0x0004,
            on_item_indent = 0x0008,
            on_item_button = 0x0010,
            on_item_right = 0x0020,
            on_item_state_icon = 0x0040,
            on_item = on_item_icon | on_item_label | on_item_state_icon
        };
    };

    export struct tree_view_hit_test_information
    {
        ipoint hit_test;
        uint flags;
        handle item_handle;
    };

    export struct tree_view_image_list_type
    {
        enum
        {
            normal = 0,
            state = 2
        };
    };

    export  typedef int(__stdcall* tree_view_compare)(parameter parameter_a,
        parameter parameter_b,
        parameter parameter_sort);

    export struct tree_view_sort_callback
    {
        handle parent;
        tree_view_compare compare;
        parameter parameter2;
    };

    export struct tree_view_expand_flag
    {
        enum
        {
            collapse = 0x0001,
            expand = 0x0002,
            toggle = 0x0003,
            partial = 0x4000,
            collapse_reset = 0x8000
        };
    };

    export struct tree_view_item_next
    {
        enum
        {
            root = 0x0000,
            next = 0x0001,
            previous = 0x0002,
            parent = 0x0003,
            child = 0x0004,
            visible_first = 0x0005,
            visible_next = 0x0006,
            visible_previous = 0x0007,
            drop_highlight = 0x0008,
            caret = 0x0009,
            last_expanded = 0x000a
        };
    };

    export template<class character>
        struct tree_view_notification : public notify_header
    {
        uint action;
        tree_view_item<character> old_item;
        tree_view_item<character> new_item;
        ipoint drag;
    };

    export template<class character>
        struct tree_view_display_information : public notify_header,
        public tree_view_item<character> {};

    export struct tree_view_custom_draw : public notify_custom_draw
    {
        icolor text_color;
        icolor text_background;
        int level;
    };

    export struct tree_view_information_tip : public notify_header
    {
        character* text;
        int text_maximum;
        handle itemhandle;
        parameter parameter2;
    };

    export struct tree_view_custom_draw_flag { enum { no_images = 0x00010000 }; };

    export  typedef bool(__stdcall* enumerate_desktop_a)(const char*, parameter);
    export  typedef bool(__stdcall* enumerate_desktop_w)(const wchar_t*, parameter);
    export  typedef bool(__stdcall* enumerate_desktop)(const character*, parameter);

    export  typedef bool(__stdcall* enumerate_station_a)(const char*, parameter);
    export  typedef bool(__stdcall* enumerate_station_w)(const wchar_t*, parameter);
    export  typedef bool(__stdcall* enumerate_station)(const wchar_t*, parameter);

    export struct station_access
    {
        enum
        {
            enumerate_desktops = 0x0001,
            read_attributes = 0x0002,
            clipboard = 0x0004,
            create_desktop = 0x0008,
            write_attributes = 0x0010,
            global_atoms = 0x0020,
            exit_windows = 0x0040,
            enumerate = 0x0100,
            read_screen = 0x0200
        };
    };

    export struct station_flag
    {
        enum { visible = 0x0001 };
    };


    export struct desktop_flag
    {
        enum { allow_other_account_hooks = 0x0001 };
    };

    export struct desktop_access
    {
        enum
        {
            read_objects = 0x0001,
            create_window = 0x0002,
            create_menu = 0x0004,
            control_hook = 0x0008,
            record_journal = 0x0010,
            playback_journal = 0x0020,
            enumerate = 0x0040,
            write_objects = 0x0080,
            _switch = 0x0100
        };
    };

    export struct user_object_index
    {
        enum
        {
            flags = 1,
            name = 2,
            type = 3,
            identity = 4
        };
    };

    export struct user_object_flags
    {
        bool inherit;
        bool reserved;
        uint flags;
    };

    export struct server_access
    {
        enum
        {
            administer = 0x00000001,
            enumerate = 0x00000002,
            all = access_type::standard_required | administer | enumerate,
            read = access_type::standard_read | enumerate,
            write = access_type::standard_write | administer | enumerate,
            execute = access_type::standard_execute | enumerate
        };
    };

    export struct printer_access
    {
        enum
        {
            administer = 0x00000004,
            use = 0x00000008,
            all = access_type::standard_required | administer | use,
            read = access_type::standard_read | use,
            write = access_type::standard_write | use,
            execute = access_type::standard_execute | use
        };
    };

    export struct job_access
    {
        enum
        {
            administer = 0x00000010,
            all = access_type::standard_required | administer,
            read = access_type::standard_read | administer,
            write = access_type::standard_write | administer,
            execute = access_type::standard_execute | administer
        };
    };

    export template<class character>
        struct printer_information1
    {
        uint flags;
        const character* description;
        const character* name;
        const character* comment;
    };

    export template<class character>
        struct printer_information2
    {
        const character* server_name;
        const character* printer_name;
        const character* share_name;
        const character* port_name;
        const character* driver_name;
        const character* comment;
        const character* location;
        device_mode<character>* device_mode;
        const character* separator_file;
        const character* print_processor;
        const character* datatype;
        const character* parameters;
        descriptor* descriptor;
        uint attributes;
        uint priority;
        uint default_priority;
        uint start_time;
        uint time_until;
        uint status;
        uint jobs;
        uint average_pages_per_minute;
    };

    export struct printer_information3
    {
        descriptor* security;
    };

    export template<class character>
        struct printer_information4
    {
        const character* printer_name;
        const character* server_name;
        uint attributes;
    };

    export template<class character>
        struct printer_information5
    {
        const character* printer_name;
        const character* port_name;
        uint attributes;
        uint device_not_selected_timeout;
        uint transmission_retry_timeout;
    };

    export struct printer_information6
    {
        uint status;
    };

    export template<class character>
        struct printer_information7
    {
        const character* object_global_identity;
        uint action;
    };

    export struct directory_service
    {
        enum
        {
            publish = 1,
            update = 2,
            unpublish = 3
        };
    };

    export struct printer_control
    {
        enum
        {
            pause = 1,
            resume = 2,
            purge = 3,
            set_status = 4
        };
    };

    export struct printer_status
    {
        enum
        {
            paused = 0x00000001,
            error = 0x00000002,
            deletion_pending = 0x00000004,
            paper_jam = 0x00000008,
            paper_out = 0x00000010,
            manual_feed = 0x00000020,
            paper_problem = 0x00000040,
            offline = 0x00000080,
            input_output_active = 0x00000100,
            busy = 0x00000200,
            printing = 0x00000400,
            output_bin_full = 0x00000800,
            not_available = 0x00001000,
            waiting = 0x00002000,
            processing = 0x00004000,
            initializing = 0x00008000,
            warming_up = 0x00010000,
            toner_low = 0x00020000,
            toner_out = 0x00040000,
            page_punt = 0x00080000,
            user_intervention = 0x00100000,
            out_of_memory = 0x00200000,
            door_open = 0x00400000,
            server_unknown = 0x00800000,
            power_save = 0x01000000
        };
    };

    export struct printer_attribute
    {
        enum
        {
            queued = 0x00000001,
            direct = 0x00000002,
            _default = 0x00000004,
            shared = 0x00000008,
            network = 0x00000010,
            hidden = 0x00000020,
            local = 0x00000040,
            enable_device_queue = 0x00000080,
            keep_printed_jobs = 0x00000100,
            complete_first = 0x00000200,
            work_offline = 0x00000400,
            enable_bidi = 0x00000800,
            raw_only = 0x00001000,
            published = 0x00002000
        };
    };

    export struct print_priority
    {
        enum
        {
            none = 0,
            maximum = 99,
            minimum = 1,
            _default = 1
        };
    };

    export template<class character>
        struct job_information1
    {
        uint job_identity;
        const character* printer_name;
        const character* machine_name;
        const character* user;
        const character* document;
        const character* datatype;
        const character* status_string;
        uint status;
        uint priority;
        uint position;
        uint total_pages;
        uint pages_printed;
        system_time time_submitted;
    };

    export template<class character>
        struct job_information2
    {
        uint job_identity;
        const character* printer_name;
        const character* machine_name;
        const character* user;
        const character* document;
        const character* notify_name;
        const character* datatype;
        const character* print_processor;
        const character* parameters;
        const character* driver_name;
        device_mode<character>* mode;
        const character* status_string;
        descriptor* descriptor;
        uint status;
        uint priority;
        uint position;
        uint start_time;
        uint time_until;
        uint total_pages;
        uint size;
        system_time time_submitted;
        uint time;
        uint pages_printed;
    };

    export struct job_information3
    {
        uint job_identity;
        uint next_job_identity;
        uint reserved;
    };

    export struct job_control
    {
        enum
        {
            pause = 1,
            resume = 2,
            cancel = 3,
            restart = 4,
            _delete = 5,
            sent_to_printer = 6,
            last_page_ejected = 7
        };
    };

    export struct job_status
    {
        enum
        {
            paused = 0x00000001,
            error = 0x00000002,
            deleting = 0x00000004,
            spooling = 0x00000008,
            printing = 0x00000010,
            offline = 0x00000020,
            paper_out = 0x00000040,
            printed = 0x00000080,
            deleted = 0x00000100,
            blocked_device_queue = 0x00000200,
            user_intervention = 0x00000400,
            restart = 0x00000800
        };
    };

    export struct job_position { enum { unspecified = 0 }; };

    export template<class character>
        struct add_job_information
    {
        const character* path;
        uint job_identity;
    };

    export template<class character>
        struct driver_information1
    {
        const character* name;
    };

    export template<class character>
        struct driver_information2
    {
        uint version;
        const character* name;
        const character* environment;
        const character* driver_path;
        const character* data_file;
        const character* configuration_file;
    };

    export template<class character>
        struct driver_information3
    {
        uint version;
        const character* name;
        const character* environment;
        const character* driver_path;
        const character* data_file;
        const character* configuration_file;
        const character* help_file;
        const character* dependent_files;
        const character* monitor_name;
        const character* default_datatype;
    };

    export struct document_information_type
    {
        enum
        {
            channel = 1,
            read_spool_job = 3
        };
    };

    export template<class character>
        struct document_information1
    {
        const character* document;
        const character* file;
        const character* datatype;
    };

    export template<class character>
        struct document_information2
    {
        const character* document;
        const character* file;
        const character* datatype;
        uint mode;
        uint job_identity;
    };

    export template<class character>
        struct form_information
    {
        uint flags;
        const character* name;
        idimensions form;
        irectangle image_area;
    };

    export struct form_flag
    {
        enum
        {
            user = 0x00000000,
            builtin = 0x00000001,
            printer = 0x00000002
        };
    };

    export template<class character>
        struct print_processor_information
    {
        const character* name;
    };

    export template<class character>
        struct port_information1
    {
        const character* name;
    };

    export template<class character>
        struct port_information2
    {
        const character* name;
        const character* monitor_name;
        const character* description;
        uint port_type;
        uint reserved;
    };

    export template<class character>
        struct port_information3
    {
        uint status;
        const character* status_string;
        uint severity;
    };

    export struct port_type
    {
        enum
        {
            write = 0x0001,
            read = 0x0002,
            redirected = 0x0004,
            network_attached = 0x0008
        };
    };

    export struct port_severity
    {
        enum
        {
            error = 1,
            warning = 2,
            information = 3
        };
    };

    export struct port_status
    {
        enum
        {
            offline = 1,
            paper_jam = 2,
            paper_out = 3,
            output_bin_full = 4,
            paper_problem = 5,
            no_toner = 6,
            door_open = 7,
            user_intervention = 8,
            out_of_memory = 9,
            toner_low = 10,
            warming_up = 11,
            power_save = 12
        };
    };

    export template<class character>
        struct monitor_information1
    {
        const character* name;
    };

    export template<class character>
        struct monitor_information2
    {
        const character* name;
        const character* environment;
        const character* library_name;
    };

    export template<class character>
        struct datatypes_information
    {
        const character* name;
    };

    export template<class character>
        struct printer_defaults
    {
        const character* datatype;
        device_mode<character>* device_mode;
        uint desired;
    };

    export template<class character>
        struct providor_information
    {
        const character* name;
        const character* environment;
        const character* library_name;
    };

    export struct enumerate_printers_flag
    {
        enum
        {
            _default = 0x00000001,
            local = 0x00000002,
            connections = 0x00000004,
            favorite = 0x00000004,
            name = 0x00000008,
            remote = 0x00000010,
            shared = 0x00000020,
            network = 0x00000040,

            expand = 0x00004000,
            container = 0x00008000,

            icon_mask = 0x00ff0000,
            icon1 = 0x00010000,
            icon2 = 0x00020000,
            icon3 = 0x00040000,
            icon4 = 0x00080000,
            icon5 = 0x00100000,
            icon6 = 0x00200000,
            icon7 = 0x00400000,
            icon8 = 0x00800000
        };
    };

    export template<class character>
        struct printer_value
    {
        const character* name;
        uint length;
        uint type;
        byte* data;
        uint size;
    };

    export struct printer_change
    {
        enum
        {
            add_printer = 0x00000001,
            set_printer = 0x00000002,
            delete_printer = 0x00000004,
            connection_failed = 0x00000008,
            printer = 0x000000ff,
            add_job = 0x00000100,
            set_job = 0x00000200,
            delete_job = 0x00000400,
            write_job = 0x00000800,
            job = 0x0000ff00,
            add_form = 0x00010000,
            set_form = 0x00020000,
            delete_form = 0x00040000,
            form = 0x00070000,
            add_port = 0x00100000,
            configure_port = 0x00200000,
            delete_port = 0x00400000,
            port = 0x00700000,
            add_print_processor = 0x01000000,
            delete_print_processor = 0x04000000,
            print_processor = 0x07000000,
            add_driver = 0x10000000,
            set_driver = 0x20000000,
            delete_driver = 0x40000000,
            driver = 0x70000000,
            timeout = 0x80000000,
            all = 0x7777ffff
        };
    };

    export struct printer_error
    {
        enum
        {
            information = 0x80000000,
            warning = 0x40000000,
            severe = 0x20000000,
            out_of_paper = 0x00000001,
            jam = 0x00000002,
            out_of_toner = 0x00000004
        };
    };

    export struct driver_upgrade_flag
    {
        enum
        {
            upgrade = 0x0001,
            downgrade = 0x0002,
            copy_all_files = 0x0004,
            copy_new_files = 0x0008
        };
    };

    export struct delete_driver
    {
        enum
        {
            unused_files = 0x0001,
            specific_version = 0x0002,
            all_files = 0x0004
        };
    };

    export struct printer_notify_options_type
    {
        part type;
        part reserved;
        uint reserved1;
        uint reserved2;
        uint count;
        part* members;
    };

    export struct printer_notify_flag
    {
        enum { refresh = 0x01 };
    };

    export struct printer_notify_options
    {
        uint version;
        uint flags;
        uint count;
        printer_notify_options_type* types;
    };

    enum { printer_notify_information_discarded = 0x01 };

    export struct printer_notify_information_data
    {
        part type;
        part member;
        uint reserved;
        uint identity;
        uint size;
        void* buffer;
    };

    export struct printer_notify_information
    {
        uint version;
        uint flags;
        uint count;
        printer_notify_information_data array_data[1];
    };

    export struct notify_type
    {
        enum
        {
            printer = 0x00,
            job = 0x01
        };
    };

    export struct printer_notify_member
    {
        enum
        {
            server_name = 0x00,
            printer_name = 0x01,
            share_name = 0x02,
            port_name = 0x03,
            driver_name = 0x04,
            comment = 0x05,
            location = 0x06,
            device_mode = 0x07,
            separator_file = 0x08,
            print_processor = 0x09,
            parameters = 0x0a,
            datatype = 0x0b,
            security_descriptor = 0x0c,
            attributes = 0x0d,
            priority = 0x0e,
            default_priority = 0x0f,
            start_time = 0x10,
            until_time = 0x11,
            status = 0x12,
            status_string = 0x13,
            number_ofjobs = 0x14,
            average_pages_per_minute = 0x15,
            total_pages = 0x16,
            pages_printed = 0x17,
            total_bytes = 0x18,
            bytes_printed = 0x19,
            object_globally_unique_identity = 0x1a
        };
    };

    export struct job_notify_member
    {
        enum
        {
            printer_name = 0x00,
            machine_name = 0x01,
            port_name = 0x02,
            user_name = 0x03,
            notify_name = 0x04,
            datatype = 0x05,
            print_processor = 0x06,
            parameters = 0x07,
            driver_name = 0x08,
            device_mode = 0x09,
            status = 0x0a,
            status_string = 0x0b,
            security_descriptor = 0x0c,
            document = 0x0d,
            priority = 0x0e,
            position = 0x0f,
            submitted = 0x10,
            start_time = 0x11,
            until_time = 0x12,
            time = 0x13,
            total_pages = 0x14,
            pages_printed = 0x15,
            total_bytes = 0x16,
            bytes_printed = 0x17
        };
    };

    export struct list_view_style
    {
        enum
        {
            icon = 0x0000,
            report = 0x0001,
            small_icon = 0x0002,
            list = 0x0003,
            type_mask = 0x0003,
            single_select = 0x0004,
            show_selection_always = 0x0008,
            sort_ascending = 0x0010,
            sort_descending = 0x0020,
            share_image_lists = 0x0040,
            no_label_wrap = 0x0080,
            auto_arrange = 0x0100,
            edit_labels = 0x0200,
            owner_data = 0x1000,
            no_scroll = 0x2000,
            type_style_mask = 0xfc00,
            align_top = 0x0000,
            align_left = 0x0800,
            align_mask = 0x0c00,
            owner_draw_fixed = 0x0400,
            no_column_header = 0x4000,
            no_sort_header = 0x8000,
        };
    };

    export struct list_view_message
    {
        enum
        {
            first = 0x1000,
            set_unicode_format = common_message::set_unicode_format,
            get_unicode_format = common_message::get_unicode_format,
            get_background_color = first + 0,
            set_background_color = first + 1,
            get_image_list = first + 2,
            set_image_list = first + 3,
            get_item_count = first + 4,
            delete_item = first + 8,
            delete_all_items = first + 9,
            get_callback_mask = first + 10,
            set_callback_mask = first + 11,
            get_next_item = first + 12,
            get_item_rectangle = first + 14,
            set_item_position = first + 15,
            get_item_position = first + 16,
            hit_test = first + 18,
            ensure_visible = first + 19,
            scroll = first + 20,
            redraw_items = first + 21,
            arrange = first + 22,
            get_edit_control = first + 24,
            delete_column = first + 28,
            get_column_width = first + 29,
            set_column_width = first + 30,
            get_header = first + 31,
            create_drag_image = first + 33,
            get_view_rectangle = first + 34,
            get_text_color = first + 35,
            set_text_color = first + 36,
            get_text_background_color = first + 37,
            set_text_background_color = first + 38,
            get_top_index = first + 39,
            get_count_per_page = first + 40,
            get_origin = first + 41,
            update = first + 42,
            set_item_state = first + 43,
            get_item_state = first + 44,
            set_item_count = first + 47,
            sort_items = first + 48,
            set_item_position32 = first + 49,
            get_selected_count = first + 50,
            get_item_spacing = first + 51,
            set_icon_spacing = first + 53,
            set_extended_list_view_style = first + 54,
            get_extended_list_view_style = first + 55,
            get_subitem_rectangle = first + 56,
            subitem_hit_test = first + 57,
            set_column_order_array = first + 58,
            get_column_order_array = first + 59,
            set_hot_item = first + 60,
            get_hot_item = first + 61,
            set_hot_cursor = first + 62,
            get_hot_cursor = first + 63,
            approximate_view_rectangle = first + 64,
            set_work_areas = first + 65,
            get_work_areas = first + 70,
            get_number_of_work_areas = first + 73,
            get_selection_mark = first + 66,
            set_selection_mark = first + 67,
            set_hover_time = first + 71,
            get_hover_time = first + 72,
            set_tool_tips = first + 74,
            get_tool_tips = first + 78,
            sort_items_extended = first + 81,
            set_selected_column = first + 140,
            set_view = first + 142,
            get_view = first + 143,
            insert_group = first + 145,
            set_group_information = first + 147,
            get_group_information = first + 149,
            remove_group = first + 150,
            move_group = first + 151,
            get_group_count = first + 152,
            get_group_information_by_index = first + 153,
            move_item_to_group = first + 154,
            get_group_rectangle = first + 98,
            set_group_metrics = first + 155,
            get_group_metrics = first + 156,
            enable_group_view = first + 157,
            sort_groups = first + 158,
            insert_group_sorted = first + 159,
            remove_all_groups = first + 160,
            has_group = first + 161,
            get_group_state = first + 92,
            get_focused_group = first + 93,
            set_tile_view_information = first + 162,
            get_tile_view_information = first + 163,
            set_tile_information = first + 164,
            get_tile_information = first + 165,
            set_insert_mark = first + 166,
            get_insert_mark = first + 167,
            insert_mark_hit_test = first + 168,
            get_insert_mark_rectangle = first + 169,
            set_insert_mark_color = first + 170,
            get_insert_mark_color = first + 171,
            set_information_tip = first + 173,
            get_selected_column = first + 174,
            is_group_view_enabled = first + 175,
            get_outline_color = first + 176,
            set_outline_color = first + 177,
            cancel_edit_label = first + 179,
            map_index_to_identity = first + 180,
            map_identity_to_index = first + 181,
            is_item_visible = first + 182,
            get_empty_text = first + 204,
            get_footer_rectangle = first + 205,
            get_footer_information = first + 206,
            get_footer_item_rectangle = first + 207,
            get_footer_item = first + 208,
            get_item_index_rectangle = first + 209,
            set_item_index_state = first + 210,
            get_next_item_index = first + 211,
            get_item = first + 75,
            set_item = first + 76,
            insert_item = first + 77,
            find_item = first + 83,
            get_string_width = first + 87,
            edit_label = first + 118,
            get_column = first + 95,
            set_column = first + 96,
            insert_column = first + 97,
            get_item_text = first + 115,
            set_item_text = first + 116,
            get_incremental_search_string = first + 117,
            set_background_image = first + 138,
            get_background_image = first + 139,
        };
    };

    export struct list_view_notify
    {
        enum
        {
            first = 0,
            item_changing = first - 0,
            item_changed = first - 1,
            insert_item = first - 2,
            delete_item = first - 3,
            delete_all_items = first - 4,
            column_click = first - 8,
            begin_drag = first - 9,
            begin_r_drag = first - 11,
            od_cache_hint = first - 13,
            item_activate = first - 14,
            od_state_handled = first - 15,
            hot_track = first - 21,
            begin_label_edit = first - 75,
            end_label_edit = first - 76,
            get_display_information = first - 77,
            set_display_information = first - 78,
            od_find_item = first - 79,
        };
    };

    export struct notify_message_header
    {
        handle from;
        uint identity;
        uint code;
    };

    export struct notify_message_list_view_state_change : public notify_message_header
    {
        int from;
        int to;
        uint new_state;
        uint old_state;
    };

    export template<class character>
        struct list_view_find_information
    {
        uint flags;
        character* string;
        parameter parameter;
        ipoint point;
        uint direction;
    };

    export template<class character>
        struct notify_message_list_view_find_item : public notify_message_header
    {
        int start;
        list_view_find_information<character> find_information;
    };

    export struct notify_message_list_view_cache_hint : public notify_message_header
    {
        int from;
        int to;
    };

    export struct notify_message_list_view : public notify_message_header
    {
        int item;
        int subitem;
        uint new_state;
        uint old_state;
        uint changed;
        ipoint action;
        parameter parameter;
    };

    export struct notify_message_item_activate : public notify_message_list_view
    {
        uint key_flags;
    };


    export struct notify_message_list_view_custom_draw
    {
        notify_message_custom_draw notify;
        icolor text_color;
        icolor text_background_color;
        int subitem;
        uint item_type;
        icolor face;
        int icon_effect;
        int icon_phase;
        int part_identity;
        int state_identity;
        irectangle text_rectangle;
        uint alignment;
    };

    export struct list_view_custom_draw_item_type
    {
        enum
        {
            item = 0x00000000,
            group = 0x00000001
        };
    };

    export struct list_view_custom_draw_return_flag
    {
        enum
        {
            no_select = 0x00010000,
            no_group_frame = 0x00020000
        };
    };

    export struct list_view_key_flags
    {
        enum
        {
            alt = 0x0001,
            control = 0x0002,
            shift = 0x0004
        };
    };

    export struct list_view_item_index
    {
        int item;
        int group;
    };

    export struct list_view_footer_item
    {
        uint mask;
        int item;
        wchar_t* text;
        int text_maximum;
        uint state;
        uint state_mask;
    };

    export struct list_view_footer_item_flags
    {
        enum
        {
            text = 0x00000001,
            state = 0x00000002
        };
    };

    export struct list_view_item_flag
    {
        enum
        {
            focused = 0x0001
        };
    };

    export template<class character>
        struct list_view_footer_information
    {
        uint mask;
        character* text;
        int text_maximum;
        uint items;
    };

    export struct list_view_footer_flags
    {
        enum
        {
            item_count = 0x00000001
        };
    };

    export template<class character>
        struct list_view_set_information_tip
    {
        uint size;
        uint flags;
        character* text;
        int item;
        int subitem;
    };

    export struct list_view_insert_mark
    {
        uint size;
        uint flags;
        int item;
        uint reserved;
    };

    enum { list_view_insert_mark_after = 0x00000001 };

    export struct list_view_tile_view_information
    {
        uint size;
        uint mask;
        uint flags;
        size_t tile;
        int lines;
        irectangle label_margin;
    };

    export struct list_view_tile_information
    {
        uint size;
        int item;
        uint columns_count;
        uint* columns;
        int* column_format;
    };

    export struct list_view_tile_view_information_flags
    {
        enum
        {
            auto_size = 0x00000000,
            fixed_width = 0x00000001,
            fixed_height = 0x00000002,
            fixed_size = 0x00000003,
            extended = 0x00000004
        };
    };

    export struct list_view_tile_view_insert_mark
    {
        enum
        {
            tile_size = 0x00000001,
            columns = 0x00000002,
            label_margin = 0x00000004
        };
    };

    export  typedef int(__stdcall* list_view_group_compare)(int, int, void*);

    export template<class character>
        struct list_view_group
    {
        uint size;
        uint mask;
        character* header;
        int header_length;
        character* footer;
        int footer_length;
        int group_identity;
        uint state_mask;
        uint state;
        uint align;
        character* subtitle;
        uint subtitle_length;
        character* task;
        uint task_length;
        character* description_top;
        uint description_top_length;
        character description_bottom;
        uint description_bottom_length;
        int title_image;
        int extended_image;
        int first_item;
        uint items;
        character* subset_title;
        uint subset_title_length;
    };

    export template<class character>
        struct insert_group_sorted
    {
        list_view_group_compare group_compare;
        void* data;
        list_view_group<character> group;
    };

    export struct list_view_group_metrics
    {
        uint size;
        uint mask;
        uint left;
        uint top;
        uint right;
        uint bottom;
        icolor left_color;
        icolor top_color;
        icolor right_color;
        icolor bottom_color;
        icolor header_color;
        icolor footer_color;
    };

    export struct list_view_group_metrics_flags
    {
        enum
        {
            none = 0x00000000,
            border_size = 0x00000001,
            border_color = 0x00000002,
            text_color = 0x00000004
        };
    };

    export struct list_view_get_group_rectangle
    {
        enum
        {
            group = 0,
            header = 1,
            label = 2,
            subset_link = 3
        };
    };

    export struct list_view_group_flags
    {
        enum
        {
            none = 0x00000000,
            header = 0x00000001,
            footer = 0x00000002,
            state = 0x00000004,
            align = 0x00000008,
            group_identity = 0x00000010,
            subtitle = 0x00000100,
            task = 0x00000200,
            description_top = 0x00000400,
            description_bottom = 0x00000800,
            title_image = 0x00001000,
            extended_image = 0x00002000,
            items = 0x00004000,
            subset = 0x00008000,
            subset_items = 0x00010000
        };
    };

    export struct list_view_group_style
    {
        enum
        {
            normal = 0x00000000,
            collapsed = 0x00000001,
            hidden = 0x00000002,
            no_header = 0x00000004,
            collapsible = 0x00000008,
            focused = 0x00000010,
            selected = 0x00000020,
            has_subset = 0x00000040,
            sub_set_link_focused = 0x00000080
        };
    };

    export struct list_view_group_attributes
    {
        enum
        {
            header_left = 0x00000001,
            header_centre = 0x00000002,
            header_right = 0x00000004,
            footer_left = 0x00000008,
            footer_centre = 0x00000010,
            footer_right = 0x00000020
        };
    };

    export struct list_view_view
    {
        enum
        {
            icon = 0x0000,
            details = 0x0001,
            small_icon = 0x0002,
            list = 0x0003,
            tile = 0x0004,
            maximum = 0x0004
        };
    };

    export struct list_view_background_image_flags
    {
        enum
        {
            source_none = 0x00000000,
            source_bitmap = 0x00000001,
            source_url = 0x00000002,
            source_mask = 0x00000003,
            style_normal = 0x00000000,
            style_tile = 0x00000010,
            style_mask = 0x00000010,
            tile_offset = 0x00000100,
            type_water_mark = 0x10000000,
            alpha_blend = 0x20000000
        };
    };

    export struct list_view_background_image
    {
        uint flags;
        handle bitmap;
        character* image;
        uint image_maximum;
        int x_offset_percent;
        int y_offset_percent;
    };

    enum { list_view_maximum_work_areas = 16 };

    export struct list_view_extended_style
    {
        enum
        {
            grid_lines = 0x00000001,
            subitem_images = 0x00000002,
            check_boxes = 0x00000004,
            track_select = 0x00000008,
            header_drag_drop = 0x00000010,
            full_row_select = 0x00000020,
            one_click_activate = 0x00000040,
            two_click_activate = 0x00000080,
            flat_scroll_bar = 0x00000100,
            regional = 0x00000200,
            information_tip = 0x00000400,
            underline_hot = 0x00000800,
            underline_cold = 0x00001000,
            multi_work_areas = 0x00002000,
            label_tip = 0x00004000,
            border_select = 0x00008000,
            double_buffer = 0x00010000,
            hide_labels = 0x00020000,
            single_row = 0x00040000,
            snap_to_grid = 0x00080000,
            simple_select = 0x00100000,
            justify_columns = 0x00200000,
            transparent_background = 0x00400000,
            transparent_shadow_text = 0x00800000,
            auto_arrange = 0x01000000,
            header_in_all_views = 0x02000000,
            auto_check_select = 0x08000000,
            auto_size_columns = 0x10000000,
            column_snap_points = 0x40000000,
            column_overflow = 0x80000000
        };
    };

    export  typedef int(__stdcall* list_view_compare)(parameter, parameter, parameter);

    export struct list_view_style_item_count_format
    {
        enum
        {
            no_invalidate_all = 0x00000001,
            no_scroll = 0x00000002
        };
    };

    export struct list_view_set_column_width
    {
        enum
        {
            auto_size = -1,
            auto_size_use_header = -2
        };
    };

    export struct list_view_column_flags
    {
        enum
        {
            format = 0x0001,
            width = 0x0002,
            text = 0x0004,
            subitem = 0x0008,
            image = 0x0010,
            order = 0x0020,
            minimum_width = 0x0040,
            default_width = 0x0080,
            ideal_width = 0x0100
        };
    };

    export struct list_view_column_format
    {
        enum
        {
            left = 0x0000,
            right = 0x0001,
            centre = 0x0002,
            justify_mask = 0x0003,
            image = 0x0800,
            bitmap_on_right = 0x1000,
            column_has_images = 0x8000,
            fixed_width = 0x00100,
            no_dots_per_inch_scale = 0x40000,
            fixed_ratio = 0x80000,
            line_break = 0x100000,
            fill = 0x200000,
            wrap = 0x400000,
            no_title = 0x800000,
            split_button = 0x1000000,
            tile_placement_mask = line_break | fill
        };
    };

    export template<class character>
        struct list_view_column
    {
        uint mask;
        int format;
        int width;
        character* text;
        int text_maximum;
        int subitem;
        int image;
        int order;
        int minimum_width;
        int default_width;
        int ideal_width;
    };

    export struct list_view_arrange
    {
        enum
        {
            _default = 0x0000,
            align_left = 0x0001,
            align_top = 0x0002,
            snap_to_grid = 0x0005
        };
    };

    export struct list_view_hit_test_information
    {
        ipoint position;
        uint flags;
        int item;
        int subitem;
        int group;
    };

    export struct list_view_hit_test
    {
        enum
        {
            nowhere = 0x00000001,
            on_item_icon = 0x00000002,
            on_item_label = 0x00000004,
            on_item_state_icon = 0x00000008,
            on_item = on_item_icon | on_item_label | on_item_state_icon,
            above = 0x00000008,
            below = 0x00000010,
            to_right = 0x00000020,
            to_left = 0x00000040,
            group_header = 0x10000000,
            group_footer = 0x20000000,
            group_collapse = 0x40000000,
            group_background = 0x80000000,
            group_state_icon = 0x01000000,
            group_subset_link = 0x02000000,
            group = group_background |
            group_collapse |
            group_footer |
            group_header |
            group_state_icon |
            group_subset_link,
            on_contents = 0x04000000, // on item, not on the background
            footer = 0x08000000
        };
    };

    export struct list_view_item_rectangle
    {
        enum
        {
            bounds = 0,
            icon = 1,
            label = 2,
            select_bounds = 3
        };
    };

    export struct list_view_image_list
    {
        enum
        {
            normal = 0,
            small = 1,
            state = 2,
            group_header = 3
        };
    };

    export struct list_view_next_item
    {
        enum
        {
            all = 0x0000,

            focused = 0x0001,
            selected = 0x0002,
            cute = 0x0004,
            drop_highlighted = 0x0008,

            state_mask = focused | selected | cute | drop_highlighted,

            visible_order = 0x0010,
            previous = 0x0020,
            visible_only = 0x0040,
            same_group_only = 0x0080,

            above = 0x0100,
            below = 0x0200,
            to_left = 0x0400,
            to_right = 0x0800,

            direction_mask = above | below | to_left | to_right,
        };
    };

    export struct list_view_find_information_flags
    {
        enum
        {
            parameter = 0x0001,
            string = 0x0002,
            substring = 0x0004,  // same as partial
            partial = 0x0008,
            wrap = 0x0020,
            nearest_xy = 0x0040
        };
    };

    export template<class character>
        struct list_view_item
    {
        uint mask;
        int item;
        int subitem;
        uint state;
        uint state_mask;
        character* text;
        int text_maximum;
        int image;
        parameter parameter;
        int indent;
        int group_identity;
        uint columns;
        uint* columns_widths;
        int* color_format;
        int group;
    };

    export struct list_view_item_flags
    {
        enum
        {
            text = 0x00000001,
            image = 0x00000002,
            parameter = 0x00000004,
            state = 0x00000008,
            indent = 0x00000010,
            no_recompute = 0x00000800,
            group_identity = 0x00000100,
            columns = 0x00000200,
            color_format = 0x00010000,
            display_information_set_item = 0x00001000,
        };
    };

    export struct list_view_item_state
    {
        enum
        {
            focused = 0x0001,
            selected = 0x0002,
            cut = 0x0004,
            drop_highlighted = 0x0008,
            glow = 0x0010,
            activating = 0x0020,
            overlay_mask = 0x0f00,
            state_image_mask = 0xf000,
        };
    };

    export struct list_view_key_down : public notify_message_header
    {
        short virtual_key;
        uint flags;
    };

    export  enum { maximum_link_identity_text = 48 };

    export  enum { maximum_url_length = 2048 + 32 + sizeof("://") };

    export struct link_item
    {
        uint  mask;
        int link;
        uint state;
        uint state_mask;
        wchar_t identity[maximum_link_identity_text];
        wchar_t url[maximum_url_length];
    };

    export struct list_view_link : public notify_message_header
    {
        link_item link;
        int item;
        int subitem;
    };

    export template<class character>
        struct list_view_get_information_tip : notify_message_header
    {
        uint flags;
        character* text;
        int text_maximum;
        int item;
        int subitem;
        parameter param;
    };

    export  enum list_view_get_information_tip_flags { list_view_get_information_tip_unfolded = 0x0001 };

    export struct list_view_notify_search_flags
    {
        enum
        {
            _default = -1,
            error = -2,
            ignore = -3
        };
    };

    export struct list_view_scroll : public notify_message_header
    {
        int width;
        int height;
    };

    export  enum list_view_empty_markup_flags { empty_markup_centered = 0x00000001 };

    export struct list_view_empty_markup : public notify_message_header
    {
        uint flags;
        wchar_t markup[maximum_url_length];   // markup displayed
    };

    export struct toolbar_button
    {
        int bitmap;
        int command;
        byte state;
        byte style;
        byte reserved[6];
        ulong data;
        long string;
    };

    export struct color_map
    {
        icolor from;
        icolor to;
    };

    export struct toolbar_state
    {
        enum
        {
            checked = 0x01,
            pressed = 0x02,
            enabled = 0x04,
            hidden = 0x08,
            indeterminate = 0x10,
            wrap = 0x20,
            ellipses = 0x40,
            marked = 0x80,
        };
    };

    export struct toolbar_style
    {
        enum
        {
            button = 0x0000,
            separator = 0x0001,
            check = 0x0002,
            group = 0x0004,
            check_group = group | check,
            drop_down = 0x0008,
            auto_size = 0x0010,
            no_prefix = 0x0020,
            tool_tips = 0x0100,
            wrapable = 0x0200,
            alt_drag = 0x0400,
            flat = 0x0800,
            list = 0x1000,
            custom_erase = 0x2000,
            register_drop = 0x4000,
            transparent = 0x8000,
        };
    };

    export struct toolbar_style_extended
    {
        enum
        {
            draw_dd_arrows = 0x00000001,
            mixed_buttons = 0x00000008,
            hide_clipped_buttons = 0x00000010,
            double_buffer = 0x00000080,
        };
    };

    export struct button_styles
    {
        enum
        {
            button = toolbar_style::button,
            separator = toolbar_style::separator,
            check = toolbar_style::check,
            group = toolbar_style::group,
            check_group = toolbar_style::check_group,
            drop_down = toolbar_style::drop_down,
            auto_size = toolbar_style::auto_size,
            no_prefix = toolbar_style::no_prefix,
            show_text = 0x0040,
            whole_dropdown = 0x0080,
        };
    };

    export struct toolbar_custom_draw : public notify_message_custom_draw
    {
        handle mono_dither;
        handle lines_brush;
        handle lines_pen;
        icolor text;
        icolor mark;
        icolor text_highlight;
        icolor button_face;
        icolor button_highlight;
        icolor highlight_hot_track;
        irectangle text_rectangle;
        int string_background_mode;
        int highlight_string_background_mode;
        int list_gap;
    };

    export struct toolbar_custom_draw_return_flag
    {
        enum
        {
            no_edges = 0x00010000,
            highlight_hot_track = 0x00020000,
            no_offset = 0x00040000,
            no_mark = 0x00080000,
            no_etched_effect = 0x00100000,
            blend_icon = 0x00200000,
            no_background = 0x00400000,
            use_custom_draw_colors = 0x00800000,
        };
    };

    export struct toolbar_dd_bitmap
    {
        handle instance;
        ulong identity;
    };

    export struct identity_button
    {
        enum
        {
            standard_small_color = 0,
            standard_large_color = 1,
            view_small_color = 4,
            view_large_color = 5,
            history_small_color = 8,
            history_large_color = 9,
            history_normal = 12,
            history_hot = 13,
            history_disabled = 14,
            history_pressed = 15,
        };
    };

    export struct standard_icon_index
    {
        enum
        {
            cut = 0,
            copy = 1,
            paste = 2,
            undo = 3,
            redo = 4,
            _delete = 5,
            file_new = 6,
            file_open = 7,
            file_save = 8,
            print_preview = 9,
            properties = 10,
            help = 11,
            find = 12,
            replace = 13,
            print = 14,
        };
    };

    export struct view_icon_index
    {
        enum
        {
            large_icons = 0,
            small_icons = 1,
            list = 2,
            details = 3,
            sort_name = 4,
            sort_size = 5,
            sort_date = 6,
            sort_type = 7,
            parent_folder = 8,
            net_connect = 9,
            net_disconnect = 10,
            new_folder = 11,
            menu = 12,
            history_back = 0,
            history_forward = 1,
            history_favorites = 2,
            history_add_to_favorites = 3,
            history_view_tree = 4,
        };
    };

    export struct toolbar_notify
    {
        enum
        {
            first = 0u - 700u,
            begin_drag = first - 1,
            end_drag = first - 2,
            begin_adjust = first - 3,
            end_adjust = first - 4,
            reset = first - 5,
            query_insert = first - 6,
            query_delete = first - 7,
            toolbar_change = first - 8,
            custom_help = first - 9,
            drop_down = first - 10,
            get_object = first - 12,
            hot_item_change = first - 13,
            drag_out = first - 14,
            deleting_button = first - 15,
            restore = first - 21,
            save = first - 22,
            initialize_customize = first - 23,
        };

        enum
        {
            get_information_tip_w = first - 19,
            get_button_information_w = first - 20,
            get_display_information_w = first - 17,
        };

        enum
        {
            get_information_tip_a = first - 18,
            get_button_information_a = first - 0,
            get_display_information_a = first - 16,
        };
    };

    export struct toolbar_notify_flag
    {
        enum
        {
            image = 0x00000001,
            text = 0x00000002,
            set_item = 0x10000000,
        };
    };

    export struct toolbar_notify_restore_flag
    {
        enum
        {
            hide_help = 0x00000001,
            end_customize = 0x00000002,
        };
    };

    export template<class character>
        struct toolbar_save_parameters
    {
        handle key;
        character* subkey;
        character* value_name;
    };

    export struct toolbar_insert_mark
    {
        int button;
        uint flags;
    };

    export  enum toobar_insert_mark_hit
    {
        after = 0x00000001,
        background = 0x00000002,
    };

    export struct toolbar_replace_bitmap
    {
        handle instance_old;
        ulong identity_old;
        handle instance_new;
        ulong identity_new;
        int buttons;
    };

    export struct toolbar_button_flag { enum { large = 0x0001 }; };

    export struct toolbar_button_information_flag
    {
        enum
        {
            image = 0x00000001,
            text = 0x00000002,
            state = 0x00000004,
            style = 0x00000008,
            parameter = 0x00000010,
            command = 0x00000020,
            size = 0x00000040,
            by_index = 0x80000000,
        };
    };

    export template<class character>
        struct toolbar_button_information
    {
        uint size;
        uint mask;
        int command;
        int image;
        byte state;
        byte style;
        part width;
        ulong parameter;
        character* text;
        int text_size;
    };

    export struct toolbar_message
    {
        enum
        {
            enable_button = message::user + 1,
            check_button = message::user + 2,
            press_button = message::user + 3,
            hide_button = message::user + 4,
            indeterminate = message::user + 5,
            mark_button = message::user + 6,
            is_button_enabled = message::user + 9,
            is_button_checked = message::user + 10,
            is_button_pressed = message::user + 11,
            is_button_hidden = message::user + 12,
            is_button_indeterminate = message::user + 13,
            is_button_highlighted = message::user + 14,
            set_state = message::user + 17,
            get_state = message::user + 18,
            add_bitmap = message::user + 19,
            delete_button = message::user + 22,
            get_button = message::user + 23,
            button_count = message::user + 24,
            command_to_index = message::user + 25,
            customize = message::user + 27,
            get_itemrectangle = message::user + 29,
            button_structure_size = message::user + 30,
            set_button_size = message::user + 31,
            set_bitmap_size = message::user + 32,
            auto_size = message::user + 33,
            get_tool_tips = message::user + 35,
            set_tool_tips = message::user + 36,
            set_parent = message::user + 37,
            set_rows = message::user + 39,
            get_rows = message::user + 40,
            get_bitmap_flags = message::user + 41,
            set_command_identity = message::user + 42,
            change_bitmap = message::user + 43,
            get_bitmap = message::user + 44,
            replace_bitmap = message::user + 46,
            set_indent = message::user + 47,
            set_image_list = message::user + 48,
            get_image_list = message::user + 49,
            load_images = message::user + 50,
            get_rectangle = message::user + 51,
            set_hot_image_list = message::user + 52,
            get_hot_image_list = message::user + 53,
            set_disabled_image_list = message::user + 54,
            get_disabled_image_list = message::user + 55,
            set_style = message::user + 56,
            get_style = message::user + 57,
            get_button_size = message::user + 58,
            set_button_width = message::user + 59,
            set_maximum_text_rows = message::user + 60,
            get_text_rows = message::user + 61,
            get_object = message::user + 62,
            get_hot_item = message::user + 71,
            set_hot_item = message::user + 72,
            set_anchor_highlight = message::user + 73,
            get_anchor_highlight = message::user + 74,
            get_insert_mark = message::user + 79,
            set_insert_mark = message::user + 80,
            insert_mark_hit_test = message::user + 81,
            move_button = message::user + 82,
            get_maximum_size = message::user + 83,
            set_extended_style = message::user + 84,
            get_extended_style = message::user + 85,
            get_padding = message::user + 86,
            set_padding = message::user + 87,
            set_insert_mark_color = message::user + 88,
            get_insert_mark_color = message::user + 89,
            set_color_scheme = common_message::set_color_scheme,
            get_color_scheme = common_message::get_color_scheme,
            set_unicode_format = common_message::set_unicode_format,
            get_unicode_format = common_message::get_unicode_format,
            hit_test = message::user + 69,
            set_draw_text_flags = message::user + 70,
            get_metrics = message::user + 101,
            set_metrics = message::user + 102,
            set_pressed_image_list = message::user + 104,
            get_pressed_image_list = message::user + 105,
            set_window_theme = common_message::set_window_theme,
        };

        enum
        {
            get_button_text_w = message::user + 75,
            save_restore_w = message::user + 76,
            add_string_w = message::user + 77,
            map_accelerator_w = message::user + 90,
            get_button_information_w = message::user + 63,
            set_button_information_w = message::user + 64,
            insert_button_w = message::user + 67,
            add_buttons_w = message::user + 68,
            get_string_w = message::user + 91,
        };

        enum
        {
            get_button_text_a = message::user + 45,
            save_restore_aw = message::user + 26,
            add_string_a = message::user + 28,
            map_accelerator_a = message::user + 78,
            get_button_information_a = message::user + 65,
            set_button_information_a = message::user + 66,
            insert_button_a = message::user + 21,
            add_buttons_a = message::user + 20,
            get_string_a = message::user + 92,
        };
    };

    export struct toolbar_metrics_flag
    {
        enum
        {
            pad = 0x00000001,
            bar_pad = 0x00000002,
            button_spacing = 0x00000004,
        };
    };

    export struct toolbar_metrics
    {
        uint size;
        uint mask;
        int pad_width;
        int pad_height;
        int bar_pad_width;
        int bar_pad_height;
        int button_spacing_width;
        int button_spacing_height;
    };

    export struct notify_message_toolbar_hot_item : public notify_message_header
    {
        int identity_old;
        int identity_new;
        uint  flags;
    };

    export struct hot_item_change_flag
    {
        enum
        {
            other = 0x00000000,
            mouse = 0x00000001,
            arrow_keys = 0x00000002,
            accelerator = 0x00000004,
            duplicate_accelerator = 0x00000008,
            entering = 0x00000010,
            leaving = 0x00000020,
            reselect = 0x00000040,
            left_mouse = 0x00000080,
            toggle_dropdown = 0x00000100,
        };
    };

    export struct notify_message_toolbar_save : public notify_message_header
    {
        uint* data;
        uint* current;
        uint data_size;
        int item;
        int buttons;
        toolbar_button button;
    };

    export struct notify_message_toolbar_restore : public notify_message_header
    {
        uint* data;
        uint* current;
        uint data_size;
        int item;
        int buttons;
        int bytes_per_record;
        toolbar_button button;
    };

    export template<class character>
        struct notify_message_toolbar_get_information_tip : public notify_message_header
    {
        character* text;
        int text_size;
        int item;
        parameter parameter;
    };

    export template<class character>
        struct notify_message_display_information : public notify_message_header
    {
        uint mask;
        int command_identity;
        ulong parameter;
        int image;
        character* text;
        int text_size;
    };

    export struct tool_bar_notify_drop_down_return
    {
        enum
        {
            _default = 0,
            no_default = 1,
            treat_pressed = 2,
        };
    };

    export template<class character>
        struct notify_message_toolbar : public notify_message_header
    {
        int item;
        toolbar_button button;
        int text_size;
        character* text;
        irectangle button_rectangle;
    };

    export struct rebar_image_list
    {
        enum
        {
            image_list = 0x00000001
        };
    };

    export struct rebar_style
    {
        enum
        {
            tool_tips = 0x00000100,
            variable_height = 0x00000200,
            band_borders = 0x00000400,
            fixed_order = 0x00000800,
            register_drop = 0x00001000,
            autosize = 0x00002000,
            vertical_griper = 0x00004000,
            double_click_toggle = 0x00008000,
        };
    };

    export struct rebar_information
    {
        uint size;
        uint mask;
        handle image_list;
    };

    export struct rebar_band_style
    {
        enum
        {
            _break = 0x00000001,
            fixed_size = 0x00000002,
            childedge = 0x00000004,
            hidden = 0x00000008,
            no_vertical = 0x00000010,
            fixed_bitmap = 0x00000020,
            variable_height = 0x00000040,
            grisharper_always = 0x00000080,
            no_grisharper = 0x00000100,
            use_chevron = 0x00000200,
            hide_title = 0x00000400,
            top_align = 0x00000800,
        };
    };

    export struct rebar_band_information_member
    {
        enum
        {
            style = 0x00000001,
            colors = 0x00000002,
            text = 0x00000004,
            image = 0x00000008,
            child = 0x00000010,
            child_size = 0x00000020,
            size = 0x00000040,
            background = 0x00000080,
            identity = 0x00000100,
            ideal_size = 0x00000200,
            parameter = 0x00000400,
            header_size = 0x00000800,
            chevron_location = 0x00001000,
            chevron_state = 0x00002000,
        };
    };

    export template<class character>
        struct rebar_band_information
    {
        uint size;
        uint mask;
        uint style;
        icolor foreground_color;
        icolor background_color;
        character* text;
        uint text_size;
        int image;
        handle child;
        uint minimum_child_width;
        uint minimum_child_height;
        uint width;
        handle background;
        uint identity;
        uint child_height;
        uint maximum_child_height;
        uint integral_height;
        uint ideal_width;
        parameter parameter;
        uint header_width;
        irectangle chevron_location;
        uint chevron_state;
    };

    export  enum { rebar_size_to_rectangle_change_rectangle = 0x0001 };

    export struct rebar_message
    {
        enum
        {
            delete_band = message::user + 2,
            get_bar_information = message::user + 3,
            set_bar_information = message::user + 4,
            set_parent = message::user + 7,
            hit_test = message::user + 8,
            get_rectangle_angle = message::user + 9,
            get_band_count = message::user + 12,
            get_row_count = message::user + 13,
            get_row_height = message::user + 14,
            identity_to_index = message::user + 16,
            get_tool_tips = message::user + 17,
            set_tool_tips = message::user + 18,
            set_background_color = message::user + 19,
            get_background_color = message::user + 20,
            set_text_color = message::user + 21,
            get_text_color = message::user + 22,
            size_to_rectangle = message::user + 23,
            set_color_scheme = common_message::set_color_scheme,
            get_color_scheme = common_message::get_color_scheme,
            begin_drag = message::user + 24,
            end_drag = message::user + 25,
            drag_move = message::user + 26,
            get_bar_height = message::user + 27,
            minimize_band = message::user + 30,
            maximize_band = message::user + 31,
            get_drop_target = common_message::get_drop_target,
            get_band_borders = message::user + 34,
            show_band = message::user + 35,
            set_palette = message::user + 37,
            get_palette = message::user + 38,
            move_band = message::user + 39,
            set_unicode_format = common_message::set_unicode_format,
            get_unicode_format = common_message::get_unicode_format,
            get_band_margins = message::user + 40,
            set_window_theme = common_message::set_window_theme,
            set_extended_style = message::user + 41,
            get_extended_style = message::user + 42,
            push_chevron = message::user + 43,
            set_band_width = message::user + 44,
        };

        enum
        {
            insert_band_w = message::user + 10,
            set_band_information_w = message::user + 11,
            get_band_information_w = message::user + 28,
        };

        enum
        {
            insert_band_a = message::user + 1,
            set_band_information_a = message::user + 6,
            get_band_information_a = message::user + 29,
        };
    };

    export struct rebar_notify
    {
        enum
        {
            first = 0u - 831u,
            height_change = first - 0,
            get_object = first - 1,
            layout_changed = first - 2,
            auto_size = first - 3,
            begin_drag = first - 4,
            end_drag = first - 5,
            deleting_band = first - 6,
            deleted_band = first - 7,
            child_size = first - 8,
            splitter_drag = first - 11,
            mimimum_maximum = first - 21,
            auto_break = first - 22,
        };
    };

    export struct notify_message_rebar_child_size : public notify_message_header
    {
        uint band;
        uint identity;
        irectangle child;
        irectangle band_rectangle;
    };

    export struct notify_message_rebar : public notify_message_header
    {
        uint mask;           // rbn_m_*
        uint band;
        uint style;
        uint identity;
        parameter parameter;
    };

    export struct rebar_notify_message
    {
        enum
        {
            identity = 0x00000001,
            style = 0x00000002,
            parameter = 0x00000004,
        };
    };

    export struct notify_message_rebar_autosize : public notify_message_header
    {
        bool changed;
        irectangle target;
        irectangle actual;
    };

    export struct notify_message_rebar_chevron : public notify_message_header
    {
        uint band;
        uint identity;
        parameter lparameter;
        irectangle rectangle;
        parameter parameter_notify_message;
    };

    export struct notify_message_rebar_splitter : public notify_message_header
    {
        irectangle sizing;
    };

    export struct rebar_auto_break
    {
        enum
        {
            auto_size = 0x0001,
            add_band = 0x0002,
        };
    };

    export struct notify_message_rebar_auto_break : public notify_message_header
    {
        uint band;
        uint identity;
        parameter parameter;
        uint message;
        uint style_current;
        bool auto_break;
    };

    export struct rebar_hit_test
    {
        enum
        {
            nowhere = 0x0001,
            caption = 0x0002,
            client = 0x0003,
            grabber = 0x0004,
            chevron = 0x0008,
            splitter = 0x0010,
        };
    };

    export struct rebar_hit_test_information : public ipoint
    {
        uint flags;
        int band;
    };

    export template<class character>
        struct tool_tips_tool_information
    {
        uint size;
        uint flags;
        handle window;
        ulong identity;
        irectangle rectangle;
        handle instance;
        character* text;
        parameter parameter;
        void* reserved;
    };

    export struct tool_tips_style
    {
        enum
        {
            always_tip = 0x01,
            no_prefix = 0x02,
            no_animate = 0x10,
            no_fade = 0x20,
            balloon = 0x40,
            close = 0x80,
            use_visual_style = 0x100,
        };
    };

    export struct tool_tips_flag
    {
        enum
        {
            window_handle = 0x0001,
            center_tip = 0x0002,
            right_to_left_reading = 0x0004,
            subclass = 0x0010,
            track = 0x0020,
            absolute = 0x0080,
            transparent = 0x0100,
            parse_links = 0x1000,
            set_item = 0x8000,
        };
    };

    export struct tool_tips_delay_time
    {
        enum
        {
            automatic = 0,
            reshow = 1,
            auto_pop = 2,
            initial = 3,
        };
    };

    export struct tool_tips_icon
    {
        enum
        {
            none = 0,
            information = 1,
            warning = 2,
            error = 3,
            information_large = 4,
            warning_large = 5,
            error_large = 6,
        };
    };

    export struct tool_tips_message
    {
        enum
        {
            activate = message::user + 1,
            set_delay_time = message::user + 3,
            relay_event = message::user + 7,
            get_tool_count = message::user + 13,
            window_from_point = message::user + 16,
            track_activate = message::user + 17,
            track_position = message::user + 18,
            set_tip_background_color = message::user + 19,
            set_tip_text_color = message::user + 20,
            get_delay_time = message::user + 21,
            get_tip_background_color = message::user + 22,
            get_tip_text_color = message::user + 23,
            set_maximum_tip_width = message::user + 24,
            get_maximum_tip_width = message::user + 25,
            set_margin = message::user + 26,
            get_margin = message::user + 27,
            pop = message::user + 28,
            update = message::user + 29,
            get_bubble_size = message::user + 30,
            adjustrectangle = message::user + 31,
            popup = message::user + 34,
            get_title = message::user + 35,
            set_window_theme = common_message::set_window_theme,
        };

        enum
        {
            add_tool_w = message::user + 50,
            delete_tool_w = message::user + 51,
            new_tool_rectangle_w = message::user + 52,
            get_tool_information_w = message::user + 53,
            set_tool_information_w = message::user + 54,
            hit_test_w = message::user + 55,
            get_text_w = message::user + 56,
            update_tip_text_w = message::user + 57,
            enumerate_tools_w = message::user + 58,
            get_current_tool_w = message::user + 59,
            set_title_w = message::user + 33,
        };

        enum
        {
            add_tool_a = message::user + 4,
            delete_tool_a = message::user + 5,
            new_tool_rectangle_a = message::user + 6,
            get_tool_information_a = message::user + 8,
            set_tool_information_a = message::user + 9,
            hit_test_a = message::user + 10,
            get_text_a = message::user + 11,
            update_tip_text_a = message::user + 12,
            enumerate_tools_a = message::user + 14,
            get_current_tool_a = message::user + 15,
            set_title_a = message::user + 32,
        };
    };

    export struct tool_tips_get_title
    {
        uint size;
        uint title_bitmap;
        uint title_size;
        wchar_t* title;
    };

    export template<class character>
        struct tool_tips_hit_test_information
    {
        handle window;
        ipoint position;
        tool_tips_tool_information<character> information;
    };

    export struct tool_tips_notify
    {
        enum
        {
            first = 0u - 520u,
            show = first - 1,
            pop = first - 2,
            link_click = first - 3,
        };

        enum
        {
            get_display_information_w = first - 10,
            need_text_w = get_display_information_w,
        };

        enum
        {
            get_display_information_a = first - 0,
            need_text_a = get_display_information_w,
        };
    };

    export struct notify_message_tool_tips_display_information : public notify_message_header
    {
        character* text;
        character text_array[80];
        handle instance;
        uint flags;
        parameter parameter;
    };

    export  enum { minimum_system_command = system_command::size };

    export struct trackbar_style
    {
        enum
        {
            auto_ticks = 0x0001,
            vertical = 0x0002,
            horizontal = 0x0000,
            top = 0x0004,
            bottom = 0x0000,
            left = 0x0004,
            right = 0x0000,
            both = 0x0008,
            no_ticks = 0x0010,
            enable_selection_range = 0x0020,
            fixed_length = 0x0040,
            no_thumb = 0x0080,
            tool_tips = 0x0100,
            reversed = 0x0200,
            down_is_left = 0x0400,
            notify_before_remove = 0x0800,
            transparent_background = 0x1000,
        };
    };

    export struct trackbar_message
    {
        enum
        {
            get_position = message::user,
            get_range_minimum = message::user + 1,
            get_range_maximum = message::user + 2,
            get_tick = message::user + 3,
            set_tick = message::user + 4,
            set_window_position = message::user + 5,
            set_range = message::user + 6,
            set_range_minimum = message::user + 7,
            set_range_maximum = message::user + 8,
            clear_ticks = message::user + 9,
            set_selection = message::user + 10,
            set_selection_start = message::user + 11,
            set_selection_end = message::user + 12,
            get_ticks = message::user + 14,
            get_tick_position = message::user + 15,
            get_number_ticks = message::user + 16,
            get_selection_start = message::user + 17,
            get_selection_end = message::user + 18,
            clear_selection = message::user + 19,
            set_tick_frequency = message::user + 20,
            set_page_size = message::user + 21,
            get_page_size = message::user + 22,
            set_line_size = message::user + 23,
            get_line_size = message::user + 24,
            get_thumb_rectangle = message::user + 25,
            get_channel_rectangle = message::user + 26,
            set_thumb_length = message::user + 27,
            get_thumb_length = message::user + 28,
            set_tool_tips = message::user + 29,
            get_tool_tips = message::user + 30,
            set_tip_side = message::user + 31,
            set_buddy = message::user + 32,
            get_buddy = message::user + 33,
            set_unicode_format = common_message::set_unicode_format,
            get_unicode_format = common_message::get_unicode_format,
        };
    };

    export struct trackbar_top_side
    {
        enum
        {
            top = 0,
            left = 1,
            bottom = 2,
            right = 3,
        };
    };

    export struct trackbar_notify_flag
    {
        enum
        {
            line_up = 0,
            line_down = 1,
            page_up = 2,
            page_down = 3,
            thumb_position = 4,
            thumb_track = 5,
            top = 6,
            bottom = 7,
            end_track = 8,
        };
    };

    export struct trackbar_custom_draw
    {
        enum
        {
            ticks = 0x0001,
            thumb = 0x0002,
            channel = 0x0003,
        };
    };

    export struct trackbar_notify
    {
        enum
        {
            first = 0u - 1501u,
            thumb_position_changing = first - 1,
        };
    };

    export struct trackbar_thumb_position_changing : public notify_message_header
    {
        uint position;
        int reason;
    };

    export struct drag_list_information
    {
        uint notification;
        handle window;
        ipoint cursor;
    };

    export struct drag_list_message
    {
        enum
        {
            begin_drag = message::user + 133,
            dragging = message::user + 134,
            dropped = message::user + 135,
            cancel_drag = message::user + 136,
        };
    };

    export struct drag_list_identity
    {
        enum
        {
            cursor_set = 0,
            stop_cursor = 1,
            copy_cursor = 2,
            move_cursor = 3,
        };
    };

    export struct up_down_acceleration
    {
        uint seconds;
        uint increment;
    };

    export struct up_down_constant
    {
        enum
        {
            maximum_value = 0x7fff,
            minimum_value = -maximum_value,
        };
    };

    export struct up_down_style
    {
        enum
        {
            wrap = 0x0001,
            set_buddy_integer = 0x0002,
            align_right = 0x0004,
            align_left = 0x0008,
            auto_buddy = 0x0010,
            arrow_keys = 0x0020,
            horizontal = 0x0040,
            no_thousands = 0x0080,
            hot_track = 0x0100,
        };
    };

    export struct up_down_message
    {
        enum
        {
            set_range = message::user + 101,
            get_range = message::user + 102,
            set_window_position = message::user + 103,
            get_position = message::user + 104,
            set_buddy = message::user + 105,
            get_buddy = message::user + 106,
            set_acceleration = message::user + 107,
            get_acceleration = message::user + 108,
            set_base = message::user + 109,
            get_base = message::user + 110,
            set_range32 = message::user + 111,
            get_range32 = message::user + 112,
            set_unicode_format = common_message::set_unicode_format,
            get_unicode_format = common_message::get_unicode_format,
            set_window_position32 = message::user + 113,
            get_position32 = message::user + 114,
        };
    };

    export struct notify_message_up_down : public notify_message_header
    {
        int position;
        int delta;
    };

    export struct up_down_notify
    {
        enum
        {
            first = 0u - 721u,
            delta_position = first - 1,
        };
    };

    export struct progress_style
    {
        enum
        {
            smooth = 0x01,
            vertical = 0x04,
            marquee = 0x08,
            smooth_reverse = 0x10,
        };
    };

    export struct progress_range
    {
        int low;
        int high;
    };

    export struct progress_message
    {
        enum
        {
            set_range = message::user + 1,
            set_window_position = message::user + 2,
            delta_position = message::user + 3,
            set_step = message::user + 4,
            step_it = message::user + 5,
            set_range32 = message::user + 6,
            get_range = message::user + 7,
            get_position = message::user + 8,
            set_bar_color = message::user + 9,
            set_background_color = common_message::set_background_color,
            set_marquee = message::user + 10,
            get_step = message::user + 13,
            get_background_color = message::user + 14,
            get_bar_color = message::user + 15,
            set_state = message::user + 16,
            get_state = message::user + 17,
        };
    };

    export struct progress_step
    {
        enum
        {
            normal = 0x0001,
            error = 0x0002,
            paused = 0x0003,
        };
    };

    export struct hotkey_flag
    {
        enum
        {
            shift = 0x01,
            control = 0x02,
            alt = 0x04,
            extended = 0x08,
        };
    };

    export struct hot_key_combination
    {
        enum
        {
            none = 0x0001,
            shift = 0x0002,
            control = 0x0004,
            alt = 0x0008,
            shift_control = 0x0010,
            shift_alt = 0x0020,
            control_alt = 0x0040,
            shift_control_alt = 0x0080,
        };
    };

    export struct hotkey_message
    {
        enum
        {
            set_hotkey = message::user + 1,
            get_hotkey = message::user + 2,
            set_rules = message::user + 3,
        };
    };

    export struct syslink_values
    {
        enum
        {
            invalid_link_index = -1,
            maximum_link_identity_text = 48,
            maximum_url_length = 2048 + 32 + sizeof("://"),
        };
    };

    export struct syslink_style
    {
        enum
        {
            transparent = 0x0001,
            ignore_return = 0x0002,
            no_prefix = 0x0004,
            use_visual_style = 0x0008,
            use_custom_text = 0x0010,
            right = 0x0020,
        };
    };

    export struct syslink_item_flag
    {
        enum
        {
            item_index = 0x00000001,
            state = 0x00000002,
            item_identity = 0x00000004,
            url = 0x00000008,
        };
    };

    export struct syslink_item_style
    {
        enum
        {
            focused = 0x00000001,
            enabled = 0x00000002,
            visited = 0x00000004,
            hot_track = 0x00000008,
            default_colors = 0x00000010,
        };
    };

    export struct link_hit_test_information
    {
        ipoint position;
        link_item item;
    };

    export struct notify_message_link : public notify_message_header
    {
        link_item item;
    };

    export struct syslink_message
    {
        enum
        {
            hit_test = message::user + 0x300,
            get_ideal_height = message::user + 0x301,
            set_item = message::user + 0x302,
            get_item = message::user + 0x303,
            get_ideal_size = get_ideal_height,
        };
    };

    export struct combobox_extended_item_flag
    {
        enum
        {
            text = 0x00000001,
            image = 0x00000002,
            selected_image = 0x00000004,
            overlay = 0x00000008,
            indent = 0x00000010,
            parameter = 0x00000020,
            set_item = 0x10000000,
        };
    };

    export template<class character>
        struct combobox_extended_item
    {
        uint mask;
        ulong item;
        character* text;
        int text_maximum;
        int image;
        int selected_image;
        int overlay;
        int indent;
        parameter parameter;
    };

    export struct combobox_extended_message
    {
        enum
        {
            insert_item_a = message::user + 1,
            set_image_list = message::user + 2,
            get_image_list = message::user + 3,
            get_item_a = message::user + 4,
            set_item_a = message::user + 5,
            delete_item = combobox_message::delete_string,
            get_combo_control = message::user + 6,
            get_edit_control = message::user + 7,
            set_extended_style = message::user + 14,
            get_extended_style = message::user + 9,
            set_unicode_format = common_message::set_unicode_format,
            get_unicode_format = common_message::get_unicode_format,
            has_edit_changed = message::user + 10,
            insert_item_w = message::user + 11,
            set_item_w = message::user + 12,
            get_item_w = message::user + 13,
            set_window_theme = common_message::set_window_theme,
        };

        enum
        {
            insert_item = insert_item_w,
            set_item = set_item_w,
            get_item = get_item_w,
        };
    };

    export struct combobox_extended_style
    {
        enum
        {
            no_edit_image = 0x00000001,
            no_edit_image_indent = 0x00000002,
            path_word_break_procedure = 0x00000004,
            no_size_limit = 0x00000008,
            case_sensitive = 0x00000010,
            text_end_ellipsis = 0x00000020,
        };
    };

    export template<class character>
        struct notify_message_combo_box_extended : public notify_message_header
    {
        combobox_extended_item<character> item;
    };

    export struct  combobox_extended_notify
    {
        enum
        {
            first = 0u - 800u,
            get_display_information_a = first - 0,
            insert_item = first - 1,
            delete_item = first - 2,
            begin_edit = first - 4,
            end_edit_a = first - 5,
            end_edit_w = first - 6,
            get_display_information_w = first - 7,
            drag_begin_a = first - 8,
            drag_begin_w = first - 9,
        };

        enum
        {
            get_display_information = get_display_information_w,
            drag_begin = drag_begin_w,
            end_edit = end_edit_w,
        };
    };

    export struct combobox_extended_notify_flag
    {
        enum
        {
            kill_focus = 1,
            _return = 2,
            escape = 3,
            drop_down = 4,
        };
    };

    export  enum { combobox_extended_maximum_string_length = 260 };

    export template<class character>
        struct notify_message_combobox_extendeddrag_begin : public notify_message_header
    {
        int item_identity;
        character text[combobox_extended_maximum_string_length];
    };

    export template<class character>
        struct notify_message_combobox_extendedend_edit : public notify_message_header
    {
        bool changed;
        int new_selection;
        character text[combobox_extended_maximum_string_length];
        int why;
    };

    export struct tab_style
    {
        enum
        {
            scroll_opposite = 0x0001,
            bottom = 0x0002,
            right = 0x0002,
            multi_select = 0x0004,
            flat_buttons = 0x0008,
            force_icon_left = 0x0010,
            force_label_left = 0x0020,
            hot_track = 0x0040,
            vertical = 0x0080,
            tabs = 0x0000,
            buttons = 0x0100,
            single_line = 0x0000,
            multi_line = 0x0200,
            right_justify = 0x0000,
            fixed_width = 0x0400,
            ragged_right = 0x0800,
            focus_button_down = 0x1000,
            owner_draw_fixed = 0x2000,
            tool_tips = 0x4000,
            focus_never = 0x8000,
        };
    };

    export struct tab_style_extended
    {
        enum
        {
            flat_separators = 0x00000001,
            register_drop = 0x00000002,
        };
    };

    export struct tab_message
    {
        enum
        {
            first = 0x1300,
            get_image_list = first + 2,
            set_image_list = first + 3,
            get_item_count = first + 4,
            delete_item = first + 8,
            delete_all_items = first + 9,
            get_item_rectangle = first + 10,
            get_current_selection = first + 11,
            set_current_selection = first + 12,
            hit_test = first + 13,
            set_item_extra = first + 14,
            adjust_rectangle = first + 40,
            set_item_size = first + 41,
            remove_image = first + 42,
            set_padding = first + 43,
            get_row_count = first + 44,
            get_tool_tips = first + 45,
            set_tool_tips = first + 46,
            get_current_focus = first + 47,
            set_current_focus = first + 48,
            set_minimum_tab_width = first + 49,
            deselect_all = first + 50,
            highlight_item = first + 51,
            set_extended_style = first + 52,
            get_extended_style = first + 53,
            set_unicode_format = common_message::set_unicode_format,
            get_unicode_format = common_message::get_unicode_format
        };

        enum
        {
            get_item_w = first + 60,
            set_item_w = first + 61,
            insert_item_w = first + 62
        };

        enum
        {
            get_item_a = first + 5,
            set_item_a = first + 6,
            insert_item_a = first + 7
        };
    };

    export struct tab_information_flags
    {
        enum
        {
            text = 0x0001,
            image = 0x0002,
            right_to_left_reading = 0x0004,
            parameter = 0x0008,
            state = 0x0010,
        };
    };

    export struct tab_item_style
    {
        enum
        {
            button_pressed = 0x0001,
            highlighted = 0x0002,
        };
    };

    export template<class character>
        struct tab_item_header
    {
        uint mask;
        uint reserved1;
        uint reserved2;
        character* text;
        int text_maximum;
        int image;
    };

    export template<class character>
        struct tab_item
    {
        uint mask;
        uint state;
        uint state_mask;
        character* text;
        int text_maximum;
        int image;
        parameter paramter;
    };

    export struct tab_hit_test
    {
        enum
        {
            nowhere = 0x0001,
            on_item_icon = 0x0002,
            on_item_label = 0x0004,
            on_item = on_item_icon | on_item_label,
        };
    };

    export struct tab_hit_test_information
    {
        ipoint position;
        uint flags;
    };

    export struct tab_notify
    {
        enum
        {
            first = 0u - 550u,
            key_down = first - 0,
            selection_change = first - 1,
            selection_changing = first - 2,
            get_object = first - 3,
            focus_change = first - 4,
        };
    };

    export struct tab_key_down : public notify_message_header
    {
        part key;
        uint flags;
    };

    export struct animate_style
    {
        enum
        {
            center = 0x0001,
            transparent = 0x0002,
            auto_play = 0x0004,
            timer = 0x0008,
        };
    };

    export struct animate_message
    {
        enum
        {
            open_a = message::user + 100,
            open_w = message::user + 103,
            play = message::user + 101,
            stop = message::user + 102,
            is_playing = message::user + 104,
        };

        enum
        {
            open = open_w,
        };
    };

    export struct animate_notify
    {
        enum
        {
            start = 1,
            stop = 2,
        };
    };

    export  typedef uint month_day_state;

    export struct month_calendar_message
    {
        enum
        {
            first = 0x1000,
            get_current_selection = first + 1,
            set_current_selection = first + 2,
            get_maximum_selection_count = first + 3,
            set_maximum_selection_count = first + 4,
            get_selection_range = first + 5,
            set_selection_range = first + 6,
            get_month_range = first + 7,
            set_day_state = first + 8,
            get_minimum_requiredrectangle = first + 9,
            set_color = first + 10,
            get_color = first + 11,
            set_today = first + 12,
            get_today = first + 13,
            hit_test = first + 14,
            set_first_day_ofweek = first + 15,
            get_first_day_ofweek = first + 16,
            get_range = first + 17,
            set_range = first + 18,
            get_month_delta = first + 19,
            set_month_delta = first + 20,
            get_maximum_today_width = first + 21,
            set_unicode_format = common_message::set_unicode_format,
            get_unicode_format = common_message::get_unicode_format,
            get_current_view = first + 22,
            get_calendar_count = first + 23,
            get_calendar_grid_information = first + 24,
            get_calendard_identity = first + 27,
            set_calendar_identity = first + 28,
            size_rectangle_to_minimum = first + 29,
            set_calendar_border = first + 30,
            get_calendar_border = first + 31,
            set_current_view = first + 32,
        };
    };

    export struct month_calendar_set_color
    {
        enum
        {
            background = 0,
            text = 1,
            title_background = 2,
            title_text = 3,
            month_background = 4,
            trailing_text = 5,
        };
    };

    export struct month_calendar_hit_test_information
    {
        uint size;
        ipoint position;
        uint hit;
        system_time time;
        irectangle rectangle;
        int offset;
        int row;
        int column;
    };

    export struct month_calendar_hit_test
    {
        enum
        {
            title = 0x00010000,
            calendar = 0x00020000,
            today_link = 0x00030000,
            calendar_control = 0x00100000,
            next = 0x01000000,
            previous = 0x02000000,
            nowhere = 0x00000000,
            title_background = title,
            title_month = title | 0x0001,
            title_year = title | 0x0002,
            title_button_next = title | next | 0x0003,
            title_button_previous = title | previous | 0x0003,
            calendar_background = calendar,
            calendar_date = calendar | 0x0001,
            calendar_date_next = calendar_date | next,
            calendar_date_previous = calendar_date | previous,
            calendar_day = calendar | 0x0002,
            calendar_week_number = calendar | 0x0003,
            calendar_date_minimum = calendar | 0x0004,
            calendar_date_maximum = calendar | 0x0005,
        };
    };

    export struct month_calendar_view
    {
        enum
        {
            month = 0,
            year = 1,
            decade = 2,
            century = 3,
            maximum = century,
        };
    };

    export struct month_calendar_grid_information_part
    {
        enum
        {
            calendar_control = 0,
            next = 1,
            previous = 2,
            footer = 3,
            calendar = 4,
            calendar_header = 5,
            calendar_body = 6,
            calendar_arrow = 7,
            calendar_cell = 8,
        };
    };

    export struct month_calendar_grid_information_flag
    {
        enum
        {
            date = 0x00000001,
            rectangle = 0x00000002,
            name = 0x00000004,
        };
    };

    export struct month_calendar_grid_information
    {
        uint size;
        uint part;
        uint flags;
        int calendar;
        int row;
        int col;
        bool selected;
        system_time start;
        system_time end;
        irectangle rectangle;
        wchar_t* name;
        size_t name_size;
    };

    export struct notify_message_selection_change : public notify_message_header
    {
        system_time selection_start;
        system_time selection_end;
    };

    export struct month_calendar_notify
    {
        enum
        {
            first = 0u - 746u,
            selection_change = first - 3,
            select = first,
            get_day_state = first - 1,
            view_change = first - 4,
        };
    };

    export struct notify_message_day_state : public notify_message_header
    {
        system_time start;
        int day_state;
        month_day_state day_state_array;
    };

    export struct notify_message_view_change : public notify_message_header
    {
        uint old_view;
        uint new_view;
    };

    export struct month_calendar_style
    {
        enum
        {
            day_state = 0x0001,
            multi_select = 0x0002,
            week_numbers = 0x0004,
            no_today_circle = 0x0008,
            no_today = 0x0010,
            no_trailing_dates = 0x0040,
            short_days_of_week = 0x0080,
            no_selection_change = 0x0100,
        };
    };

    export struct get_month_range_flags
    {
        enum
        {
            visible = 0,
            day_state = 1,
        };
    };

    export struct date_time_pick_information
    {
        uint size;
        irectangle check;
        uint state_check;
        irectangle button;
        uint state_button;
        handle edit;
        handle up_down;
        handle drop_down;
    };

    export struct  date_time_message
    {
        enum
        {
            first = 0x1000,
            get_system_time = first + 1,
            set_system_time = first + 2,
            get_range = first + 3,
            set_range = first + 4,
            set_month_calendar_color = first + 6,
            get_month_calendar_color = first + 7,
            get_month_calendar = first + 8,
            set_month_calendar_font = first + 9,
            get_month_calendar_font = first + 10,
            set_month_calendar_style = first + 11,
            get_month_calendar_style = first + 12,
            close_month_calendar = first + 13,
            get_date_time_picker_information = first + 14,
            get_ideal_size = first + 15,
        };

        enum
        {
            date_time_message_set_format_w = first + 50,
        };

        enum
        {
            date_time_message_set_format_a = first + 5,
        };
    };

    export struct date_type_style
    {
        enum
        {
            up_down = 0x0001,
            show_none = 0x0002,
            short_date_format = 0x0000,
            long_date_format = 0x0004,
            short_date_century_format = 0x000c,
            time_format = 0x0009,
            application_can_parse = 0x0010,
            right_align = 0x0020,
        };
    };

    export struct date_time_notify
    {
        enum date_time_pick_notify
        {
            first = 0u - 740u,
            first2 = 0u - 753u,
            date_time_change = first2 - 6,
            drop_down = first2 - 1,
            close_up = first2,
        };
        enum
        {
            user_string_w = first - 5,
            key_down_w = first - 4,
            format_w = first - 3,
            format_query_w = first - 2,
        };
        enum
        {
            user_string_a = first2 - 5,
            key_down_a = first2 - 4,
            format_a = first2 - 3,
            format_query_a = first2 - 2,
        };
    };

    export struct notify_message_date_time_change : public notify_message_header
    {
        uint flags;
        system_time time;
    };

    export template<class character>
        struct notify_message_date_time_string : public notify_message_header
    {
        character* user_string;
        system_time time;
        uint flags;
    };

    export template<class character>
        struct notify_message_date_time_key_down : public notify_message_header
    {
        int virtual_key;
        character* format;
        system_time time;
    };

    export template<class character>
        struct notify_message_date_time_format : public notify_message_header
    {
        character* format;
        system_time time;
        character* display;
        character buffer[64];
    };

    export template<class character>
        struct notify_message_date_time_format_query : public notify_message_header
    {
        character* format;
        ipoint maximum;
    };

    export struct get_date_time_return
    {
        enum
        {
            minimum = 0x0001,
            maximum = 0x0002,
        };
    };

    export struct get_date_time_flag
    {
        enum
        {
            error = -1,
            valid = 0,
            none = 1,
        };
    };

    export struct internet_protocol_address_message
    {
        enum
        {
            clear_address = message::user + 100,
            set_address = message::user + 101,
            get_address = message::user + 102,
            set_range = message::user + 103,
            set_focus = message::user + 104,
            is_blank = message::user + 105,
        };
    };

    export struct internet_protocol_address_notify
    {
        enum
        {
            first = 0u - 860u,
            field_changed = first - 0,
        };
    };

    export struct notify_message_internet_protocol_address : public notify_message_header
    {
        int field;
        int value;
    };

    export  parameter make_internet_protocol_range(uint low, uint high)
    {
        return ((parameter)(part)(((byte)high << 8) + (byte)low));
    }

    export  parameter make_internet_protocol_address(byte b1, byte b2, byte b3, byte b4)
    {
        return (parameter)(((uint)b1 << 24) + ((uint)b2 << 16) + ((uint)b3 << 8) + ((uint)b4));
    }

    export  byte first_internet_protocol_address(uint x) { return (x >> 24) & 0xff; }
    export  byte second_internet_protocol_address(uint x) { return (x >> 16) & 0xff; }
    export  byte third_internet_protocol_address(uint x) { return (x >> 8) & 0xff; }
    export  byte fourth_internet_protocol_address(uint x) { return x & 0xff; }

    export struct pager_style
    {
        enum
        {
            vertical = 0x00000000,
            horizontal = 0x00000001,
            auto_scroll = 0x00000002,
            drag_and_drop = 0x00000004,
        };
    };

    export struct pager_button_state
    {
        enum
        {
            invisible = 0,
            normal = 1,
            grayed = 2,
            depressed = 4,
            hot = 8,
        };
    };

    export struct pager_button
    {
        enum
        {
            top_or_left = 0,
            bottom_or_right = 1,
        };
    };

    export struct pager_message
    {
        enum
        {
            first = 0x1400,
            set_child = first + 1,
            recalculate_size = first + 2,
            forward_mouse = first + 3,
            set_background_color = first + 4,
            get_background_color = first + 5,
            set_border = first + 6,
            get_border = first + 7,
            set_window_position = first + 8,
            get_position = first + 9,
            set_button_size = first + 10,
            get_button_size = first + 11,
            get_button_state = first + 12,
            get_drop_target = common_message::get_drop_target,
        };
    };

    export struct pager_notify
    {
        enum
        {
            first = 0u - 900u,
            scroll = first - 1,
            calculate_size = first - 2,
            hot_item_change = first - 3,
        };
    };

    export struct pager_scroll_flag
    {
        enum
        {
            up = 1,
            down = 2,
            left = 4,
            right = 8,
        };
    };

    export struct pager_key
    {
        enum
        {
            shift = 1,
            control = 2,
            menu = 4,
        };
    };

    export struct notify_message_pager_scroll : public notify_message_header
    {
        part keys;
        irectangle parent;
        int direction;
        int x_position;
        int y_position;
        int scroll;
    };

    export struct pager_calculate
    {
        enum
        {
            width = 1,
            height = 2,
        };
    };

    export struct notify_message_pager_calculate_size : public notify_message_header
    {
        uint flag;
        int width;
        int height;
    };

    export struct pager_hot_item_change_flag
    {
        enum
        {
            entering = 0x00000010,
            leaving = 0x00000020,
        };
    };

    export struct notify_message_pager_hot_item_change : public notify_message_header
    {
        int identity_old;
        int identity_new;
        uint flags;
    };

    export struct native_font_style
    {
        enum
        {
            edit = 0x0001,
            _static = 0x0002,
            list_combo = 0x0004,
            button = 0x0008,
            all = 0x0010,
            user_font_association = 0x0020,
        };
    };

    export  typedef result(__stdcall* task_dialog_callback)(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2,
        void* reference_data);

    export struct task_dialog_flag
    {
        enum
        {
            enable_hyper_links = 0x0001,
            use_icon_handle_main = 0x0002,
            use_icon_handle_footer = 0x0004,
            allow_dialog_cancellation = 0x0008,
            use_command_links = 0x0010,
            use_command_links_no_icon = 0x0020,
            expand_footer_area = 0x0040,
            expanded_by_default = 0x0080,
            verification_flag_checked = 0x0100,
            show_progress_bar = 0x0200,
            show_marquee_progress_bar = 0x0400,
            callback_timer = 0x0800,
            position_relative_to_windows = 0x1000,
            rtl_layout = 0x2000,
            no_default_radio_button = 0x4000,
            can_be_minimized = 0x8000
        };
    };

    export struct task_dialog_message
    {
        enum
        {
            navigate_page = message::user + 101,
            click_button = message::user + 102,
            set_marquee_progress_bar = message::user + 103,
            set_progress_bar_state = message::user + 104,
            set_progress_bar_range = message::user + 105,
            set_progress_bar_position = message::user + 106,
            set_progress_bar_marquee = message::user + 107,
            set_element_text = message::user + 108,
            click_radio_button = message::user + 110,
            enable_button = message::user + 111,
            enable_radio_button = message::user + 112,
            click_verification = message::user + 113,
            update_element_text = message::user + 114,
            set_button_elevation_required_state = message::user + 115,
            update_icon = message::user + 116
        };
    };

    export struct task_dialog_notify
    {
        enum
        {
            created = 0,
            navigated = 1,
            button_clicked = 2,
            hyperlink_clicked = 3,
            timer = 4,
            destroyed = 5,
            radio_button_clicked = 6,
            dialog_constructed = 7,
            verification_clicked = 8,
            help = 9,
            expand_button_clicked = 10
        };
    };

    export struct task_dialog_button
    {
        int button_identity;
        wchar_t* button_text;
    };

    export struct task_dialog_element
    {
        enum
        {
            content,
            expanded_information,
            footer,
            main_instruction,
        };
    };

    export struct task_dialog_icon_element
    {
        enum
        {
            main_icon,
            footer_icon,
        };
    };

    export struct task_dialog_common_button_flag
    {
        enum
        {
            ok = 0x0001,
            yes = 0x0002,
            no = 0x0004,
            cancel = 0x0008,
            retry = 0x0010,
            close = 0x0020,
        };
    };

    export struct task_dialog_configuration
    {
        uint size;
        handle parent;
        handle instance;
        int flags;
        int common_buttons;
        wchar_t* window_title;
        union
        {
            handle main_icon_handle;
            wchar_t* main_icon_string;
        };
        wchar_t* main_instruction;
        wchar_t* content;
        uint buttons;
        int* button_pointer;
        int default_button;
        uint radio_buttons;
        int* radio_button_pointer;
        int default_radio_button;
        wchar_t* verification_text;
        wchar_t* expanded_information;
        wchar_t* expanded_control_text;
        wchar_t* collapsed_control_text;
        union
        {
            handle footer_icon_handle;
            wchar_t* footer_icon_text;
        };
        wchar_t* footer;
        task_dialog_callback callback;
        void* callback_data;
        uint width;
    };

    export struct list_entry
    {
        list_entry* forward;
        list_entry* backward;
    };

    export struct critical_section
    {
        part type;
        part backtrace;
        critical_section* section;
        list_entry* locks;
        uint count;
        uint contention;
        uint spare[2];
    };

    export template<class character>
        struct open_file
    {
        enum { maximum_path_name = 128 };

        byte size__byte;
        byte fixed_disk;
        part error;
        part reserved1;
        part reserved2;
        character path_name[maximum_path_name];
    };

    export struct stream_identity_information
    {
        uint identity;
        uint attribute;
        double_uint size;
        uint nsize;
        wchar_t name[1];
    };

    export struct exit_flag
    {
        enum
        {
            logoff = 0x00,
            shutdown = 0x01,
            reboot = 0x02,
            force = 0x04,
            power_off = 0x08,
            force_if_hung = 0x10
        };
    };

    export struct session_end { enum { logoff = 0x80000000 }; };

    export struct key_event
    {
        enum
        {
            extended = 0x0001,
            key_up = 0x0002
        };
    };

    export struct mouse_flag
    {
        enum
        {
            move = 0x0001,
            left_down = 0x0002,
            left_up = 0x0004,
            right_down = 0x0008,
            right_up = 0x0010,
            middle_down = 0x0020,
            middle_up = 0x0040,
            wheel = 0x0080,
            absolute = 0x8000
        };
    };

    export struct mouse_event_flag
    {
        enum
        {
            hover = 0x00000001,
            leave = 0x00000002,
            query = 0x40000000,
            cancel = 0x80000000
        };
    };

    export struct hover_flag { enum { _default = 0xffffffff }; };

    export struct mouse_track
    {
        uint size;
        uint flags;
        handle window;
        uint hover;
    };

    export struct control_color
    {
        enum
        {
            message_box = 0,
            edit = 1,
            listbox = 2,
            button = 3,
            dialog = 4,
            scrollbar = 5,
            display = 6,
            maximum = 7
        };
    };

    export struct system_color
    {
        enum
        {
            scrollbar = 0,
            background = 1,
            active_caption = 2,
            inactive_caption = 3,
            menu = 4,
            window = 5,
            window_frame = 6,
            menu_text = 7,
            window_text = 8,
            caption_text = 9,
            active_border = 10,
            inactive_border = 11,
            application_workspace = 12,
            highlight = 13,
            text_highlight = 14,
            button_face = 15,
            button_shadow = 16,
            gray_text = 17,
            button_text = 18,
            inactive_caption_text = 19,
            button_highlight = 20,
            three_ddark_shadow = 21,
            three_d_light = 22,
            information_text = 23,
            information_background = 24,
            hotlight = 26,
            gradient_active_caption = 27,
            gradient_inactive_caption = 28,
            desktop = background,
            three_d_face = button_face,
            three_d_shadow = button_shadow,
            three_d_highlight = button_highlight
        };
    };

    export struct system_parameter
    {
        enum
        {
            get_beep = 1,
            set_beep = 2,
            get_mouse = 3,
            set_mouse = 4,
            get_border = 5,
            set_border = 6,
            get_keyboard_speed = 10,
            set_keyboard_speed = 11,
            language_driver = 12,
            icon_horizontal_spacing = 13,
            get_screen_save_timeout = 14,
            set_screen_save_timeout = 15,
            get_screen_save_active = 16,
            set_screen_save_active = 17,
            get_grid_granularity = 18,
            set_grid_granularity = 19,
            set_desk_wall_paper = 20,
            set_desk_pattern = 21,
            get_keyboard_delay = 22,
            set_keyboard_delay = 23,
            icon_vertical_spacing = 24,
            get_icon_title_wrap = 25,
            set_icon_title_wrap = 26,
            get_menu_drop_alignment = 27,
            set_menu_drop_alignment = 28,
            set_double_click_width = 29,
            set_double_click_height = 30,
            get_icon_title_logical_font = 31,
            set_double_click_time = 32,
            set_mouse_button_swap = 33,
            set_icon_title_logical_font = 34,
            get_fast_task_switch = 35,
            set_fast_task_switch = 36,
            set_drag_full_windows = 37,
            get_drag_full_windows = 38,
            get_nonclient_metrics = 41,
            set_nonclient_metrics = 42,
            get_minimized_metrics = 43,
            set_minimized_metrics = 44,
            get_icon_metrics = 45,
            set_icon_metrics = 46,
            set_work_area = 47,
            get_work_area = 48,
            set_pen_windows = 49,
            get_filter_keys = 50,
            set_filter_keys = 51,
            get_toggle_keys = 52,
            set_toggle_keys = 53,
            get_mouse_keys = 54,
            set_mouse_keys = 55,
            get_show_sounds = 56,
            set_show_sounds = 57,
            get_sticky_keys = 58,
            set_sticky_keys = 59,
            get_access_timeout = 60,
            set_access_timeout = 61,
            get_serial_keys = 62,
            set_serial_keys = 63,
            get_sound_sentry = 64,
            set_sound_sentry = 65,
            get_high_contrast = 66,
            set_high_contrast = 67,
            get_keyboard_preference = 68,
            set_keyboard_preference = 69,
            get_screen_reader = 70,
            set_screen_reader = 71,
            get_animation = 72,
            set_animation = 73,
            get_font_smoothing = 74,
            set_font_smoothing = 75,
            set_drag_width = 76,
            set_drag_height = 77,
            set_hand_held = 78,
            get_low_power_timeout = 79,
            get_power_off_timeout = 80,
            set_low_power_timeout = 81,
            set_power_off_timeout = 82,
            get_low_power_active = 83,
            get_power_off_active = 84,
            set_low_power_active = 85,
            set_power_off_active = 86,
            set_cursors = 87,
            set_icons = 88,
            get_default_input_language = 89,
            set_default_input_language = 90,
            set_language_toggle = 91,
            get_windows_extension = 92,
            set_mouse_trails = 93,
            get_mouse_trails = 94,
            set_screen_saver_running = 97,
            get_mouse_hover_width = 98,
            set_mouse_hover_width = 99,
            get_mouse_hover_height = 100,
            set_mouse_hover_height = 101,
            get_mouse_hover_time = 102,
            set_mouse_hover_time = 103,
            get_wheel_scroll_lines = 104,
            set_wheel_scroll_lines = 105,
            get_menu_show_delay = 0x006a,
            set_menu_show_delay = 0x006b,
            get_input_edit_user_interface = 110,
            set_input_edit_user_interface = 111,
            get_mouse_speed = 112,
            set_mouse_speed = 113,
            get_screen_saver_running = 114,
            get_desk_wall_paper = 0x0073,
            get_active_window_tracking = 0x1000,
            set_active_window_tracking = 0x1001,
            get_menu_animation = 0x1002,
            set_menu_animation = 0x1003,
            get_combobox_animation = 0x1004,
            set_combobox_animation = 0x1005,
            get_listbox_smooth_scrolling = 0x1006,
            set_listbox_smooth_scrolling = 0x1007,
            get_gradient_captions = 0x1008,
            set_gradient_captions = 0x1009,
            get_menu_underlines = 0x100a,
            set_menu_underlines = 0x100b,
            get_active_window_track_z_order = 0x100c,
            set_active_window_track_z_order = 0x100d,
            get_hot_tracking = 0x100e,
            set_hot_tracking = 0x100f,
            get_foreground_lock_timeout = 0x2000,
            set_foreground_lock_timeout = 0x2013,
            get_active_window_track_timeout = 0x2002,
            set_active_window_track_timeout = 0x2003,
            get_foreground_flash_count = 0x2013,
            set_foreground_flash_count = 0x2005,
            get_menu_fade = 0x1012,
            set_menu_fade = 0x1013,
            get_selection_fade = 0x1014,
            set_selection_fade = 0x1015,
            get_tool_tip_animation = 0x1016,
            set_tool_tip_animation = 0x1017,
            get_tool_tip_fade = 0x1018,
            set_tool_tip_fade = 0x1019,
            get_cursor_shadow = 0x101a,
            set_cursor_shadow = 0x101b,
            get_mouse_sonar = 0x101c,
            set_mouse_sonar = 0x101d,
            get_mouse_click_clock = 0x101e,
            set_mouse_click_clock = 0x101f,
            get_mouse_vanish = 0x1020,
            set_mouse_vanish = 0x1021,
            get_flat_menu = 0x1022,
            set_flat_menu = 0x1023,
            get_drop_shadow = 0x1024,
            set_drop_shadow = 0x1025,
            get_block_send_input_resets = 0x1026,
            set_block_send_input_resets = 0x1027,
            get_user_interface_effects = 0x103e,
            set_user_iterface_effects = 0x103f,
            get_caret_width = 0x2006,
            set_caret_width = 0x2007,
            get_mouse_click_clock_time = 0x2008,
            set_mouse_click_clock_time = 0x2009,
            get_font_smoothing_type = 0x200a,
            set_font_smoothing_type = 0x200b,
            get_font_smoothing_contrast = 0x200c,
            set_font_smoothing_contrast = 0x200d,
            get_focus_border_width = 0x200e,
            set_focus_border_width = 0x200f,
            get_focus_border_height = 0x2010,
            set_focus_border_height = 0x2011,
            get_font_smoothing_orientation = 0x2012,
            set_font_smoothing_orientation = 0x2013
        };
    };

    export struct font_smoothing_type
    {
        enum
        {
            standard = 0x0001,
            clear_type = 0x0002,
            docking = 0x8000
        };
    };

    export struct font_smoothing_orientation
    {
        enum
        {
            blue_green_red = 0x0000,
            red_green_blue = 0x0001
        };
    };

    export struct system_parameter_flag
    {
        enum
        {
            initialization_update = 0x0001,
            initialization_send_change = 0x0002
        };
    };

    export struct system_metric
    {
        enum
        {
            screen_width = 0,
            screen_height = 1,
            vertical_scroll_width = 2,
            horizontal_scroll_height = 3,
            caption_height = 4,
            border_width = 5,
            border_height = 6,
            fixed_frame_width = 7,
            fixed_frame_height = 8,
            vertical_slider_height = 9,
            horizontal_slider_width = 10,
            icon_width = 11,
            icon_height = 12,
            cursor_width = 13,
            cursor_height = 14,
            menu_height = 15,
            full_screen_width = 16,
            full_screen_height = 17,
            kanji_window_height = 18,
            mouse_present = 19,
            vertical_scroll_arrow_height = 20,
            horizontal_scroll_arrow_width = 21,
            debug = 22,
            swap_button = 23,
            reserved1 = 24,
            reserved2 = 25,
            reserved3 = 26,
            reserved4 = 27,
            minimum_width = 28,
            minimum_height = 29,
            button_width = 30,
            button_height = 31,
            size_frame_width = 32,
            size_frame_height = 33,
            minimum_track_width = 34,
            minimum_track_height = 35,
            double_click_width = 36,
            double_click_height = 37,
            icon_spacing_width = 38,
            icon_spacing_height = 39,
            menu_drop_alignment = 40,
            pen_windows = 41,
            double_byte_enabled = 42,
            number_mouse_buttons = 43,
            secure = 44,
            edge_width = 45,
            edge_height = 46,
            minimize_grid_width = 47,
            minimize_grid_height = 48,
            small_icon_width = 49,
            small_icon_height = 50,
            small_caption_height = 51,
            small_button_width = 52,
            small_button_height = 53,
            menu_button_width = 54,
            menu_button_height = 55,
            arrange = 56,
            minimized_width = 57,
            minimized_height = 58,
            maximum_track_width = 59,
            maximum_track_height = 60,
            maximized_width = 61,
            maximized_height = 62,
            network = 63,
            clean_boot = 67,
            drag_width = 68,
            drag_height = 69,
            sounds_show = 70,
            menu_check_width = 71,
            menu_check_height = 72,
            slow_machine = 73,
            mideast_enabled = 74,
            mouse_wheel_present = 75,
            virtual_screen_x = 76,
            virtual_screen_y = 77,
            virtual_screen_width = 78,
            virtual_screen_height = 79,
            number_of_monitors = 80,
            same_display_format = 81,
            input_method_enabled = 82,
            focus_border_width = 83,
            focus_border_height = 84,
            table_cpc = 86,
            media_center = 87,
            starter = 88,
            server_r2 = 89,
        };
    };

    export struct arrange_icons
    {
        enum
        {
            bottom_left = 0x0000,
            bottom_right = 0x0001,
            top_left = 0x0002,
            top_right = 0x0003,
            start_right = 0x0001,
            start_top = 0x0002,
            start_mask = 0x0003,
            horizontal = 0x0000,
            vertical = 0x0004,
            hide = 0x0008
        };
    };

    export struct image_flag
    {
        enum
        {
            load_default_color = 0x0000,
            load_monochrome = 0x0001,
            load_color = 0x0002,
            copy_exact = 0x0004,
            copy_delete_original = 0x0008,
            load_from_file = 0x0010,
            load_transparent = 0x0020,
            load_default_size = 0x0040,
            load_vga_color = 0x0080,
            load_map_3d_colors = 0x1000,
            load_create_bitmap_section = 0x2000,
            copy_from_resource = 0x4000,
            load_shared = 0x8000
        };
    };

    export struct image_type
    {
        enum
        {
            bitmap = 0,
            icon = 1,
            cursor = 2,
            metafile = 3
        };
    };

    export struct device_broadcast_type
    {
        enum
        {
            configuration_change_query = 0x0017,
            configuration_changed = 0x0018,
            configuration_change_cancelled = 0x0019,
            arrival = 0x8000,
            remove_query = 0x8001,
            remove_query_failed = 0x8002,
            remove_pending = 0x8003,
            remove_complete = 0x8004,
            type_specific = 0x8005,
            user_defined = 0xffff
        };
    };

    export struct device_broadcast
    {
        uint size;
        uint type;
        uint reserved;

        device_broadcast() : size(sizeof(device_broadcast)), reserved(0) {}
    };

    export template<class character>
        struct device_broadcast_user_defined : public device_broadcast
    {
        character name[1];
    };

    export struct mouse_move_resolution
    {
        enum
        {
            display = 1,
            driver = 2
        };
    };

    export struct mouse_move_point
    {
        int x;
        int y;
        uint time;
        void* extra;
    };

    export struct broadcast_recipient
    {
        enum
        {
            all_components = 0x00000000,
            system_drivers = 0x00000001,
            network_driver = 0x00000002,
            installable_drivers = 0x00000004,
            applications = 0x00000008,
            all_desktops = 0x00000010
        };
    };

    export struct broadcast_flag
    {
        enum
        {
            query = 0x00000001,
            current_task_ignore = 0x00000002,
            disk_flush = 0x00000004,
            no_hang = 0x00000008,
            message_post = 0x00000010,
            force_if_hung = 0x00000020,
            no_timeout_if_not_hung = 0x00000040
        };
    };

    export  enum { broadcast_deny_query = 0x424d5144 };

    export struct mouse_input
    {
        int x;
        int y;
        uint data;
        uint flags;
        uint time;
        void* extra;
    };

    export struct keyboard_input
    {
        part virtual_key;
        part scan;
        uint flags;
        uint time;
        void* extra;
    };

    export struct hardware_input
    {
        uint message;
        part low;
        part high;
    };

    export struct input_type
    {
        enum
        {
            mouse = 0,
            keyboard = 1,
            hardware = 2
        };
    };

    export struct input
    {
        uint type;

        union
        {
            mouse_input    mouse;
            keyboard_input keyboard;
            hardware_input hardware;
        };
    };

    export struct input_information
    {
        uint size;
        uint time;
    };

    export template<class character>
        struct nonclient_metrics
    {
        uint size;
        int border_width;
        int scroll_width;
        int scroll_height;
        int caption_width;
        int caption_height;
        logical_font<character> font_caption;
        int small_caption_width;
        int small_caption_height;
        logical_font<character> small_caption_font;
        int menu_width;
        int menu_height;
        logical_font<character> menu_font;
        logical_font<character> status_font;
        logical_font<character> message_font;
    };

    export struct minimized_metrics
    {
        uint size;
        int width;
        int horizontal_spacing;
        int vertical_spacing;
        int arrange;
    };

    export template<class character>
        struct icon_metrics
    {
        uint size;
        int horizontal_spacing;
        int vertical_spacing;
        int wrap;
        logical_font<character> font;
    };

    export struct animation_information
    {
        uint size;
        int minimum;
    };

    export struct serial_key_flag
    {
        enum
        {
            on = 0x0001,
            available = 0x0002,
            indicator = 0x0004
        };
    };

    export template<class character>
        struct serial_keys
    {
        uint size;
        uint flags;
        character* auto_port;
        character* port;
        uint baud;
        uint state;
        uint active;
    };

    export struct high_contrast_flag
    {
        enum
        {
            on = 0x00000001,
            available = 0x00000002,
            hotkey_active = 0x00000004,
            hotkey_confirm = 0x00000008,
            hotkey_sound = 0x00000010,
            indicator = 0x00000020,
            hotkey_available = 0x00000040
        };
    };

    export template<class character>
        struct high_contrast
    {
        uint size;
        uint flags;
        character* scheme;
    };

    export struct display_change_flag
    {
        enum
        {
            update_registry = 0x00000001,
            test = 0x00000002,
            full_screen = 0x00000004,
            global = 0x00000008,
            set_primary = 0x00000010,
            reset = 0x40000000,
            set_rectangle = 0x20000000,
            no_reset = 0x10000000
        };
    };

    export struct display_change_return
    {
        enum
        {
            successful = 0,
            restart = 1,
            failed = -1,
            mode_bad = -2,
            not_updated = -3,
            flags_bad = -4,
            parameter_bad = -5
        };
    };

    export struct display_settings_mode
    {
        enum
        {
            current = -1,
            registry = -2
        };
    };

    export struct filter_key_flag
    {
        enum
        {
            on = 0x00000001,
            available = 0x00000002,
            hotkey_active = 0x00000004,
            hotkey_confirm = 0x00000008,
            hotkey_sound = 0x00000010,
            indicator = 0x00000020,
            click_on = 0x00000040
        };
    };

    export struct filter_keys
    {
        uint size;
        uint flags;
        uint wait;
        uint delay;
        uint repeat;
        uint bounce;
    };

    export struct sticky_key_flag
    {
        enum
        {
            on = 0x00000001,
            available = 0x00000002,
            hotkey_active = 0x00000004,
            hotkey_confirm = 0x00000008,
            hotkey_sound = 0x00000010,
            indicator = 0x00000020,
            audible_feedback = 0x00000040,
            tristate = 0x00000080,
            two_keys_off = 0x00000100,
            left_alt_latched = 0x10000000,
            left_control_latched = 0x04000000,
            left_shift_latched = 0x01000000,
            right_alt_latched = 0x20000000,
            right_control_latched = 0x08000000,
            right_shift_latched = 0x02000000,
            left_window_latched = 0x40000000,
            right_window_latched = 0x80000000,
            left_alt_locked = 0x00100000,
            left_control_locked = 0x00040000,
            left_shift_locked = 0x00010000,
            right_alt_locked = 0x00200000,
            right_control_locked = 0x00080000,
            right_shift_locked = 0x00020000,
            left_window_locked = 0x00400000,
            right_window_locked = 0x00800000
        };
    };

    export struct sticky_keys
    {
        uint size;
        uint flags;
    };

    export struct mouse_key_flag
    {
        enum
        {
            on = 0x00000001,
            available = 0x00000002,
            hotkey_active = 0x00000004,
            hotkey_confirm = 0x00000008,
            hotkey_sound = 0x00000010,
            indicator = 0x00000020,
            modifiers = 0x00000040,
            replace_numbers = 0x00000080,
            left_button_select = 0x10000000,
            right_button_select = 0x20000000,
            left_button_down = 0x01000000,
            right_button_down = 0x02000000,
            mouse_mode = 0x80000000
        };
    };

    export struct mouse_keys
    {
        uint size;
        uint flags;
        uint speed;
        uint time;
        uint control;
        uint reserved1;
        uint reserved2;
    };

    export struct sound_sentry_flag
    {
        enum
        {
            on = 0x00000001,
            available = 0x00000002,
            indicator = 0x00000004
        };
    };

    export struct sound_sentry__effect
    {
        enum
        {
            none = 0,
            display = 3
        };
    };

    export struct sound_sentry_text_effect
    {
        enum
        {
            none = 0,
            characters = 1,
            border = 2,
            display = 3
        };
    };

    export struct sound_sentry_windows_effect
    {
        enum
        {
            none = 0,
            title = 1,
            window = 2,
            display = 3,
            custom = 4
        };
    };

    export template<class character>
        struct sound_sentry
    {
        uint size;
        uint flags;
        uint text_effect;
        uint text_effect_time;
        uint text_effect_color_bits;
        uint _effect;
        uint _effect_time;
        uint _effect_color;
        uint windows_effect;
        uint windows_effect_time;
        character* windows_effect_library;
        uint windows_effect_ordinal;
    };

    export struct access_timeout_flag
    {
        enum
        {
            on = 0x0001,
            on_off_feedback = 0x0002,
            available = 0x0004
        };
    };

    export struct access_timeout
    {
        uint size;
        uint flags;
        uint timeout;
    };

    export struct toggle_keys_flag
    {
        enum
        {
            on = 0x00000001,
            available = 0x00000002,
            hotkey_active = 0x00000004,
            hotkey_confirm = 0x00000008,
            hotkey_sound = 0x00000010,
            indicator = 0x00000020
        };
    };

    export struct toggle_keys
    {
        uint size;
        uint flags;
    };

    export struct monitor_default
    {
        enum
        {
            to_null = 0x0000,
            to_primary = 0x0001,
            to_nearest = 0x0002
        };
    };

    export  enum { monitor_information_primary = 0x00000001 };

    export struct monitor_information
    {
        uint size;
        irectangle monitor;
        irectangle area;
        uint flags;

        monitor_information() : size(sizeof(monitor_information)) {}
    };

    export template<class character>
        struct monitor_information_extended : public monitor_information
    {
        character device[device_name_length];
    };

    export struct windows_event_hook_flag
    {
        enum
        {
            out_of_context = 0x0000,
            skip_own_thread = 0x0001,
            skip_own_process = 0x0002,
            in_context = 0x0004
        };
    };

    export struct common_object_identity
    {
        enum
        {
            child_self = 0,
            index_object = 0,
            index_container = 0
        };
    };

    export struct object_identity
    {
        enum
        {
            window = 0x00000000,
            system_menu = 0xffffffff,
            title_bar = 0xfffffffe,
            menu = 0xfffffffd,
            client = 0xfffffffc,
            vertical_scroll = 0xfffffffb,
            horizontal_scroll = 0xfffffffa,
            size_grip = 0xfffffff9,
            caret = 0xfffffff8,
            cursor = 0xfffffff7,
            alert = 0xfffffff6,
            sound = 0xfffffff5,
            query_class_name_index = 0xfffffff4,
            native_oem = 0xfffffff0
        };
    };

    export struct event_limit
    {
        enum
        {
            minimum = 0x00000001,
            maximum = 0x7fffffff
        };
    };

    export struct system_event
    {
        enum
        {
            sound = 0x0001,
            alert = 0x0002,
            foreground = 0x0003,
            start_menu = 0x0004,
            end_menu = 0x0005,
            start_popup_menu = 0x0006,
            end_popup_menu = 0x0007,
            start_capture = 0x0008,
            end_capture = 0x0009,
            start_move_size = 0x000a,
            end_move_size = 0x000b,
            start_context_help = 0x000c,
            end_context_help = 0x000d,
            start_drag_drop = 0x000e,
            end_drag_drop = 0x000f,
            start_dialog = 0x0010,
            end_dialog = 0x0011,
            start_scrolling = 0x0012,
            end_scrolling = 0x0013,
            start_switch = 0x0014,
            end_switch = 0x0015,
            start_minimize = 0x0016,
            end_minimize = 0x0017
        };
    };

    export struct event_object
    {
        enum
        {
            create = 0x8000,
            destroy = 0x8001,
            show = 0x8002,
            hide = 0x8003,
            reorder = 0x8004,
            focus = 0x8005,
            selection = 0x8006,
            selection_add = 0x8007,
            selection_remove = 0x8008,
            selection_within = 0x8009,
            state_change = 0x800a,
            location_change = 0x800b,
            name_change = 0x800c,
            description_change = 0x800d,
            value_change = 0x800e,
            parent_change = 0x800f,
            help_change = 0x8010,
            default_action_change = 0x8011,
            accelerator_change = 0x8012
        };
    };

    export struct system_sound
    {
        enum
        {
            startup = 1,
            shutdown = 2,
            beep = 3,
            error = 4,
            question = 5,
            warning = 6,
            information = 7,
            maximize = 8,
            minimize = 9,
            restore_up = 10,
            restore_down = 11,
            application_start = 12,
            fault = 13,
            append = 14,
            menu_command = 15,
            menu_popup = 16
        };
    };

    export struct system_alert
    {
        enum
        {
            information = 1,
            warning = 2,
            error = 3,
            query = 4,
            critical = 5
        };
    };

    export struct _thread_flag
    {
        enum
        {
            caret_blinking = 0x0001,
            move_size = 0x0002,
            menu_mode = 0x0004,
            menu_mode_system = 0x0008,
            menu_mode_popup = 0x0010
        };
    };

    export struct _thread_information
    {
        uint size;
        uint flags;
        handle active;
        handle focus;
        handle capture;
        handle owner;
        handle move;
        handle caret;
        irectangle bounds;

        _thread_information() : size(sizeof(_thread_information)) {}
    };

    export  enum { cursor_showing = 0x0001 };

    export struct cursor_control_information
    {
        uint size;
        uint flags;
        handle cursor;
        ipoint position;

        cursor_control_information() : size(sizeof(cursor_control_information)) {}
    };

    export struct window_information
    {
        uint size;
        irectangle window;
        irectangle client;
        uint style;
        uint extended;
        uint other;
        uint width;
        uint height;
        atom type;
        part version;
    };

    export  enum { titlebar_children = 5 };

    export struct system_state
    {
        enum
        {
            unavailable = 0x00000001,
            selected = 0x00000002,
            focused = 0x00000004,
            pressed = 0x00000008,
            checked = 0x00000010,
            mixed = 0x00000020,
            indeterminate = mixed,
            readonly = 0x00000040,
            hot_tracked = 0x00000080,
            _default = 0x00000100,
            expanded = 0x00000200,
            collapsed = 0x00000400,
            busy = 0x00000800,
            floating = 0x00001000,
            marqueed = 0x00002000,
            animated = 0x00004000,
            invisible = 0x00008000,
            off_screen = 0x00010000,
            sizeable = 0x00020000,
            moveable = 0x00040000,
            self_voicing = 0x00080000,
            focusable = 0x00100000,
            selectable = 0x00200000,
            linked = 0x00400000,
            traversed = 0x00800000,
            multi_selectable = 0x01000000,
            ext_selectable = 0x02000000,
            alert_low = 0x04000000,
            alert_medium = 0x08000000,
            alert_high = 0x10000000,
            _protected = 0x20000000,
            valid = 0x3fffffff
        };
    };

    export struct titlebar_information
    {
        uint size;
        irectangle titlebar;
        uint states[titlebar_children + 1];
    };

    export struct menubar_information
    {
        uint size;
        irectangle bounds;
        handle menu;
        handle submenu;
        uint menu_focused : 1;
        uint item_focused : 1;
    };

    export  enum { scrollbar_children = 5 };

    export struct scrollbar_control_information
    {
        uint size;
        irectangle bounds;
        int line_button_xy;
        int slider_top_xy;
        int slider_bottom_xy;
        int dummy;
        uint states[scrollbar_children + 1];
    };

    export struct scrollbar_style
    {
        enum
        {
            horizontal = 0x0000,
            vertical = 0x0001,
            align_top = 0x0002,
            align_left = 0x0002,
            align_bottom = 0x0004,
            align_right = 0x0004,
            sizebox_align_top_left = 0x0002,
            sizebox_align_bottom_right = 0x0004,
            sizebox = 0x0008,
            sizegrip = 0x0010
        };
    };

    export struct scrollbar_message
    {
        enum
        {
            enable_arrows = 0x00e4,
            get_position = 0x00e1,
            set_window_position = 0x00e0,
            get_range = 0x00e3,
            set_range = 0x00e2,
            set_range_redraw = 0x00e6,
            set_information = 0x00e9,
            get_information = 0x00ea
        };
    };

    export struct scrollbar_notify
    {
        enum
        {
            line_up = 0,
            line_left = 0,
            line_down = 1,
            line_right = 1,
            page_up = 2,
            page_left = 2,
            page_down = 3,
            page_right = 3,
            slider_position = 4,
            slider_track = 5,
            top = 6,
            left = 6,
            bottom = 7,
            right = 7,
            end = 8
        };
    };

    export struct combobox_information
    {
        uint size;
        irectangle bounds;
        irectangle button;
        uint state;
        handle combo;
        handle item;
        handle list;
    };

    export  typedef bool(__stdcall* monitor)(handle monitor,
        handle device,
        irectangle* clip,
        parameter parameter_enumerate);

    export  typedef void(__stdcall* windows_event)(handle hook,
        uint event,
        handle window,
        int object,
        uint child,
        uint thread,
        uint time);

    export  enum { dialog_window_extra = 48 };

    export struct dialog_style
    {
        enum
        {
            align_absolute = 0x01,
            system_modal = 0x02,
            local_edit = 0x20,
            set_font = 0x40,
            modal_frame = 0x80,
            no_idle_message = 0x100,
            set_foreground = 0x200,
            three_d_look = 0x0004,
            fixed_system = 0x0008,
            no_fail_create = 0x0010,
            control = 0x0400,
            center = 0x0800,
            center_mouse = 0x1000,
            context_help = 0x2000
        };
    };

    export struct dialog_message
    {
        enum
        {
            get_default_identity = 0x0400,
            set_default_identity = 0x0401,
            reposition = 0x0402
        };
    };

    export  enum { dialog_has_default_identity = 0x534b };

    export struct dialog_code
    {
        enum
        {
            accept_arrows = 0x0001,
            accept_tab = 0x0002,
            accept_all_keys = 0x0004,
            accept_message = 0x0004,
            set_selection = 0x0008,
            default_push_button = 0x0010,
            nondefault_push_button = 0x0020,
            radio_button = 0x0040,
            accept_characters = 0x0080,
            display = 0x0100,
            button = 0x2000
        };
    };

    export struct dialog_template
    {
        uint style;
        uint extended;
        part items;
        short x;
        short y;
        short width;
        short height;
    };

    export struct dialog_item
    {
        uint style;
        uint extended;
        short x;
        short y;
        short width;
        short height;
        part identity;
    };

    export struct dialog_information
    {
        enum { direct, indirect };

        int type;
        void* template_pointer;
        handle parent;
        procedure procedure_pointer;
        parameter parameter_dialog;
        handle modulehandle;
    };

    export struct cursor_identity
    {
        enum
        {
            arrow = 32512,
            i_beam = 32513,
            wait = 32514,
            cross = 32515,
            up_arrow = 32516,
            size = 32640,
            icon = 32641,
            size_nwse = 32642,
            size_nesw = 32643,
            size_we = 32644,
            size_ns = 32645,
            size_all = 32646,
            no = 32648,
            hand = 32649,
            help = 32651,
            starting = 32650
        };
    };

    export struct cursor_shape
    {
        ipoint hotspot;
        int width;
        int height;
        int byte_width;
        byte planes;
        byte bits_per_pixel;
    };

    export struct window_position_change
    {
        handle window;
        handle after;
        ipoint position;
        idimensions size;
        uint flags;
    };

    export struct calculate_nonclient_size
    {
        irectangle array[3];
        window_position_change* position;
    };

    export struct calculate_size
    {
        irectangle array[3];
        window_position_change* position;
    };

    export struct copy_data
    {
        void* user;
        uint size;
        void* data;

        copy_data(void* user_set = 0,
            uint size_set = 0,
            void* dataset = (void*)0)
            : user(user_set),
            size(size_set),
            data(dataset) {}
    };

    export template <class character>
        struct window_create
    {
        void* parameters;
        handle module;
        handle menu;
        handle parent;
        int height;
        int width;
        int y;
        int x;
        uint style;
        const character* title;
        const character* _class;
        uint extended;
    };

    export struct client_create
    {
        handle menu_handle;
        uint first_child;
    };

    export struct compare_item
    {
        uint type;
        uint control;
        handle window;
        uint identity1;
        void* data1;
        uint identity2;
        void* data2;
        uint locale;
    };

    export struct delete_item
    {
        uint type;
        uint control;
        uint identity;
        handle window;
        void* data;
    };

    export struct item_type
    {
        enum
        {
            menu = 1,
            listbox = 2,
            combobox = 3,
            button = 4,
            display = 5,
            header = 100,
            tab = 101,
            listview = 102
        };
    };

    export struct item_action
    {
        enum
        {
            entire = 0x0001,
            select = 0x0002,
            focus = 0x0004
        };
    };

    export struct item_state
    {
        enum
        {
            selected = 0x0001,
            grayed = 0x0002,
            disabled = 0x0004,
            checked = 0x0008,
            focus = 0x0010,
            _default = 0x0020,
            combobox_edit = 0x1000,
            highlight = 0x0040,
            inactive = 0x0080
        };
    };

    export struct draw_item
    {
        uint type;
        uint control;
        uint identity;
        uint action;
        uint state;
        handle window;
        handle device;
        irectangle bounds;
        void* data;
    };

    export struct measure_item
    {
        uint type;
        uint control;
        uint identity;
        uint width;
        uint height;
        void* data;
    };

    export struct minimum_maximum_information
    {
        ipoint reserved;
        ipoint maximum_size;
        ipoint maximum_position;
        ipoint minimum_track_size;
        ipoint maximum_track_size;
    };

    export template <class character>
        struct multidocument_create
    {
        const character* _class;
        const character* title;
        handle owner;
        int x;
        int y;
        int width;
        int height;
        uint style;
        parameter parameter2;
    };

    export extern "C" int __stdcall print_string_a(const char*, const char*, ...);

    export extern "C" int __stdcall print_string_w(const wchar_t*, const wchar_t*, ...);

    export extern "C" int __stdcall print_string(const wchar_t*, const wchar_t*, ...);

    export extern "C" int __stdcall message_box_a(handle window,
        const char* text,
        const char* caption,
        uint type);

    export extern "C" int __stdcall message_box_w(handle window,
        const wchar_t* text,
        const wchar_t* caption,
        uint type);

    export template <class character>
        inline int message_box(handle window,
            character* text,
            character* caption,
            uint type)
    {
        if (sizeof(character) == 1)
            return message_box_a(window, (const char*)text, (const char*)caption, type);
        else
            return message_box_w(window, (const wchar_t*)text, (const wchar_t*)caption, type);
    }

    export extern "C" int __stdcall message_box_extended_a(handle window,
        const char* text,
        const char* caption,
        uint type,
        part language);

    export extern "C" int __stdcall message_box_extended_w(handle window,
        const wchar_t* text,
        const wchar_t* caption,
        uint type,
        part language);

    export template <class character>
        inline int message_box_extended(handle window,
            const character* text,
            const character* caption,
            uint type,
            part language)
    {
        if (sizeof(character == 1))
            return message_box_extended_a(window, (const char*)text, (const char*)caption, type, language);
        else
            return message_box_extended_w(window, (const wchar_t*)text, (const wchar_t*)caption, type, language);
    }

    export extern "C" bool __stdcall message_beep(uint type);

    //*** system exceptions

    export extern "C" void __stdcall raise_exception(uint code,
        uint flags,
        uint parameters,
        const void** array);

    export extern "C" int __stdcall unhandled_exception_filter(exception_pointers*);

    export extern "C" top_level_exception_filter __stdcall set_unhandled_exception_filter(top_level_exception_filter);

    //*** errors

    export extern "C" uint __stdcall set_error_mode(uint mode);

    export extern "C" uint __stdcall get_last_error();

    export extern "C" void __stdcall set_last_error(uint error);

    export extern "C" void __stdcall set_last_error_extended(uint error,
        uint type);

    export extern "C" bool __stdcall create_hard_link_a(const char* file_name,
        const char* existing,
        security_attributes * security);

    export extern "C" bool __stdcall create_hard_link_w(const wchar_t* file_name,
        const wchar_t* existing,
        security_attributes * security);

    export template<class character>
        inline bool create_hard_link(const character* file_name,
            const character* existing,
            security_attributes* security)
    {
        if (sizeof(character) == 1)
            return create_hard_link_a((const char*)file_name,
                (const char*)existing,
                security);
        else
            return create_hard_link_w((const wchar_t*)file_name,
                (const wchar_t*)existing,
                security);
    }

    export extern "C" bool __stdcall copy_file_extended_a(const char* existing_file,
        const char* new_file,
        progress callback,
        void* data,
        bool* cancel,
        uint flags);

    export extern "C" bool __stdcall copy_file_extended_w(const wchar_t* existing_file,
        const wchar_t* new_file,
        progress callback,
        void* data,
        bool* cancel,
        uint flags);

    export template<class character>
        inline bool copy_file_extended(const character* existing_file,
            const character* new_file,
            progress callback,
            void* data,
            bool* cancel,
            uint flags)
    {
        if (sizeof(character) == 1)
            return copy_file_extended_a((const char*)existing_file,
                (const char*)new_file,
                callback,
                data,
                cancel,
                flags);
        else
            return copy_file_extended_w((const wchar_t*)existing_file,
                (const wchar_t*)new_file,
                callback,
                data,
                cancel,
                flags);
    }

    export extern "C" bool __stdcall get_binary_type_a(const char* application_name,
        uint * binary_type);

    export extern "C" bool __stdcall get_binary_type_w(const wchar_t* application_name,
        uint * binary_type);

    export template<class character>
        inline bool get_binary_type(const character* application_name,
            uint* binary_type)
    {
        if (sizeof(character) == 1)
            return get_binary_type_a((const char*)application_name,
                binary_type);
        else
            return get_binary_type_w((const wchar_t*)application_name,
                binary_type);
    }

    export extern "C" uint __stdcall get_short_path_name_a(const char* long_path,
        char* short_path,
        uint size);

    export extern "C" uint __stdcall get_short_path_name_w(const wchar_t* long_path,
        wchar_t* short_path,
        uint size);

    export template<class character>
        inline uint get_short_path_name(const character* long_path,
            character* short_path,
            uint size)
    {
        if (sizeof(character) == 1)
            return get_short_path_name_a((const char*)long_path,
                (char*)short_path,
                size);
        else
            return get_short_path_name_w((const wchar_t*)long_path,
                (wchar_t*)short_path,
                size);
    }

    export extern "C" uint __stdcall get_long_path_name_a(const char* short_path,
        char* long_path,
        uint buffer);

    export extern "C" uint __stdcall get_long_path_name_w(const wchar_t* short_path,
        wchar_t* long_path,
        uint buffer);

    export template<class character>
        inline uint get_long_path_name(const character* short_path,
            character* long_path,
            uint buffer)
    {
        if (sizeof(character) == 1)
            return get_long_path_name_a((const char*)short_path,
                (char*)long_path,
                buffer);
        else
            return get_long_path_name_w((const wchar_t*)short_path,
                (wchar_t*)long_path,
                buffer);
    }

    export extern "C" bool __stdcall get_volume_information_a(const char* root,
        char* volume,
        uint volume_name_size,
        uint * serial,
        uint * component,
        uint * flags,
        char* system,
        uint system_size);

    export extern "C" bool __stdcall get_volume_information_w(const wchar_t* root,
        wchar_t* volume,
        uint volume_name_size,
        uint * serial,
        uint * component,
        uint * flags,
        wchar_t* system,
        uint system_size);

    export template<class character>
        inline bool get_volume_information_w(const character* root,
            character* volume,
            uint volume_name_size,
            uint* serial,
            uint* component,
            uint* flags,
            character* system,
            uint system_size)
    {
        if (sizeof(character) == 1)
            return get_volume_information_a((const char*)root,
                (char*)volume,
                volume_name_size,
                serial,
                component,
                flags,
                system,
                system_size);
        else
            return get_volume_information_w((const wchar_t*)root,
                (wchar_t*)volume,
                volume_name_size,
                serial,
                component,
                flags,
                system,
                system_size);
    }

    export extern "C" uint __stdcall get_compressed_file_size_a(const char* file_name,
        uint * file_size_high);

    export extern "C" uint __stdcall get_compressed_file_size_w(const wchar_t* file_name,
        uint * file_size_high);

    export template<class character>
        inline uint get_compressed_file_size(const character* file_name,
            uint* file_size_high)
    {
        if (sizeof(character) == 1)
            return get_compressed_file_size_a((const char*)file_name,
                file_size_high);
        else
            return get_compressed_file_size_w((const wchar_t*)file_name,
                file_size_high);
    }

    export extern "C" bool __stdcall close_handle(handle object);

    export extern "C" bool __stdcall cancel_input_output(handle file);

    export extern "C" bool __stdcall duplicate_handle(handle source,
        handle duplicate,
        handle target,
        handle * result,
        uint access,
        bool inherit,
        uint options);

    //*** strings

    export extern "C" int __stdcall compare_strings_a(const char* string1,
        const char* string2);

    export extern "C" int __stdcall compare_strings_w(const wchar_t* string1,
        const wchar_t* string2);

    export template<class character>
        inline int compare_strings(const character* string1,
            const character* string2)
    {
        if (sizeof(character) == 1)
            return compare_strings_a((const char*)string1,
                (const char*)string2);
        else
            return compare_strings_w((const wchar_t*)string1,
                (const wchar_t*)string2);
    }

    export extern "C" int __stdcall compare_strings_ignore_a(const char* string1,
        const char* string2);

    export extern "C" int __stdcall compare_strings_ignore_w(const wchar_t* string1,
        const wchar_t* string2);

    export template<class character>
        inline int compare_strings_ignore(const character* string1,
            const character* string2)
    {
        if (sizeof(character) == 1)
            return compare_strings_ignore_a((const char*)string1,
                (const char*)string2);
        else
            return compare_strings_ignore_w((const wchar_t*)string1,
                (const wchar_t*)string2);
    }

    export extern "C" char* __stdcall copy_string_a(char* string1,
        const char* string2);

    export extern "C" wchar_t* __stdcall copy_string_w(wchar_t* string1,
        const wchar_t* string2);

    export template<class character>
        inline character* copy_string(character* string1,
            const character* string2)
    {
        if (sizeof(character) == 1)
            return (character*)copy_string_a((char*)string1,
                (const char*)string2);
        else
            return (character*)copy_string_w((wchar_t*)string1,
                (const wchar_t*)string2);
    }

    export extern "C" char* __stdcall concatenate_strings_a(char* string1,
        const char* string2);

    export extern "C" wchar_t* __stdcall concatenate_strings_w(wchar_t* string1,
        const wchar_t* string2);

    export template<class character>
        inline character* concatenate_strings(character* string1,
            const character* string2)
    {
        if (sizeof(character) == 1)
            return (character*)concatenate_strings_a((char*)string1,
                (const char*)string2);
        else
            return (character*)concatenate_strings_w((wchar_t*)string1,
                (const wchar_t*)string2);
    }

    export extern "C" uint __stdcall string_length_a(const char* string);

    export extern "C" uint __stdcall string_length_w(const wchar_t* string);

    export template<class character>
        inline uint string_length(const character* string)
    {
        if (sizeof(character) == 1)
            return string_length_a((const char*)string);
        else
            return string_length_w((const wchar_t*)string);
    }

    export extern "C" bool __stdcall character_to_locale_a(const char* source,
        char* destination);

    export extern "C" bool __stdcall character_to_locale_w(const wchar_t* source,
        wchar_t* destination);

    export template<class character>
        inline bool character_to_locale(const character* source,
            character* destination)
    {
        if (sizeof(character) == 1)
            return character_to_locale_a((const char*)source,
                (char*)destination);
        else
            return character_to_locale_w((const wchar_t*)source,
                (wchar_t*)destination);
    }

    export extern "C" bool __stdcall locale_to_character_a(const char* source,
        char* destination);

    export extern "C" bool __stdcall locale_to_character_w(const wchar_t* source,
        wchar_t* destination);

    export template<class character>
        inline bool locale_to_character(const character* source,
            character* destination)
    {
        if (sizeof(character) == 1)
            return locale_to_character_a((const char*)source,
                (char*)destination);
        else
            return locale_to_character_w((const wchar_t*)source,
                (wchar_t*)destination);
    }

    export extern "C" bool __stdcall character_to_locale_buffer_a(const char* source,
        char* destination,
        uint destination_length);

    export extern "C" bool __stdcall character_to_locale_buffer_w(const wchar_t* source,
        wchar_t* destination,
        uint destination_length);

    export template<class character>
        inline bool character_to_locale_buffer(const character* source,
            character* destination,
            uint destination_length)
    {
        if (sizeof(character) == 1)
            return character_to_locale_buffer_a((const char*)source,
                (char*)destination,
                destination_length);
        else
            return character_to_locale_buffer_w((const wchar_t*)source,
                (wchar_t*)destination,
                destination_length);
    }

    export extern "C" bool __stdcall locale_to_character_buffer_a(const char* source,
        char* destination,
        uint destination_length);

    export extern "C" bool __stdcall locale_to_character_buffer_w(const wchar_t* source,
        wchar_t* destination,
        uint destination_length);

    export template<class character>
        inline bool locale_to_character_buffer(const character* source,
            character* destination,
            uint destination_length)
    {
        if (sizeof(character) == 1)
            return locale_to_character_buffer_a((const char*)source,
                (char*)destination,
                destination_length);
        else
            return locale_to_character_buffer_w((const wchar_t*)source,
                (wchar_t*)destination,
                destination_length);
    }

    export extern "C" char* __stdcall character_upper_a(char* buffer);

    export extern "C" wchar_t* __stdcall character_upper_w(wchar_t* buffer);

    export template<class character>
        inline character* character_upper(character* buffer)
    {
        if (sizeof(character) == 1)
            return character_upper_a((char*)buffer);
        else
            return character_upper_w((wchar_t*)buffer);
    }

    export extern "C" uint __stdcall character_upper_buffer_a(char* buffer,
        uint length);

    export extern "C" uint __stdcall character_upper_buffer_w(wchar_t* buffer,
        uint length);

    export template<class character>
        inline uint character_upper_buffer(character* buffer,
            uint length)
    {
        if (sizeof(character) == 1)
            return character_upper_buffer_a((char*)buffer,
                length);
        else
            return character_upper_buffer_w((wchar_t*)buffer,
                length);
    }

    export extern "C" char* __stdcall character_lower_a(char* buffer);

    export extern "C" wchar_t* __stdcall character_lower_w(wchar_t* buffer);

    export template<class character>
        inline character* character_lower(character* buffer)
    {
        if (sizeof(character) == 1)
            return character_lower_a((char*)buffer);
        else
            return character_lower_w((wchar_t*)buffer);
    }

    export extern "C" uint __stdcall character_lower_buffer_a(char* buffer,
        uint length);

    export extern "C" uint __stdcall character_lower_buffer_w(wchar_t* buffer,
        uint length);

    export template<class character>
        inline uint character_lower_buffer(character* buffer,
            uint length)
    {
        if (sizeof(character) == 1)
            return character_lower_buffer_a((char*)buffer,
                length);
        else
            return character_lower_buffer_w((wchar_t*)buffer,
                length);
    }

    export extern "C" const char* __stdcall character_next_a(const char* current);

    export extern "C" const wchar_t* __stdcall character_next_w(const wchar_t* current);

    export template<class character>
        inline const character* character_next(const character* current)
    {
        if (sizeof(character) == 1)
            return (const char*)character_next_a((const char*)current);
        else
            return (const wchar_t*)character_next_w((const wchar_t*)current);
    }

    export extern "C" const char* __stdcall character_previous_a(const char* start,
        const char* current);

    export extern "C" const wchar_t* __stdcall character_previous_w(const wchar_t* start,
        const wchar_t* current);

    export template<class character>
        inline  const character* character_previous(const character* start,
            const character* current)
    {
        if (sizeof(character) == 1)
            return (const char*)character_previous_a((const char*)start,
                (const char*)current);
        else
            return (const wchar_t*)character_previous_w((const wchar_t*)start,
                (const wchar_t*)current);
    }

    export extern "C" const char* __stdcall character_next_extended_ascii(part codepage,
        const char* current,
        uint flags);

    export extern "C" const char* __stdcall character_previous_extended_ascii(part codepage,
        const char* start,
        const char* current,
        uint flags);

    //*** semaphores

    export extern "C" handle __stdcall create_exclusive_a(security_attributes * security,
        bool owner,
        const char* name);

    export extern "C" handle __stdcall create_exclusive_w(security_attributes * security,
        bool owner,
        const wchar_t* name);

    export template<class character>
        inline handle create_exclusive(security_attributes* security,
            bool owner,
            const character* name)
    {
        if (sizeof(character) == 1)
            return create_exclusive_a(security,
                owner,
                (const char*)name);
        else
            return create_exclusive_w(security,
                owner,
                (const wchar_t*)name);
    }

    export extern "C" bool __stdcall release_exclusive(handle exclusive);

    export extern "C" handle __stdcall open_exclusive_a(uint access,
        bool inherit,
        const char* name);

    export extern "C" handle __stdcall open_exclusive_w(uint access,
        bool inherit,
        const wchar_t* name);

    export template<class character>
        inline handle open_exclusive(uint access,
            bool inherit,
            const character* name)
    {
        if (sizeof(character) == 1)
            return open_exclusive_a(access,
                inherit,
                (const char*)name);
        else
            return open_exclusive_w(access,
                inherit,
                (const wchar_t*)name);
    }

    export extern "C" handle __stdcall create_event_a(security_attributes * security,
        bool manual_reset,
        bool initial_state,
        const char* name);

    export extern "C" handle __stdcall create_event_w(security_attributes * security,
        bool manual_reset,
        bool initial_state,
        const wchar_t* name);

    export template<class character>
        inline handle create_event(security_attributes* security,
            bool manual_reset,
            bool initial_state,
            const character* name)
    {
        if (sizeof(character) == 1)
            return create_event_a(security,
                manual_reset,
                initial_state,
                (const char*)name);
        else
            return create_event_w(security,
                manual_reset,
                initial_state,
                (const wchar_t*)name);
    }

    export extern "C" handle __stdcall open_event_a(uint access,
        bool inherit,
        const char* name);

    export extern "C" handle __stdcall open_event_w(uint access,
        bool inherit,
        const wchar_t* name);

    export template<class character>
        inline handle open_event(uint access,
            bool inherit,
            const character* name)
    {
        if (sizeof(character) == 1)
            return open_event_a(access,
                inherit,
                (const char*)name);
        else
            return open_event_w(access,
                inherit,
                (const wchar_t*)name);
    }

    export extern "C" bool __stdcall set_event(handle file);

    export extern "C" bool __stdcall reset_event(handle file);

    export extern "C" bool __stdcall pulse_event(handle file);

    export extern "C" uint __stdcall signal_object_and_wait(handle signal,
        handle wait,
        uint milliseconds,
        bool alertable);

    export extern "C" uint __stdcall wait_for_single_object(handle object,
        uint milliseconds);

    export extern "C" uint __stdcall wait_for_single_object_extended(handle object,
        uint milliseconds,
        bool alertable);

    export extern "C" uint __stdcall wait_for_multiple_objects(uint count,
        const handle * handles,
        bool wait_all,
        uint milliseconds);

    export extern "C" uint __stdcall message_wait_for_multiple_objects(uint count,
        const handle * handles,
        bool wait_all,
        uint milliseconds,
        uint mask);

    export extern "C" uint __stdcall wait_for_multiple_objects_extended(uint count,
        const handle * handles,
        bool wait_all,
        uint milliseconds,
        bool alertable);

    export extern "C" uint __stdcall message_wait_for_multiple_objects_extended(uint count,
        const handle * handles,
        uint milliseconds,
        uint wake_mask,
        uint flags);

    export extern "C" void __stdcall sleep(uint milliseconds);

    export extern "C" uint __stdcall sleep_extended(uint milliseconds,
        bool alertable);

    export extern "C" int __stdcall interlocked_increment(int* addend);

    export extern "C" int __stdcall interlocked_decrement(int* subtrahend);

    export extern "C" int __stdcall interlocked_exchange(int* target,
        int value);

    export extern "C" int __stdcall interlocked_exchange_add(int* target,
        int value);

    export extern "C" uint __stdcall interlocked_compare_exchange(uint * destination,
        uint exchange,
        uint comparand);

    //*** miscellaneous

    export extern "C" void __stdcall initialize_critical_section(critical_section * section);

    export extern "C" void __stdcall enter_critical_section(critical_section * section);

    export extern "C" void __stdcall leave_critical_section(critical_section * section);

    export extern "C" void __stdcall delete_critical_section(critical_section * section);

    export extern "C" bool __stdcall try_enter_critical_section(critical_section * section);

    export extern "C" bool __stdcall initialize_critical_section_and_spin_count(critical_section * section,
        uint count);

    export extern "C" uint __stdcall set_critical_section_spin_count(critical_section * section,
        uint count);

    export extern "C" uint __stdcall get_version();

    export extern "C" bool __stdcall get_version_extended_a(version_information<char>*information);

    export extern "C" bool __stdcall get_version_extended_w(version_information<wchar_t>*information);

    export template<class character>
        inline bool  get_version_extended(version_information<character>* information)
    {
        if (sizeof(character) == 1)
            return get_version_extended_a((version_information<char>*)information);
        else
            return get_version_extended_w((version_information<wchar_t>*)information);
    }

    //*** system messages

    export extern "C" uint __stdcall format_message_a(uint flags,
        const void* source,
        uint message,
        uint language,
        char* buffer,
        uint size,
        void* parameters);

    export extern "C" uint __stdcall format_message_w(uint flags,
        const void* source,
        uint message,
        uint language,
        wchar_t* buffer,
        uint size,
        void* parameters);

    export template<class character>
        inline uint format_message(uint flags,
            const void* source,
            uint message,
            uint language,
            character* buffer,
            uint size,
            void* parameters)
    {
        if (sizeof(character) == 1)
            return format_message_a(flags,
                source,
                message,
                language,
                (char*)buffer,
                size,
                parameters);
        else
            return format_message_w(flags,
                source,
                message,
                language,
                (wchar_t*)buffer,
                size,
                parameters);
    }

    //*** memory

    export extern "C" handle __stdcall allocate_global_memory(uint flags,
        ulong bytes);

    export extern "C" handle __stdcall reallocate_global_memory(handle memory,
        ulong bytes,
        uint flags);

    export extern "C" ulong __stdcall get_global_memory_size(handle memory);

    export extern "C" uint __stdcall get_global_memory_flags(handle memory);

    export extern "C" void* __stdcall lock_global_memory(handle memory);

    export extern "C" handle __stdcall get_global_memory_handle(const void* memory);

    export extern "C" bool __stdcall unlock_global_memory(handle memory);

    export extern "C" handle __stdcall free_global_memory(handle memory);

    export extern "C" ulong __stdcall shrink_global_memory(handle memory,
        uint new_size);

    export extern "C" void __stdcall global_memory_status(memory_status * status);

    export extern "C" bool __stdcall global_memory_status_extended(extended_memory_status * buffer);

    export extern "C" handle __stdcall load_resource(handle module,
        handle resource);

    export extern "C" bool __stdcall free_resource(handle resource);

    export extern "C" void* __stdcall lock_resource(handle resource);

    export extern "C" handle __stdcall allocate_local_memory(uint flags,
        ulong bytes);

    export extern "C" handle __stdcall reallocate_local_memory(handle memory,
        ulong bytes,
        uint flags);

    export extern "C" void* __stdcall lock_local_memory(handle memory);

    export extern "C" handle __stdcall get_local_memory_handle(const void* memory);

    export extern "C" bool __stdcall unlock_local_memory(handle memory);

    export extern "C" ulong __stdcall get_local_memory_size(handle memory);

    export extern "C" uint __stdcall get_local_memory_flags(handle memory);

    export extern "C" handle __stdcall free_local_memory(handle memory);

    export extern "C" ulong __stdcall shrink_local_memory(handle memory,
        uint new_size);

    export extern "C" ulong __stdcall compact_local_memory(uint minimum_free);

    export extern "C" void* __stdcall allocate_memory(void* address,
        ulong size,
        uint type,
        uint protection);

    export extern "C" void* __stdcall allocate_memory_extended(handle process,
        void* address,
        ulong size,
        uint type,
        uint protection);

    export extern "C" bool __stdcall free_memory(void* address,
        ulong size = 0,
        uint type = memory_flag::release);

    export extern "C" bool __stdcall free_memory_extended(handle process,
        void* address,
        ulong size = 0,
        uint type = memory_flag::release);

    export extern "C" bool __stdcall lock_memory(void* address,
        ulong size);

    export extern "C" bool __stdcall unlock_memory(void* address,
        ulong size);

    export extern "C" bool __stdcall protect_memory(void* address,
        ulong size,
        uint new_protection,
        uint * previous_protection);

    export extern "C" bool __stdcall protect_memory_extended(handle process,
        void* address,
        ulong size,
        uint new_protection,
        uint * previous_protection);

    export extern "C" ulong __stdcall query_memory(void* address,
        memory_information * buffer,
        ulong length);

    export extern "C" ulong __stdcall query_memory_extended(handle process,
        void* address,
        memory_information * buffer,
        ulong length);

    export extern "C" uint __stdcall get_write_watch(uint flags,
        void* base_address,
        ulong region_size,
        void* addresses,
        ulong * count,
        uint * granularity);

    export extern "C" uint __stdcall reset_write_watch(void* base_address,
        ulong region_size);

    export extern "C" ulong __stdcall get_large_page_minimum(void);

    //*** files

    export extern "C" bool __stdcall set_handle_information(handle object,
        uint mask,
        uint flags);

    export extern "C" handle __stdcall get___stdcall_handle(uint destination);

    export extern "C" bool __stdcall set___stdcall_handle(uint destination,
        handle file);

    export extern "C" handle __stdcall create_file_a(const char* file_name,
        uint access,
        uint share_mode,
        const security_attributes * security = 0,
        uint disposition = file_action::open_existing,
        uint flags_and_attributes = 0,
        handle template_file = 0);

    export extern "C" handle __stdcall create_file_w(const wchar_t* file_name,
        uint access,
        uint share_mode,
        const security_attributes * security = 0,
        uint disposition = file_action::open_existing,
        uint flags_and_attributes = 0,
        handle template_file = 0);

    export template<class character>
        inline handle create_file(const character* file_name,
            uint access,
            uint share_mode,
            const security_attributes* security = 0,
            uint disposition = file_action::open_existing,
            uint flags_and_attributes = 0,
            handle template_file = 0)
    {
        if (sizeof(character) == 1)
            return create_file_a((const char*)file_name,
                access,
                share_mode,
                security,
                disposition,
                flags_and_attributes,
                template_file);
        else
            return create_file_w((const wchar_t*)file_name,
                access,
                share_mode,
                security,
                disposition,
                flags_and_attributes,
                template_file);
    }

    export extern "C" bool __stdcall write_file(handle file,
        const void* buffer,
        uint count,
        uint * written,
        overlapped * overlapped_write = 0);

    export extern "C" bool __stdcall write_file_extended(handle file,
        const void* buffer,
        uint count,
        overlapped * overlapped_write,
        overlapped_completion completion);

    export extern "C" bool __stdcall read_file(handle file,
        void* buffer,
        uint count,
        uint * bytes,
        overlapped * overlapped_read = 0);

    export extern "C" bool __stdcall read_file_extended(handle file,
        void* buffer,
        uint count,
        overlapped * overlapped_read,
        overlapped_completion completion);

    export extern "C" uint __stdcall set_file_pointer(handle file,
        int low,
        int* high,
        uint method);

    export extern "C" unsigned set_file_ptr(handle file,
        long long ptr,
        unsigned method)
    {
        int high = (int)(ptr >> 32);
        return set_file_pointer(file, (int)ptr, &high, method);
    }

    export extern "C" bool __stdcall device_input_output_control(handle file,
        uint code,
        void* input_buffer,
        uint input_size,
        void* output_buffer,
        uint output_size,
        uint * returned,
        overlapped * overlapped_input_output);

    export extern "C" bool __stdcall lock_file(handle file,
        uint offset_low,
        uint offset_high,
        uint bytes_low,
        uint bytes_high);

    export extern "C" bool __stdcall lock_file_extended(handle file,
        uint flags,
        uint reserved,
        uint bytes_low,
        uint bytes_high,
        overlapped * overlapped_lock);

    export extern "C" bool __stdcall unlock_file(handle file,
        uint offset_low,
        uint offset_high,
        uint bytes_low,
        uint bytes_high);

    export extern "C" bool __stdcall unlock_file_extended(handle file,
        uint reserved,
        uint bytes_low,
        uint bytes_high,
        overlapped * overlapped_unlock);

    export extern "C" bool __stdcall get_file_information_by_handle(handle file,
        file_information * information);

    export extern "C" uint __stdcall get_file_type(handle file);

    export extern "C" uint __stdcall get_file_size(handle file,
        uint * high);

    export extern "C" long long get_file_length(handle file)
    {
        unsigned high = 0;
        int low = get_file_size(file, &high);
        return (long long)low | (long long)high << 32;
    }

    export extern "C" bool __stdcall flush_file_buffers(handle file);

    export extern "C" bool __stdcall set_end_of_file(handle file);

    export extern "C" bool __stdcall get_file_time(handle file,
        file_time * create,
        file_time * last_access,
        file_time * last_write);

    export extern "C" bool __stdcall set_file_time(handle file,
        const file_time * create,
        const file_time * last_access,
        const file_time * last_write);

    export extern "C" bool __stdcall get_overlapped_result(handle file,
        overlapped * result,
        uint * transferred,
        bool wait);

    export extern "C" handle __stdcall create_input_output_completion_port(handle file,
        handle port,
        void* completion_key,
        uint number_ofconcurrent_threads);

    export extern "C" bool __stdcall get_queued_completion_status(handle port,
        uint * transferred,
        void** completion_key,
        overlapped * *overlapped_address,
        uint milliseconds);

    export extern "C" bool __stdcall post_queued_completion_status(handle port,
        uint transferred,
        void* completion_key,
        overlapped * overlapped_completion);

    export extern "C" bool __stdcall read_directory_changes(handle directory,
        void* buffer,
        uint length,
        bool watch,
        uint filter,
        uint * returned,
        overlapped * overlapped_read,
        overlapped_completion completion);

    export extern "C" bool __stdcall backup_read(handle file,
        byte * buffer,
        uint read,
        uint * read_pointer,
        bool cancel,
        bool process_security,
        void** context_pointer);

    export extern "C" bool __stdcall backup_seek(handle file,
        uint seek_low,
        uint seek_high,
        uint * offset_low,
        uint * offset_high,
        void** context_pointer);

    export extern "C" bool __stdcall backup_write(handle file,
        const byte * buffer,
        uint write,
        uint * written,
        bool cancel,
        bool process_security,
        void** contextipointer);

    export extern "C" bool __stdcall set_file_attributes_a(const char* file_name,
        uint attributes);

    export extern "C" bool __stdcall set_file_attributes(const wchar_t* file_name,
        uint attributes);

    export template<class character>
        inline bool set_file_attributes(const character* file_name,
            uint attributes)
    {
        if (sizeof(character) == 1)
            return set_file_attributes_a((const char*)file_name,
                attributes);
        else
            return set_file_attributes_w((const wchar_t*)file_name,
                attributes);
    }

    export extern "C" uint __stdcall get_file_attributes_a(const char* file_name);

    export extern "C" uint __stdcall get_file_attributes_w(const wchar_t* file_name);

    export template<class character>
        inline uint get_file_attributes(const character* file_name)
    {
        if (sizeof(character) == 1)
            return get_file_attributes_a((const char*)file_name);
        else
            return get_file_attributes_w((const wchar_t*)file_name);
    }

    export extern "C" bool __stdcall get_file_attributes_extended_a(const char* file_name,
        uint level,
        void* information);

    export extern "C" bool __stdcall get_file_attributes_extended_w(const wchar_t* file_name,
        uint level,
        void* information);

    export template<class character>
        inline bool get_file_attributes_extended(const character* file_name,
            uint level,
            void* information)
    {
        if (sizeof(character) == 1)
            return get_file_attributes_extended_a((const char*)file_name,
                level,
                information);
        else
            return get_file_attributes_extended_w((const wchar_t*)file_name,
                level,
                information);
    }

    export extern "C" bool __stdcall delete_file_a(const char* file_name);

    export extern "C" bool __stdcall delete_file_w(const wchar_t* file_name);

    export template<class character>
        inline bool delete_file(const character* file_name)
    {
        if (sizeof(character) == 1)
            return delete_file_a((const char*)file_name);
        else
            return delete_file_w((const wchar_t*)file_name);
    }

    export extern "C" handle __stdcall find_first_file_a(const char* file_name,
        find_data<char>*data);

    export extern "C" handle __stdcall find_first_file_w(const wchar_t* file_name,
        find_data<wchar_t>*data);

    export template<class character>
        inline handle find_first_file(const character* file_name,
            find_data<character>* data)
    {
        if (sizeof(character) == 1)
            return find_first_file_a((const char*)file_name,
                (find_data<char>*)data);
        else
            return find_first_file_w((const wchar_t*)file_name,
                (find_data<wchar_t>)data);
    }

    export extern "C" handle __stdcall find_first_file_extended_a(const char* file_name,
        uint level,
        void* data,
        uint options,
        void* search_filter,
        uint additional_flags);

    export extern "C" handle __stdcall find_first_file_extended_w(const wchar_t* file_name,
        uint level,
        void* data,
        uint options,
        void* search_filter,
        uint additional_flags);

    export template<class character>
        inline handle find_first_file_extended(const character* file_name,
            uint level,
            void* data,
            uint options,
            void* search_filter,
            uint additional_flags)
    {
        if (sizeof(character) == 1)
            return find_first_file_extended_a((const char*)file_name,
                level,
                data,
                options,
                search_filter,
                additional_flags);
        else
            return find_first_file_extended_w((const wchar_t*)file_name,
                level,
                data,
                options,
                search_filter,
                additional_flags);
    }

    export extern "C" bool __stdcall find_next_file_a(handle file,
        find_data<char>*data);

    export extern "C" bool __stdcall find_next_file_w(handle file,
        find_data<wchar_t>*data);

    export template<class character>
        inline bool find_next_file(handle file,
            find_data<character>* data)
    {
        if (sizeof(character) == 1)
            return find_next_file_a(file,
                (find_data<char>*)data);
        else
            return find_next_file_w(file,
                (find_data<wchar_t>*)data);
    }

    export extern "C" bool __stdcall find_close(handle file);

    export extern "C" uint __stdcall search_path_a(const char* path,
        const char* file_name,
        const char* extension,
        uint size,
        char* buffer,
        char** part);

    export extern "C" uint __stdcall search_path_w(const wchar_t* path,
        const wchar_t* file_name,
        const wchar_t* extension,
        uint size,
        wchar_t* buffer,
        wchar_t** part);

    export template<class character>
        inline uint search_path(const character* path,
            const character* file_name,
            const character* extension,
            uint size,
            character* buffer,
            character** part)
    {
        if (sizeof(character) == 1)
            return search_path_a((const char*)path,
                (const char*)file_name,
                (const char*)extension,
                size,
                (char*)buffer,
                (char**)part);
        else
            return search_path_w((const wchar_t*)path,
                (const wchar_t*)file_name,
                (const wchar_t*)extension,
                size,
                (wchar_t*)buffer,
                (wchar_t**)part);
    }

    export extern "C" bool __stdcall copy_file_a(const char* source,
        const char* target,
        bool exists);

    export extern "C" bool __stdcall copy_file_w(const wchar_t* source,
        const wchar_t* target,
        bool exists);

    export template<class character>
        inline bool copy_file(const character* source,
            const character* target,
            bool exists)
    {
        if (sizeof(character) == 1)
            return copy_file_a((const char*)source,
                (const char*)target,
                exists);
        else
            return copy_file_w((const wchar_t*)source,
                (const wchar_t*)target,
                exists);
    }

    export extern "C" bool __stdcall move_file_a(const char* source,
        const char* target);

    export extern "C" bool __stdcall move_file_w(const wchar_t* source,
        const wchar_t* target);

    export template<class character>
        inline bool move_file(const character* source,
            const character* target)
    {
        if (sizeof(character) == 1)
            return move_file_a((const char*)source,
                (const char*)target);
        else
            return move_file_w((const wchar_t*)source,
                (const wchar_t*)target);
    }


    export extern "C" bool __stdcall move_file_extended_a(const char* source,
        const char* target,
        uint flags);

    export extern "C" bool __stdcall move_file_extended_w(const wchar_t* source,
        const wchar_t* target,
        uint flags);

    export template<class character>
        inline bool  move_file_extended(const character* source,
            const character* target,
            uint flags)
    {
        if (sizeof(character) == 1)
            return move_file_extended_a((const char*)source,
                (const char*)target,
                flags);
        else
            return move_file_extended_w((const wchar_t*)source,
                (const wchar_t*)target,
                flags);
    }

    export extern "C" bool __stdcall move_file_with_progress_a(const char* source,
        const char* target,
        progress callback,
        void* data,
        uint flags);

    export extern "C" bool __stdcall move_file_with_progress_w(const wchar_t* source,
        const wchar_t* target,
        progress callback,
        void* data,
        uint flags);

    export template<class character>
        inline bool move_file_with_progress(const character* source,
            const character* target,
            progress callback,
            void* data,
            uint flags)
    {
        if (sizeof(character) == 1)
            return move_file_with_progress_a((const char*)source,
                (const char*)target,
                callback,
                void* data,
                flags);
        else
            return move_file_with_progress_w((const wchar_t*)source,
                (const wchar_t*)target,
                callback,
                void* data,
                flags);
    }

    export extern "C" uint __stdcall get_system_directory_a(char* buffer,
        uint size);

    export extern "C" uint __stdcall get_system_directory_w(wchar_t* buffer,
        uint size);

    export template<class character>
        inline uint get_system_directory(character* buffer,
            uint size)
    {
        if (sizeof(character) == 1)
            return get_system_directory_a((char*)buffer,
                size);
        else
            return get_system_directory_w((wchar_t*)buffer,
                size);
    }

    export extern "C" uint __stdcall get_windows_directory_a(char* buffer,
        uint size);

    export extern "C" uint __stdcall get_windows_directory_w(wchar_t* buffer,
        uint size);

    export template<class character>
        inline uint get_windows_directory(character* buffer,
            uint size)
    {
        if (sizeof(character) == 1)
            return get_windows_directory_a((char*)buffer,
                size);
        else
            return get_windows_directory_w((wchar_t*)buffer,
                size);
    }

    export extern "C" bool __stdcall set_current_directory_a(const char* path_name);

    export extern "C" bool __stdcall set_current_directory_w(const wchar_t* path_name);

    export template<class character>
        inline bool set_current_directory(const character* path_name)
    {
        if (sizeof(character) == 1)
            return set_current_directory_a((const char*)path_name);
        else
            return set_current_directory_w((const wchar_t*)path_name);
    }

    export extern "C" uint __stdcall get_current_directory_a(uint length,
        char* buffer);

    export extern "C" uint __stdcall get_current_directory_w(uint length,
        wchar_t* buffer);

    export template<class character>
        inline uint get_current_directory(uint length,
            character* buffer)
    {
        if (sizeof(character) == 1)
            return get_current_directory_a(length,
                (char*)buffer);
        else
            return get_current_directory_w(length,
                (wchar_t*)buffer);
    }

    export extern "C" bool __stdcall create_directory_a(const char* path_name,
        const security_attributes * security);

    export extern "C" bool __stdcall create_directory_w(const char* path_name,
        const security_attributes * security);

    export template<class character>
        inline bool create_directory(const character* path_name,
            const security_attributes* security)
    {
        if (sizeof(character) == 1)
            return create_directory_a((const char*)path_name,
                security);
        else
            return create_directory_w((const wchar_t*)path_name,
                security);
    }

    export extern "C" bool __stdcall create_directory_extended_a(const char* template_directory,
        const char* new_directory,
        const security_attributes * security);

    export extern "C" bool __stdcall create_directory_extended_w(const wchar_t* template_directory,
        const wchar_t* new_directory,
        const security_attributes * security);

    export template<class character>
        inline bool create_directory_extended(const character* template_directory,
            const character* new_directory,
            const security_attributes* security)
    {
        if (sizeof(character) == 1)
            return create_directory_extended_a((const char*)template_directory,
                (const char*)new_directory,
                security);
        else
            return create_directory_extended_w((const wchar_t*)template_directory,
                (const wchar_t*)new_directory,
                security);
    }

    export extern "C" bool __stdcall remove_directory_a(const char* path_name);

    export extern "C" bool __stdcall remove_directory_w(const wchar_t* path_name);

    export template<class character>
        inline bool remove_directory(const character* path_name)
    {
        if (sizeof(character) == 1)
            return remove_directory_a((const char*)path_name);
        else
            return remove_directory_w((const wchar_t*)path_name);
    }

    export extern "C" uint __stdcall get_full_path_name_a(const char* file_name,
        uint size,
        char* buffer,
        char** part);

    export extern "C" uint __stdcall get_full_path_name_w(const wchar_t* file_name,
        uint size,
        wchar_t* buffer,
        wchar_t** part);

    export template<class character>
        inline uint get_full_path_name(const character* file_name,
            uint size,
            character* buffer,
            character** part)
    {
        if (sizeof(character) == 1)
            return get_full_path_name_a((const char*)file_name,
                size,
                (char*)buffer,
                (char**)part);
        else
            return get_full_path_name_w((const wchar_t*)file_name,
                size,
                (wchar_t*)buffer,
                (wchar_t**)part);
    }

    export extern "C" uint __stdcall get_temporary_path_a(uint size,
        char* buffer);

    export extern "C" uint __stdcall get_temporary_path_w(uint size,
        wchar_t* buffer);

    export template<class character>
        inline uint get_temporary_path(uint size,
            character* buffer)
    {
        if (sizeof(character) == 1)
            return get_temporary_path_a(size,
                (char*)buffer);
        else
            return get_temporary_path_w(size,
                (wchar_t*)buffer);
    }

    export extern "C" uint __stdcall get_temporary_file_name_a(const char* path_name,
        char* prefix,
        uint suffix,
        char* temporary);

    export extern "C" uint __stdcall get_temporary_file_name_w(const wchar_t* path_name,
        wchar_t* prefix,
        uint suffix,
        wchar_t* temporary);

    export template<class character>
        inline uint get_temporary_file_name(const character* path_name,
            character* prefix,
            uint suffix,
            character* temporary)
    {
        if (sizeof(character) == 1)
            return get_temporary_file_name_a((const char*)path_name,
                (char*)prefix,
                suffix,
                (char*)temporary);
        else
            return get_temporary_file_name_w((const wchar_t*)path_name,
                (wchar_t*)prefix,
                suffix,
                (wchar_t*)temporary);
    }

    export extern "C" uint __stdcall get_logical_drives();

    export extern "C" uint __stdcall get_logical_drive_strings_a(uint size,
        char* buffer);

    export extern "C" uint __stdcall get_logical_drive_strings_w(uint size,
        wchar_t* buffer);

    export template<class character>
        inline uint get_logical_drive_strings(uint size,
            character* buffer)
    {
        if (sizeof(character) == 1)
            return get_logical_drive_strings_a(size,
                (char*)buffer);
        else
            return get_logical_drive_strings_w(size,
                (wchar_t*)buffer);
    }

    export extern "C" uint __stdcall get_drive_type_a(const char* root);

    export extern "C" uint __stdcall get_drive_type_w(const wchar_t* root);

    export template<class character>
        inline uint get_drive_type(const character* root)
    {
        if (sizeof(character) == 1)
            return get_drive_type_a((const char*)root);
        else
            return get_drive_type_w((const wchar_t*)root);
    }

    export extern "C" bool __stdcall get_disk_free_space_a(const char* root,
        uint * sectors,
        uint * bytes,
        uint * free,
        uint * total);

    export extern "C" bool __stdcall get_disk_free_space_w(const wchar_t* root,
        uint * sectors,
        uint * bytes,
        uint * free,
        uint * total);

    export template<class character>
        inline bool  get_disk_free_space(const character* root,
            uint* sectors,
            uint* bytes,
            uint* free,
            uint* total)
    {
        if (sizeof(character) == 1)
            return get_disk_free_space_a((const char*)root,
                sectors,
                bytes,
                free,
                total);
        else
            return get_disk_free_space_w((const wchar_t*)root,
                sectors,
                bytes,
                free,
                total);
    }

    export extern "C" bool __stdcall get_disk_free_space_extended_a(const char* root,
        ulong * available,
        ulong * total,
        ulong * free);

    export extern "C" bool __stdcall get_disk_free_space_extended_w(const wchar_t* root,
        ulong * available,
        ulong * total,
        ulong * free);

    export template<class character>
        inline bool get_disk_free_space_extended(const character* root,
            ulong* available,
            ulong* total,
            ulong* free)
    {
        if (sizeof(character) == 1)
            return get_disk_free_space_extended_a((const char*)root,
                available,
                total,
                free);
        else
            return get_disk_free_space_extended_w((const wchar_t*)root,
                available,
                total,
                free);
    }

    export extern "C" handle __stdcall find_first_change_notification_a(const char* path_name,
        bool watch,
        uint filter);

    export extern "C" handle __stdcall find_first_change_notification_w(const wchar_t* path_name,
        bool watch,
        uint filter);

    export template<class character>
        inline handle find_first_change_notification(const character* path_name,
            bool watch,
            uint filter)
    {
        if (sizeof(character) == 1)
            return find_first_change_notification_a((const char*)path_name,
                watch,
                filter);
        else
            return find_first_change_notification_w((const wchar_t*)path_name,
                watch,
                filter);
    }

    export extern "C" bool __stdcall find_next_change_notification(handle change);

    export extern "C" bool __stdcall find_close_change_notification(handle change);

    //*** pipes

    export extern "C" handle __stdcall create_named_pipe_a(const char* name,
        uint open_mode,
        uint pipe_mode,
        uint maximum_instances,
        uint output_ssize,
        uint input_size,
        uint default_timeout,
        const security_attributes * security);

    export extern "C" handle __stdcall create_named_pipe_w(const wchar_t* name,
        uint open_mode,
        uint pipe_mode,
        uint maximum_instances,
        uint output_ssize,
        uint input_size,
        uint default_timeout,
        const security_attributes * security);

    export template<class character>
        inline handle create_named_pipe(const character* name,
            uint open_mode,
            uint pipe_mode,
            uint maximum_instances,
            uint output_ssize,
            uint input_size,
            uint default_timeout,
            const security_attributes* security)
    {
        if (sizeof(character) == 1)
            return create_named_pipe_a((const char*)name,
                open_mode,
                pipe_mode,
                maximum_instances,
                output_ssize,
                input_size,
                default_timeout,
                security);
        else
            return create_named_pipe_w((const wchar_t*)name,
                open_mode,
                pipe_mode,
                maximum_instances,
                output_ssize,
                input_size,
                default_timeout,
                security);
    }


    export extern "C" bool __stdcall connect_named_pipe(handle pipe,
        overlapped * overlappedconnect);

    export extern "C" bool __stdcall disconnect_named_pipe(handle pipe);

    export extern "C" bool __stdcall set_named_pipe_handle_state(handle pipe,
        uint * mode,
        uint * collection_maximum,
        uint * collection_timeout);

    export extern "C" bool __stdcall get_named_pipe_handle_state_a(handle pipe,
        uint * destination,
        uint * instances,
        uint * collection_maximum,
        uint * collection_timeout,
        char* user,
        uint user_name_size);

    export extern "C" bool __stdcall get_named_pipe_handle_state_w(handle pipe,
        uint * destination,
        uint * instances,
        uint * collection_maximum,
        uint * collection_timeout,
        wchar_t* user,
        uint user_name_size);

    export template<class character>
        inline bool get_named_pipe_handle_state(handle pipe,
            uint* destination,
            uint* instances,
            uint* collection_maximum,
            uint* collection_timeout,
            character* user,
            uint user_name_size)
    {
        if (sizeof(character) == 1)
            return get_named_pipe_handle_state_a(pipe,
                destination,
                instances,
                collection_maximum,
                collection_timeout,
                (char*)user,
                user_name_size);
        else
            return get_named_pipe_handle_state_w(pipe,
                destination,
                instances,
                collection_maximum,
                collection_timeout,
                (wchar_t*)user,
                user_name_size);
    }

    export extern "C" bool __stdcall get_named_pipe_information(handle pipe,
        uint * flags,
        uint * output_size,
        uint * input_size,
        uint * maximum_instances);

    export extern "C" bool __stdcall peek_named_pipe(handle pipe,
        void* buffer,
        uint size,
        uint * bytes_read,
        uint * bytes_available,
        uint * bytes_remaining);

    export extern "C" bool __stdcall transact_named_pipe(handle pipe,
        void* input_buffer,
        uint input_ssize,
        void* output_buffer,
        uint output_size,
        uint * bytes_read,
        overlapped * overlapped_transact);

    export extern "C" bool __stdcall impersonate_named_pipe_client(handle pipe);

    export extern "C" bool __stdcall call_named_pipe_a(const char* name,
        void* input_buffer,
        uint input_size,
        void* output_buffer,
        uint output_size,
        uint * read,
        uint timeout);

    export extern "C" bool __stdcall call_named_pipe_w(const wchar_t* name,
        void* input_buffer,
        uint input_size,
        void* output_buffer,
        uint output_size,
        uint * read,
        uint timeout);

    export template<class character>
        inline bool call_named_pipe(const character* name,
            void* input_buffer,
            uint input_size,
            void* output_buffer,
            uint output_size,
            uint* read,
            uint timeout)
    {
        if (sizeof(character) == 1)
            return call_named_pipe_a((const char*)name,
                input_buffer,
                input_size,
                output_buffer,
                output_size,
                read,
                timeout);
        else
            return call_named_pipe_w((const wchar_t*)name,
                input_buffer,
                input_size,
                output_buffer,
                output_size,
                read,
                timeout);
    }

    export extern "C" bool __stdcall wait_named_pipe_a(const char* name,
        uint timeout);

    export extern "C" bool __stdcall wait_named_pipe_w(const wchar_t* name,
        uint timeout);

    export template<class character>
        inline bool wait_named_pipe(const character* name,
            uint timeout)
    {
        if (sizeof(character) == 1)
            return wait_named_pipe_a((const char*)name,
                timeout);
        else
            return wait_named_pipe_w((const wchar_t*)name,
                timeout);
    }

    export extern "C" bool __stdcall get_named_pipe_client_computer_name_a(handle pipe,
        char* client_computer_name,
        uint client_computer_name_length);

    export extern "C" bool __stdcall get_named_pipe_client_computer_name_w(handle pipe,
        wchar_t* client_computer_name,
        uint client_computer_name_length);

    export template<class character>
        inline bool get_named_pipe_client_computer_name(handle pipe,
            character* client_computer_name,
            uint client_computer_name_length)
    {
        if (sizeof(character) == 1)
            return get_named_pipe_client_computer_name_a(pipe,
                (char*)client_computer_name,
                client_computer_name_length);
        else
            return get_named_pipe_client_computer_name_w(pipe,
                (wchar_t*)client_computer_name,
                client_computer_name_length);
    }

    export extern "C" bool __stdcall get_named_pipe_client_process_identity(handle pipe,
        uint * client_process_identity);

    export extern "C" bool __stdcall get_named_pipe_client_session_identity(handle pipe,
        uint * client_session_identity);

    export extern "C" bool __stdcall get_named_pipe_server_process_identity(handle pipe,
        uint * server_process_identity);

    export extern "C" bool __stdcall get_named_pipe_server_session_identity(handle pipe,
        uint * server_session_identity);

    export extern "C" bool __stdcall create_pipe(handle * read,
        handle * write,
        security_attributes * security,
        uint size);

    //*** system information

    export extern "C" void __stdcall get_19924rmation(system_information * information);

    //*** time

    export extern "C" void __stdcall get_system_time(system_time * time);

    export extern "C" bool __stdcall set_system_time(const system_time * time);

    export extern "C" void __stdcall get_local_time(system_time * time);

    export extern "C" bool __stdcall set_local_time(const system_time * time);

    export extern "C" uint __stdcall get_time_zone_information(time_zone_information * information);

    export extern "C" bool __stdcall set_time_zone_information(const time_zone_information * information);

    export extern "C" bool __stdcall system_time_to_file_time(const system_time * time_convert,
        file_time * time_out);

    export extern "C" bool __stdcall file_time_to_local_file_time(const file_time * time_convert,
        file_time * time_local);

    export extern "C" bool __stdcall local_file_time_to_file_time(const file_time * time_local,
        file_time * time_out);

    export extern "C" bool __stdcall file_time_to_system_time(const file_time * time_file,
        system_time * time_out);

    export extern "C" int __stdcall compare_file_time(const file_time * file_time_a,
        const file_time * file_time_b);

    export extern "C" bool __stdcall file_time_to_dos_date_time(const file_time * file_time_to_convert,
        part * file_allocation_table_date,
        part * file_allocation_table_time);

    export extern "C" bool __stdcall dos_date_time_to_file_time(part file_allocation_table_date,
        part file_allocation_table_time,
        file_time * file_time_converted);

    export extern "C" uint __stdcall get_tick_count();

    //*** threads

    export extern "C" handle __stdcall get_current_thread();

    export extern "C" handle __stdcall create_thread(security_attributes * security_thread,
        ulong stack_size,
        thread_function function_address,
        void* parameter_pointer,
        uint flags,
        uint * thread_identity);

    export extern "C" handle __stdcall create_remote_thread(handle process,
        security_attributes * security_thread,
        ulong stack_size,
        thread_function function_address,
        void* parameter_pointer,
        uint flags,
        uint * thread_identity);

    export extern "C" uint __stdcall get_current_thread_identity();

    export extern "C" handle __stdcall get_current_thread_token();

    export extern "C" bool __stdcall set_thread_priority(handle thread,
        int priority);

    export extern "C" int __stdcall get_thread_priority(handle thread);

    export extern "C" bool __stdcall get_thread_times(handle thread,
        file_time * create,
        file_time * exit,
        file_time * kernel,
        file_time * user);

    export extern "C" bool __stdcall terminate_thread(handle thread,
        uint exit_code);

    export extern "C" bool __stdcall get_thread_exit_code(handle thread,
        uint * exit_code);

    export extern "C" bool __stdcall get_thread_selector_entry(handle thread,
        uint selector,
        void* selector_entry);

    export extern "C" bool __stdcall get_thread_context(handle thread,
        context * thread_context);

    export extern "C" bool __stdcall set_thread_context(handle thread,
        const context * thread_context);

    export extern "C" uint __stdcall suspend_thread(handle thread);

    export extern "C" uint __stdcall resume_thread(handle thread);

    export extern "C" void __stdcall exit_thread(uint exit_code);

    export extern "C" uint __stdcall queue_asynchronous_procedure_call(asynchronous_procedure procedure,
        handle thread,
        void* data);

    //*** fibers

    export extern "C" void* __stdcall create_fiber(ulong stack_size,
        fiber_function start_address,
        void* parameter);

    export extern "C" void* __stdcall create_fiber_extended(ulong stack_commit_size,
        ulong stack_reserve_size,
        uint flags,
        fiber_function start_address,
        void* parameter);

    export extern "C" void __stdcall delete_fiber(void* fiber);

    export extern "C" void* __stdcall convert_thread_to_fiber(void* parameter);

    export extern "C" void* __stdcall convert_thread_to_fiber_extended(void* parameter,
        uint flags);

    export extern "C" bool __stdcall convert_fiber_to_thread(void);

    export extern "C" bool __stdcall is_thread_a_fiber(void);

    export extern "C" void __stdcall switch_to_fiber(void* fiber);

    export extern "C" bool __stdcall switch_to_thread(void);

    //*** processes

    export extern "C" uint __stdcall get__resources(handle process,
        uint flags);

    export extern "C" bool __stdcall set_priority_class(handle process,
        uint priority);

    export extern "C" uint __stdcall get_priority_class(handle process);

    export extern "C" void __stdcall get_startup_information_a(start_information<char> *information);

    export extern "C" void __stdcall get_startup_information_w(start_information<wchar_t> *information);

    export template<class character>
        inline void  get_startup_information(start_information<character>* information)
    {
        if (sizeof(character) == 1)
            get_startup_information_a((start_information<char>*)information);
        else
            get_startup_information_w((start_information<wchar_t>*)information);
    }

    export extern "C" handle __stdcall get_current_process();

    export extern "C" handle __stdcall open_process(uint access,
        bool inherit,
        uint identity);

    export extern "C" bool __stdcall create_process_a(const char* application_name,
        const char* command,
        security_attributes * process_security,
        security_attributes * thread_security,
        bool inherit_handles,
        uint creation_flags,
        void* environment,
        const char* current_directory,
        start_information<char>*start_information_pointer,
        process_information * process_information_pointer);

    export extern "C" bool __stdcall create_process_w(const wchar_t* application_name,
        const wchar_t* command,
        security_attributes * process_security,
        security_attributes * thread_security,
        bool inherit_handles,
        uint creation_flags,
        void* environment,
        const wchar_t* current_directory,
        start_information<wchar_t>*start_information_pointer,
        process_information * process_information_pointer);

    export template<class character>
        inline bool create_process(const character* application_name,
            const character* command,
            security_attributes* process_security,
            security_attributes* thread_security,
            bool inherit_handles,
            uint creation_flags,
            void* environment,
            const character* current_directory,
            start_information<character>* start_information_pointer,
            process_information* process_information_pointer)
    {
        if (sizeof(character) == 1)
            return create_process_a(application_name,
                command,
                process_security,
                thread_security,
                inherit_handles,
                creation_flags,
                environment,
                (const char*)current_directory,
                start_information_pointer,
                process_information_pointer);
        else
            return create_process_w(application_name,
                command,
                process_security,
                thread_security,
                inherit_handles,
                creation_flags,
                environment,
                (const wchar_t*)current_directory,
                start_information_pointer,
                process_information_pointer);
    }

    export extern "C" bool __stdcall impersonate_logged_on_user(handle token);

    export extern "C" bool __stdcall create_process_as_user_a(handle token,
        const char* application_name,
        const char* command,
        security_attributes * process_security,
        security_attributes * thread_security,
        bool inherit_handles,
        uint creation_flags,
        void* environment,
        const char* current_directory,
        start_information<char>*start_information_pointer,
        process_information * process_information_pointer);

    export extern "C" bool __stdcall create_process_as_user_w(handle token,
        const wchar_t* application_name,
        const wchar_t* command,
        security_attributes * process_security,
        security_attributes * thread_security,
        bool inherit_handles,
        uint creation_flags,
        void* environment,
        const wchar_t* current_directory,
        start_information<wchar_t> *start_information_pointer,
        process_information * process_information_pointer);

    export template<class character>
        inline bool create_process_as_user(handle token,
            const character* application_name,
            const character* command,
            security_attributes* process_security,
            security_attributes* thread_security,
            bool inherit_handles,
            uint creation_flags,
            void* environment,
            const character* current_directory,
            start_information<character>* start_information_pointer,
            process_information* process_information_pointer)
    {
        if (sizeof(character) == 1)
            return create_process_as_user_a(token,
                (const char*)application_name,
                (const char*)command,
                process_security,
                thread_security,
                inherit_handles,
                creation_flags,
                environment,
                current_directory,
                (start_information<char>*)start_information_pointer,
                process_information_pointer);
        else
            return create_process_as_user_w(token,
                (const wchar_t*)application_name,
                (const wchar_t*)command,
                process_security,
                thread_security,
                inherit_handles,
                creation_flags,
                environment,
                current_directory,
                (start_information<wchar_t>*)start_information_pointer,
                process_information_pointer);

    }

    export extern "C" bool __stdcall get_process_working_set_size(handle process,
        ulong * working_set_minimum,
        ulong * working_set_maximum);

    export extern "C" bool __stdcall get_process_working_set_size_extended(handle process,
        ulong * working_set_minimum,
        ulong * working_set_maximum,
        uint * flags);

    export extern "C" bool __stdcall set_process_working_set_size(handle process,
        ulong working_set_minimum,
        ulong working_set_maximum);

    export extern "C" bool __stdcall set_process_working_set_size_extended(handle process,
        ulong working_set_minimum,
        ulong working_set_maximum,
        uint flags);

    export extern "C" handle __stdcall load_module(const character * module_name,
        void* load_parameters);

    export extern "C" bool __stdcall terminate_process(handle process,
        uint exit_code);

    export extern "C" bool __stdcall get_process_exit_code(handle process,
        uint * exit_code);

    export extern "C" bool __stdcall get_process_times(handle process,
        file_time * create,
        file_time * exit,
        file_time * kernel,
        file_time * user);

    export extern "C" bool __stdcall read_process_memory(handle process,
        const void* address,
        void* buffer,
        ulong size,
        ulong * transferred);

    export extern "C" bool __stdcall write_process_memory(handle process,
        void* address,
        void* buffer,
        ulong size,
        ulong * written);

    export extern "C" bool __stdcall set_system_file_cache_size(ulong minimum_file_cache_size,
        ulong maximum_file_cache_size,
        uint flags);

    export extern "C" bool __stdcall get_system_file_cache_size(ulong * minimum_file_cache_size,
        ulong * maximum_file_cache_size,
        uint * flags);

    export extern "C" bool __stdcall flush_instruction_cache(handle process,
        const void* address,
        ulong size);

    export extern "C" bool __stdcall set_process_shutdown_parameters(uint level,
        uint flags);

    export extern "C" bool __stdcall get_process_shutdown_parameters(uint * level,
        uint * flags);

    export extern "C" handle __stdcall get_process_heap();

    export extern "C" uint __stdcall get_current_process_identity();

    export extern "C" void __stdcall exit_process(uint exit_code);

    export extern "C" void __stdcall fatal_application_exit_a(uint action,
        const char* message_text);

    export extern "C" void __stdcall fatal_application_exit_w(uint action,
        const wchar_t* message_text);

    export template<class character>
        inline void fatal_application_exit(uint action,
            const character* message_text)
    {
        if (sizeof(character) == 1)
            fatal_application_exit_a(action,
                (const char*)message_text);
        else
            fatal_application_exit_w(action,
                (const wchar_t*)message_text);
    }

    export extern "C" void __stdcall fatal_exit(uint exit_code);

    export extern "C" const char* __stdcall get_command_line_a();

    export extern "C" const wchar_t* __stdcall get_command_line_w();

    export  inline const character* get_command_line()
    {
        return get_command_line_w();
    }

    export extern "C" char* __stdcall get_environment_strings_a();

    export extern "C" wchar_t* __stdcall get_environment_strings_w();

    export  inline character* get_environment_strings()
    {
        return (character*)get_environment_strings_w();
    }

    export extern "C" bool __stdcall free_environment_strings_a(const char* environment);

    export extern "C" bool __stdcall free_environment_strings_w(const wchar_t* environment);

    export template<class character>
        inline bool free_environment_strings(character* environment)
    {
        if (sizeof(character) == 1)
            return free_environment_strings_a((const char*)environment);
        else
            return free_environment_strings_w((const wchar_t*)environment);
    }

    export extern "C" uint __stdcall get_environment_variable_a(const char* name,
        char* buffer,
        uint size);

    export extern "C" uint __stdcall get_environment_variable_w(const wchar_t* name,
        wchar_t* buffer,
        uint size);

    export template<class character>
        inline uint get_environment_variable(const character* name,
            character* buffer,
            uint size)
    {
        if (sizeof(character) == 1)
            return get_environment_variable_a((const char*)name,
                (char*)buffer,
                size);
        else
            return get_environment_variable_w((const wchar_t*)name,
                (wchar_t*)buffer,
                size);
    }

    export extern "C" bool __stdcall set_environment_variable_a(const char* name,
        const char* value);

    export extern "C" bool __stdcall set_environment_variable_w(const wchar_t* name,
        const wchar_t value);

    export template<class character>
        inline bool set_environment_variable(const character* name,
            const character* value)
    {
        if (sizeof(character) == 1)
            return set_environment_variable_a((const char*)name,
                (const char*)value);
        else
            return set_environment_variable_w((const wchar_t*)name,
                (const wchar_t*)value);
    }

    export extern "C" uint __stdcall expand_environment_strings_a(const char* source,
        char* destination,
        uint size);

    export extern "C" uint __stdcall expand_environment_strings_w(const wchar_t* source,
        wchar_t* destination,
        uint size);

    export template<class character>
        inline uint expand_environment_strings(const character* source,
            character* destination,
            uint size)
    {
        if (sizeof(character) == 1)
            return expand_environment_strings_a((const char*)source,
                (char*)destination,
                size);
        else
            return expand_environment_strings_w((const wchar_t*)source,
                (wchar_t*)destination,
                size);
    }

    //*** modules

    export extern "C" handle __stdcall get_module_handle_a(const char* module_name);

    export extern "C" handle __stdcall get_module_handle_w(const wchar_t* module_name);

    export template<class character>
        inline handle get_module_handle(const character* module_name = 0)
    {
        if (sizeof(character) == 1)
            return get_module_handle_a((const char*)module_name);
        else
            return get_module_handle_w((const wchar_t*)module_name);
    }

    export extern "C" uint __stdcall get_module_file_name_a(handle module,
        char* file_name,
        uint size);

    export extern "C" uint __stdcall get_module_file_name_w(handle module,
        wchar_t* file_name,
        uint size);

    export template<class character>
        inline uint get_module_file_name(handle module,
            character* file_name,
            uint size)
    {
        if (sizeof(character) == 1)
            return get_module_file_name_a(module,
                (char*)file_name,
                size);
        else
            return get_module_file_name_w(module,
                (wchar_t*)file_name,
                size);
    }

    export extern "C" handle __stdcall load_library_a(const char* file_name);

    export extern "C" handle __stdcall load_library_w(const wchar_t* file_name);

    export template<class character>
        inline handle load_library(const character* file_name)
    {
        if (sizeof(character) == 1)
            return load_library_a((const char*)file_name);
        else
            return load_library_w((const wchar_t*)file_name);
    }

    export extern "C" handle __stdcall load_library_extended_a(const char* file_name,
        handle file,
        uint flags);

    export extern "C" handle __stdcall load_library_extended_w(const wchar_t* file_name,
        handle file,
        uint flags);

    export template<class character>
        inline handle load_library_extended(const character* file_name,
            handle file,
            uint flags)
    {
        if (sizeof(character) == 1)
            return load_library_extended_a((const char*)file_name,
                file,
                flags);
        else
            return load_library_extended_w((const wchar_t*)file_name,
                file,
                flags);
    }

    export extern "C" bool __stdcall free_library(handle library);

    export extern "C" function_type __stdcall get_procedure_address(handle module,
        const wchar_t* name);

    export extern "C" uint __stdcall size_of_resource(handle module,
        handle resource);

    export extern "C" handle __stdcall find_resource_a(handle module,
        const char* name,
        const char* type);

    export extern "C" handle __stdcall find_resource_w(handle module,
        const wchar_t* name,
        const wchar_t* type);

    export template<class character>
        inline handle find_resource(handle module,
            const character* name,
            const character* type)
    {
        if (sizeof(character) == 1)
            return find_resource_a(module,
                (const char*)name,
                (const char*)type);
        else
            return find_resource_w(module,
                (const wchar_t*)name,
                (const wchar_t*)type);
    }

    export extern "C" handle __stdcall find_resource_extended_a(handle module,
        const char* type,
        const char* name,
        part language);

    export extern "C" handle __stdcall find_resource_extended_w(handle module,
        const wchar_t* type,
        const wchar_t* name,
        part language);

    export template<class character>
        inline handle find_resource_extended(handle module,
            const character* type,
            const character* name,
            part language)
    {
        if (sizeof(character) == 1)
            return find_resource_extended_a(module,
                (const char*)type,
                (const char*)name,
                language);
        else
            return find_resource_extended_w(module,
                (const wchar_t*)type,
                (const wchar_t*)name,
                language);
    }

    export extern "C" bool __stdcall enumerate_resource_types(handle module,
        resource_type_callback callback,
        void* parameter);

    export extern "C" bool __stdcall enumerate_resource_names_a(handle module,
        const char* type,
        resource_name_callback callback,
        void* parameter);

    export extern "C" bool __stdcall enumerate_resource_names_w(handle module,
        const wchar_t* type,
        resource_name_callback callback,
        void* parameter);

    export template<class character>
        inline bool enumerate_resource_names(handle module,
            const character* type,
            resource_name_callback callback,
            void* parameter)
    {
        if (sizeof(character) == 1)
            return enumerate_resource_names_a(module,
                (const char*)type,
                callback,
                parameter);
        else
            return enumerate_resource_names_w(module,
                (const wchar_t*)type,
                callback,
                parameter);
    }

    export extern "C" bool __stdcall enumerate_resource_languages_a(handle module,
        const char* type,
        const char* name,
        resource_language_callback callback,
        void* parameter);

    export extern "C" bool __stdcall enumerate_resource_languages_w(handle module,
        const wchar_t* type,
        const wchar_t* name,
        resource_language_callback callback,
        void* parameter);

    export template<class character>
        inline bool enumerate_resource_languages(handle module,
            const character* type,
            const character* name,
            resource_language_callback callback,
            void* parameter)
    {
        if (sizeof(character) == 1)
            return enumerate_resource_languages_a(module,
                (const char*)type,
                (const char*)name,
                callback,
                parameter);
        else
            return enumerate_resource_languages_w(module,
                (const wchar_t*)type,
                (const wchar_t*)name,
                callback,
                parameter);
    }

    //*** resources

    export  enum resource_flags { resource_flag_none = 0, resource_flag_discard = 2 };

    export extern "C" handle __stdcall begin_update_resource_a(const char* file_name,
        bool delete_existing);

    export extern "C" handle __stdcall begin_update_resource_w(const wchar_t* file_name,
        bool delete_existing);

    export template<class character>
        inline handle begin_update_resource(const character* file_name,
            bool delete_existing)
    {
        if (sizeof(character) == 1)
            return begin_update_resource_a((const char*)file_name,
                delete_existing);
        else
            return begin_update_resource_w((const wchar_t*)file_name,
                delete_existing);
    }

    export extern "C" bool __stdcall update_resource_a(handle update,
        const char* type,
        const char* name,
        part language,
        const void* data,
        uint size);

    export extern "C" bool __stdcall update_resource_w(handle update,
        const wchar_t* type,
        const wchar_t* name,
        part language,
        const void* data,
        uint size);

    export template<class character>
        inline bool update_resource(handle update,
            const character* type,
            const character* name,
            part language,
            const void* data,
            uint size)
    {
        if (sizeof(character) == 1)
            return update_resource_a(update,
                (const char*)type,
                (const char*)name,
                language,
                data,
                size);
        else
            return update_resource_w(update,
                (const wchar_t*)type,
                (const wchar_t*)name,
                language,
                data,
                size);
    }

    export extern "C" bool __stdcall end_update_resource_a(handle update,
        bool discard);

    export extern "C" bool __stdcall end_update_resource_w(handle update,
        bool discard);

    export extern "C" inline bool end_update_resource(handle update,
        bool discard)
    {
        return end_update_resource_w(update,
            discard);
    }

    //*** debugging

    export extern "C" void __stdcall set_debug_error_level(uint level);

    export extern "C" void __stdcall debug_break();

    export extern "C" bool __stdcall wait_for_debug_event(debug_event<character> *event,
        uint milliseconds);

    export extern "C" bool __stdcall continue_debug_event(uint process,
        uint thread,
        uint status);

    export extern "C" bool __stdcall debug_active_process(uint process);

    export extern "C" void __stdcall output_debug_string_a(const char* string);

    export extern "C" void __stdcall output_debug_string_w(const wchar_t* string);

    export template<class character>
        inline void output_debug_string(const character* string)
    {
        if (sizeof(character) == 1)
            output_debug_string_a((const char*)string);
        else
            output_debug_string_w((const wchar_t*)string);
    }

    //*** atoms

    export extern "C" atom __stdcall delete_global_atom(atom atom_to_delete);

    export extern "C" bool __stdcall initialize_atom_table(uint size);

    export extern "C" atom __stdcall delete_atom(atom atom_to_delete);

    export extern "C" atom __stdcall add_global_atom_a(const char* string);

    export extern "C" atom __stdcall add_global_atom_w(const wchar_t* string);

    export template<class character>
        inline atom add_global_atom(const character* string)
    {
        if (sizeof(character) == 1)
            return add_global_atom_a((const char*)string);
        else
            return add_global_atom_w((const wchar_t*)string);
    }

    export extern "C" atom __stdcall find_global_atom_a(const char* string);

    export extern "C" atom __stdcall find_global_atom_w(const wchar_t* string);

    export template<class character>
        inline atom find_global_atom(const character* string)
    {
        if (sizeof(character) == 1)
            return find_global_atom_a((const char*)string);
        else
            return find_global_atom_w((const wchar_t*)string);
    }

    export extern "C" uint __stdcall get_global_atom_name_a(atom atom_to_get,
        char* buffer,
        int size);

    export extern "C" uint __stdcall get_global_atom_name_w(atom atom_to_get,
        wchar_t* buffer,
        int size);

    export template<class character>
        inline uint get_global_atom_name(atom atom_to_get,
            character* buffer,
            int size)
    {
        if (sizeof(character) == 1)
            return get_global_atom_name_a(atom_to_get,
                (char*)buffer,
                size);
        else
            return get_global_atom_name_w(atom_to_get,
                (wchar_t*)buffer,
                size);
    }

    export extern "C" atom __stdcall add_atom_a(const char* string);

    export extern "C" atom __stdcall add_atom_w(const wchar_t* string);

    export template<class character>
        inline atom add_atom(const character* string)
    {
        if (sizeof(character) == 1)
            return add_atom_a((const char*)string);
        else
            return add_atom_a((const wchar_t*)string);
    }

    export extern "C" atom __stdcall find_atom_a(const char* string);

    export extern "C" atom __stdcall find_atom_w(const wchar_t* string);

    export template<class character>
        inline atom find_atom(const character* string)
    {
        if (sizeof(character) == 1)
            return find_atom_a((const char*)string);
        else
            return find_atom_w((const wchar_t*)string);
    }

    export extern "C" uint __stdcall get_atom_name_a(atom atom_to_get,
        char* buffer,
        int size);

    export extern "C" uint __stdcall get_atom_name_w(atom atom_to_get,
        wchar_t* buffer,
        int size);

    export template<class character>
        inline uint get_atom_name(atom atom_to_get,
            character* buffer,
            int size)
    {
        if (sizeof(character) == 1)
            return get_atom_name_a(atom_to_get,
                (char*)buffer,
                size);
        else
            return get_atom_name_w(atom_to_get,
                buffer,
                (wchar_t*)size);
    }

    //*** profiles

    export extern "C" uint __stdcall get_profile_integer_a(const char* section,
        const char* key_name,
        int default_value);

    export extern "C" uint __stdcall get_profile_integer_w(const wchar_t* section,
        const wchar_t* key_name,
        int default_value);

    export template<class character>
        inline uint get_profile_integer(const character* section,
            const character* key_name,
            int default_value)
    {
        if (sizeof(character) == 1)
            return get_profile_integer_a((const char*)section,
                (const char*)key_name,
                default_value);
        else
            return get_profile_integer_w((const wchar_t*)section,
                (const wchar_t*)key_name,
                default_value);
    }

    export extern "C" uint __stdcall get_profile_string_a(const char* section,
        const char* key_name,
        const char* default_value,
        char* string,
        uint size);

    export extern "C" uint __stdcall get_profile_string_w(const wchar_t* section,
        const wchar_t* key_name,
        const wchar_t* default_value,
        wchar_t* string,
        uint size);

    export template<class character>
        inline uint get_profile_string(const character* section,
            const character* key_name,
            const character* default_value,
            character* string,
            uint size)
    {
        if (sizeof(character) == 1)
            return get_profile_string_a((const char*)section,
                (const char*)key_name,
                (const char*)default_value,
                (char*)string,
                size);
        else
            return get_profile_string_w((const wchar_t*)section,
                (const wchar_t*)key_name,
                (const wchar_t*)default_value,
                (wchar_t*)string,
                size);
    }

    export extern "C" bool __stdcall write_profile_string_a(const char* section,
        const char* key_name,
        const char* string);

    export extern "C" bool __stdcall write_profile_string_w(const wchar_t* section,
        const wchar_t* key_name,
        const wchar_t* string);

    export template<class character>
        inline bool write_profile_string(const character* section,
            const character* key_name,
            const character* string)
    {
        if (sizeof(character) == 1)
            return write_profile_string_a((const char*)section,
                (const char*)key_name,
                (const char*)string);
        else
            return write_profile_string_w((const wchar_t*)section,
                (const wchar_t*)key_name,
                (const wchar_t*)string);
    }

    export extern "C" uint __stdcall get_profile_section_a(const char* section,
        char* string,
        uint size);

    export extern "C" uint __stdcall get_profile_section_w(const wchar_t* section,
        wchar_t* string,
        uint size);

    export template<class character>
        inline uint get_profile_section(const character* section,
            character* string,
            uint size)
    {
        if (sizeof(character) == 1)
            return get_profile_section_a((const char*)section,
                (char*)string,
                size);
        else
            return get_profile_section_w((const wchar_t*)section,
                (wchar_t*)string,
                size);
    }

    export extern "C" bool __stdcall write_profile_section_a(const char* section,
        const char* string);

    export extern "C" bool __stdcall write_profile_section_w(const wchar_t* section,
        const wchar_t* string);

    export template<class character>
        inline bool write_profile_section(const character* section,
            const character* string)
    {
        if (sizeof(character) == 1)
            return write_profile_section_a((const char*)section,
                (const char*)string);
        else
            return write_profile_section_w((const wchar_t*)section,
                (const wchar_t*)string);
    }

    export extern "C" uint __stdcall get_private_profile_integer_a(const char* section,
        const char* key_name,
        int default_value,
        const char* file_name);

    export extern "C" uint __stdcall get_private_profile_integer_w(const wchar_t* section,
        const wchar_t* key_name,
        int default_value,
        const wchar_t* file_name);

    export template<class character>
        inline uint get_private_profile_integer(const character* section,
            const character* key_name,
            int default_value,
            const character* file_name)
    {
        if (sizeof(character) == 1)
            return get_private_profile_integer_a((const char*)section,
                (const char*)key_name,
                default_value,
                (const char*)file_name);
        else
            return get_private_profile_integer_w((const wchar_t*)section,
                (const wchar_t*)key_name,
                default_value,
                (const wchar_t*)file_name);
    }

    export extern "C" uint __stdcall get_private_profile_string_a(const char* section,
        const char* key_name,
        const char* default_value,
        char* string,
        uint size,
        const char* file_name);

    export extern "C" uint __stdcall get_private_profile_string_w(const wchar_t* section,
        const wchar_t* key_name,
        const wchar_t* default_value,
        wchar_t* string,
        uint size,
        const wchar_t* file_name);

    export template<class character>
        inline uint get_private_profile_string(const character* section,
            const character* key_name,
            const character* default_value,
            character* string,
            uint size,
            const character* file_name)
    {
        if (sizeof(character) == 1)
            return get_private_profile_string_a((const char*)section,
                (const char*)key_name,
                (const char*)default_value,
                (char*)string,
                size,
                (const char*)file_name);
        else
            return get_private_profile_string_w((const wchar_t*)section,
                (const wchar_t*)key_name,
                (const wchar_t*)default_value,
                (wchar_t*)string,
                size,
                (const wchar_t*)file_name);
    }

    export extern "C" bool __stdcall write_private_profile_string_a(const char* section,
        const char* key_name,
        const char* string,
        const char* file_name);

    export extern "C" bool __stdcall write_private_profile_string_w(const wchar_t* section,
        const wchar_t* key_name,
        const wchar_t* string,
        const wchar_t* file_name);

    export template<class character>
        inline bool write_private_profile_string(const character* section,
            const character* key_name,
            const character* string,
            const character* file_name)
    {
        if (sizeof(character) == 1)
            return write_private_profile_string_a((const char*)section,
                (const char*)key_name,
                (const char*)string,
                (const char*)file_name);
        else
            return write_private_profile_string_w((const wchar_t*)section,
                (const wchar_t*)key_name,
                (const wchar_t*)string,
                (const wchar_t*)file_name);
    }

    export extern "C" uint __stdcall get_private_profile_section_a(const char* section,
        char* string,
        uint size,
        const char* file_name);

    export extern "C" uint __stdcall get_private_profile_section_w(const wchar_t* section,
        wchar_t* string,
        uint size,
        const wchar_t* file_name);

    export template<class character>
        inline uint get_private_profile_section(const character* section,
            character* string,
            uint size,
            const character* file_name)
    {
        if (sizeof(character) == 1)
            return get_private_profile_section_a((const char*)section,
                (char*)string,
                size,
                (const char*)file_name);
        else
            return get_private_profile_section_w((const wchar_t*)section,
                (wchar_t*)string,
                size,
                (const wchar_t*)file_name);
    }

    export extern "C" bool __stdcall write_private_profile_section_a(const char* section,
        const char* string,
        const char* file_name);

    export extern "C" bool __stdcall write_private_profile_section_w(const wchar_t* section,
        const wchar_t* string,
        const wchar_t* file_name);

    export template<class character>
        inline bool write_private_profile_section(const character* section,
            const character* string,
            const character* file_name)
    {
        if (sizeof(character) == 1)
            return write_private_profile_section_a((const char*)section,
                (const char*)string,
                (const char*)file_name);
        else
            return write_private_profile_section_w((const wchar_t*)section,
                (const wchar_t*)string,
                (const wchar_t*)file_name);
    }

    //*** communications

    export extern "C" bool __stdcall build_communications_data_control_block_a(const char* control,
        data_control_block<char>*control_block);

    export extern "C" bool __stdcall build_communications_data_control_block_w(const wchar_t* control,
        data_control_block<wchar_t>*control_block);

    export template<class character>
        inline bool build_communications_data_control_block(const character* control,
            data_control_block<character>* control_block)
    {
        if (sizeof(character) == 1)
            return build_communications_data_control_block_a((const char*)control,
                (data_control_block<char>*)control_block);
        else
            return build_communications_data_control_block_w((const wchar_t*)control,
                (data_control_block<wchar_t>*)control_block);
    }

    export extern "C" bool __stdcall build_communications_data_control_block_and_timeouts_a(const char* control,
        data_control_block<char>*control_block,
        const communications_timeouts * timeouts);

    export extern "C" bool __stdcall build_communications_data_control_block_and_timeouts_w(const wchar_t* control,
        data_control_block<wchar_t> *control_block,
        const communications_timeouts * timeouts);

    export template<class character>
        inline bool build_communications_data_control_block_and_timeouts(const character* control,
            data_control_block<character>* control_block,
            const communications_timeouts* timeouts)
    {
        if (sizeof(character) == 1)
            return build_communications_data_control_block_and_timeouts_a((const char*)control,
                (data_control_block<char>*)control_block,
                timeouts);
        else
            return build_communications_data_control_block_and_timeouts_w((const wchar_t*)control,
                (data_control_block<wchar_t>*)control_block,
                timeouts);
    }

    export extern "C" bool __stdcall clear_communications_break(handle file);

    export extern "C" bool __stdcall clear_communications_error(handle file,
        uint * errors,
        communications_statistics * statistics);

    export extern "C" bool __stdcall setup_communications(handle file,
        uint queue_in,
        uint queue_out);

    export extern "C" bool __stdcall escape_communications_function(handle file,
        uint function);

    export extern "C" bool __stdcall get_communications_mask(handle file,
        uint * event_mask);

    export extern "C" bool __stdcall get_communications_properties(handle file,
        communications_properties * properties);

    export extern "C" bool __stdcall get_modem_status(handle file,
        uint * modem_status);

    export extern "C" bool __stdcall get_communications_state_a(handle file,
        data_control_block<char>*data_control_block_get);

    export extern "C" bool __stdcall get_communications_state_w(handle file,
        data_control_block<wchar_t>*data_control_block_get);

    export template<class character>
        inline bool get_communications_state(handle file,
            data_control_block<character>* data_control_block_get)
    {
        if (sizeof(character) == 1)
            return get_communications_state_a(file,
                (data_control_block<char>*)data_control_block_get);
        else
            return get_communications_state_w(file,
                (data_control_block<wchar_t>*)data_control_block_get);
    }

    export extern "C" bool __stdcall get_communications_timeouts(handle file,
        communications_timeouts * timeouts);

    export extern "C" bool __stdcall purge_communications(handle file,
        uint flags);

    export extern "C" bool __stdcall set_communications_break(handle file);

    export extern "C" bool __stdcall set_communications_mask(handle file,
        uint event_mask);

    export extern "C" bool __stdcall set_communications_state_a(handle file,
        const data_control_block<char>*data);

    export extern "C" bool __stdcall set_communications_state_w(handle file,
        const data_control_block<wchar_t>*data);

    export template<class character>
        inline bool set_communications_state(handle file,
            const data_control_block<character>* data)
    {
        if (sizeof(character) == 1)
            return set_communications_state_a(file,
                (data_control_block<char>*)data);
        else
            return set_communications_state_w(file,
                (data_control_block<wchar_t>*)data);
    }

    export extern "C" bool __stdcall set_communications_timeouts(handle file,
        const communications_timeouts * timeouts);

    export extern "C" bool __stdcall transmit_communications_character_a(handle file,
        char transmit);

    export extern "C" bool __stdcall transmit_communications_character_w(handle file,
        wchar_t transmit);

    export template<class character>
        inline bool transmit_communications_character(handle file,
            character transmit)
    {
        if (sizeof(character) == 1)
            return transmit_communications_character_a(file,
                transmit);
        else
            return transmit_communications_character_w(file,
                transmit);
    }

    export extern "C" bool __stdcall wait_communications_event(handle file,
        uint * event_mask,
        overlapped * overlapped_event);

    //*** tapes

    export extern "C" uint __stdcall set_tape_position(handle file,
        uint method,
        uint partition,
        uint offset_low,
        uint offset_high,
        bool immediate);

    export extern "C" uint __stdcall get_tape_position(handle file,
        uint type,
        uint * partition,
        uint * offset_low,
        uint * offset_high);

    export extern "C" uint __stdcall prepare_tape(handle file,
        uint operation,
        bool immediate);

    export extern "C" uint __stdcall erase_tape(handle file,
        uint type,
        bool immediate);

    export extern "C" uint __stdcall create_tape_partition(handle file,
        uint method,
        uint count,
        uint size);

    export extern "C" uint __stdcall write_tape_mark(handle file,
        uint type,
        uint count,
        bool immediate);

    export extern "C" uint __stdcall get_tape_status(handle file);

    export extern "C" uint __stdcall get_tape_parameters(handle file,
        uint operation,
        uint * size,
        void* tape_information);

    export extern "C"  uint __stdcall set_tape_parameters(handle file,
        uint operation,
        void* tape_information);

    //*** sound

    export extern "C" bool __stdcall beep(uint frequency,
        uint duration);

    export extern "C" int __stdcall multiply_divide(int value,
        int numerator,
        int denominator);

    //*** mail slots

    export extern "C" handle __stdcall create_mailslot_a(const char* name,
        uint maximum_message_size,
        uint read_timeout,
        security_attributes * security);

    export extern "C" handle __stdcall create_mailslot_w(const wchar_t* name,
        uint maximum_message_size,
        uint read_timeout,
        security_attributes * security);

    export template<class character>
        inline handle create_mailslot(const character* name,
            uint maximum_message_size,
            uint read_timeout,
            security_attributes* security)
    {
        if (sizeof(character) == 1)
            return create_mailslot_a((const char*)name,
                maximum_message_size,
                read_timeout,
                security);
        else
            return create_mailslot_w((const wchar_t*)name,
                maximum_message_size,
                read_timeout,
                security);
    }

    export extern "C" bool __stdcall get_mailslot_information(handle mailslot,
        uint * maximum_message_size,
        uint * next_size,
        uint * message_count,
        uint * read_timeout);

    export extern "C" bool __stdcall set_mailslot_information(handle mailslot,
        uint read_timeout);

    //*** file mappings

    export extern "C" handle __stdcall create_file_mapping_a(handle file,
        security_attributes * security_mapping,
        uint protection,
        uint maximum_size_high,
        uint maximum_size_low,
        const char* name);

    export extern "C" handle __stdcall create_file_mapping_w(handle file,
        security_attributes * security_mapping,
        uint protection,
        uint maximum_size_high,
        uint maximum_size_low,
        const wchar_t* name);

    export template<class character>
        inline handle create_file_mapping(handle file,
            security_attributes* security_mapping,
            uint protection,
            uint maximum_size_high,
            uint maximum_size_low,
            const character* name)
    {
        if (sizeof(character) == 1)
            return create_file_mapping_a(file,
                security_mapping,
                protection,
                maximum_size_high,
                maximum_size_low,
                (const char*)name);
        else
            return create_file_mapping_w(file,
                security_mapping,
                protection,
                maximum_size_high,
                maximum_size_low,
                (const wchar_t*)name);
    }

    export extern "C" handle __stdcall open_file_mapping_a(uint access,
        bool inherit,
        const char* name);

    export extern "C" handle __stdcall open_file_mapping_w(uint access,
        bool inherit,
        const wchar_t* name);

    export template<class character>
        inline handle open_file_mapping(uint access,
            bool inherit,
            const character* name)
    {
        if (sizeof(character) == 1)
            return open_file_mapping_a(access,
                inherit,
                (const char*)name);
        else
            return open_file_mapping_w(access,
                inherit,
                (const wchar_t*)name);
    }

    export extern "C" void* __stdcall map_view_of_file(handle mapping,
        uint access,
        uint offset_high,
        uint offset_low,
        ulong bytes_to_map);

    export extern "C" void* __stdcall map_view_of_file_extended(handle mapping,
        uint access,
        uint offset_high,
        uint offset_low,
        ulong bytes_to_map,
        void* base_address_pointer);

    export extern "C" bool __stdcall flush_view_of_file(void* base_address_pointer,
        ulong bytes_to_flush);

    export extern "C" bool __stdcall unmap_view_of_file(void* base_addressipointer);

    //*** thread local storage

    export extern "C" uint __stdcall allocate_thread_local_storage();

    export extern "C" void* __stdcall get_thread_local_storage_value(uint index);

    export extern "C" bool __stdcall set_thread_local_storage_value(uint index,
        void* value);

    export extern "C" bool __stdcall free_thread_local_storage(uint index);

    //*** hardware devices

    export extern "C" bool __stdcall define_dos_device_a(uint flags,
        const char* device_name,
        const char* target_path);

    export extern "C" bool __stdcall define_dos_device_w(uint flags,
        const wchar_t* device_name,
        const wchar_t* target_path);

    export template<class character>
        inline bool define_dos_device(uint flags,
            const character* device_name,
            const character* target_path)
    {
        if (sizeof(character) == 1)
            return define_dos_device_a(flags,
                (const char*)device_name,
                (const char*)target_path);
        else
            return define_dos_device_w(flags,
                (const wchar_t*)device_name,
                (const wchar_t*)target_path);
    }

    export extern "C" uint __stdcall query_dos_device_a(const char* device_name,
        char* target_path,
        uint size);

    export extern "C" uint __stdcall query_dos_device_w(const wchar_t* device_name,
        wchar_t* target_path,
        uint size);

    export template<class character>
        uint query_dos_device(const character* device_name,
            character* target_path,
            uint size)
    {
        if (sizeof(character) == 1)
            return query_dos_device_a((const char*)device_name,
                target_path,
                size);
        else
            return query_dos_device_w((const wchar_t*)device_name,
                target_path,
                size);

    }

    export extern "C" bool __stdcall set_volume_label_a(const char* root,
        const char* volume);

    export extern "C" bool __stdcall set_volume_label_w(const wchar_t* root,
        const wchar_t* volume);

    export template<class character>
        inline bool set_volume_label(const character* root,
            const character* volume)
    {
        if (sizeof(character) == 1)
            return set_volume_label_a((const char*)root,
                (const char*)volume);
        else
            return set_volume_label_w((const wchar_t*)root,
                (const wchar_t*)volume);
    }

    export extern "C" void __stdcall set_file_functions_to_local();

    export extern "C" void __stdcall set_file_functions_to_international();

    export extern "C" bool __stdcall are_file_functions_international();

    //*** event log

    export extern "C" bool __stdcall clear_event_log_a(handle event_log,
        const char* backup_file_name);

    export extern "C" bool __stdcall clear_event_log_w(handle event_log,
        const wchar_t* backup_file_name);

    export template <class character>
        inline bool clear_event_log(handle event_log,
            const character* backup_file_name)
    {
        if (sizeof(character) == 1)
            return clear_event_log_a(event_log,
                (const char*)backup_file_name);
        else
            return clear_event_log_w(event_log,
                (const wchar_t*)backup_file_name);

    }

    export extern "C" bool __stdcall backup_event_log_w(handle event_log,
        const wchar_t* backup_file_name);

    export extern "C" bool __stdcall backup_event_log_a(handle event_log,
        const char* backup_file_name);

    export template <class character>
        inline bool backup_event_log(handle event_log,
            const character* backup_file_name)
    {
        if (sizeof(character) == 1)
            return backup_event_log_a(event_log,
                (const char*)backup_file_name);
        else
            return backup_event_log_w(event_log,
                (const wchar_t*)backup_file_name);
    }

    export extern "C" bool __stdcall close_event_log(handle event_log);

    export extern "C" bool __stdcall deregister_event_source(handle event_log);

    export extern "C" bool __stdcall get_number_of_event_log_records(handle event_log,
        uint * number_ofrecords);

    export extern "C" bool __stdcall get_oldest_event_log_record(handle event_log,
        uint * old_destination_record);

    export extern "C" handle __stdcall open_event_log_a(const char* server_universal_name,
        const char* source_name);

    export extern "C" handle __stdcall open_event_log_w(const wchar_t* server_universal_name,
        const wchar_t* source_name);

    export template<class character>
        inline handle open_event_log(const character* server_universal_name,
            const character* source_name)
    {
        if (sizeof(character) == 1)
            return open_event_log_a((const char*)server_universal_name,
                (const char*)source_name);
        else
            return open_event_log_w((const wchar_t*)server_universal_name,
                (const wchar_t*)source_name);
    }


    export extern "C" handle __stdcall register_event_source_a(const char* server_universal_name,
        const char* source_name);

    export extern "C" handle __stdcall register_event_source_w(const wchar_t* server_universal_name,
        const wchar_t* source_name);

    export template<class character>
        inline handle register_event_source(const character* server_universal_name,
            const character* source_name)
    {
        if (sizeof(character) == 1)
            return register_event_source_a((const char*)server_universal_name,
                (const char*)source_name);
        else
            return register_event_source_w((const wchar_t*)server_universal_name,
                (const wchar_t*)source_name);

    }

    export extern "C" handle __stdcall open_backup_event_log_a(const char* server_universal_name,
        const char* file_name);

    export extern "C" handle __stdcall open_backup_event_log_w(const wchar_t* server_universal_name,
        const wchar_t* file_name);

    export template<class character>
        inline handle open_backup_event_log(const character* server_universal_name,
            const character* file_name)
    {
        if (sizeof(character) == 1)
            return open_backup_event_log_a((const char*)server_universal_name,
                (const char*)file_name);
        else
            return open_backup_event_log_w((const wchar_t*)server_universal_name,
                (const wchar_t*)file_name);
    }

    export extern "C" bool __stdcall read_event_log(handle event_log,
        uint read_flags,
        uint record_offset,
        void* buffer_pointer,
        uint read,
        uint * read_pointer,
        uint * minimum);

    export extern "C" bool __stdcall report_event_a(handle event_log,
        part type,
        part category,
        uint event_identity,
        void* user_security_identity,
        part nmber_ofstrings,
        uint data_size,
        const char* strings,
        void* raw_data);

    export extern "C" bool __stdcall report_event_w(handle event_log,
        part type,
        part category,
        uint event_identity,
        void* user_security_identity,
        part nmber_ofstrings,
        uint data_size,
        const wchar_t* strings,
        void* raw_data);

    export template<class character>
        inline bool report_event(handle event_log,
            part type,
            part category,
            uint event_identity,
            void* user_security_identity,
            part nmber_ofstrings,
            uint data_size,
            const character* strings,
            void* raw_data)
    {
        if (sizeof(character) == 1)
            return report_event_a(event_log,
                type,
                category,
                event_identity,
                user_security_identity,
                nmber_ofstrings,
                data_size,
                (const char*)strings,
                raw_data);
        else
            return report_event_w(event_log,
                type,
                category,
                event_identity,
                user_security_identity,
                nmber_ofstrings,
                data_size,
                (const wchar_t*)strings,
                raw_data);
    }


    //*** security

    export extern "C" bool __stdcall allocate_locally_unique_identity(unique * unique_allocate);

    export extern "C" bool __stdcall impersonate_self(uint token_level_self);

    export extern "C" bool __stdcall revert_to_self();

    export extern "C" bool __stdcall check_access(descriptor * security_descriptor,
        handle client,
        uint access,
        const generic_mask * generic_mapping,
        privilege_set * access_privileges,
        uint * privileges_length,
        uint * granted,
        bool* access_status);

    export extern "C" bool __stdcall open_process_token(handle process,
        uint access,
        handle * token);

    export extern "C" bool __stdcall open_thread_token(handle thread,
        uint access,
        bool self,
        handle * token);

    export extern "C" bool __stdcall set_thread_token(handle * thread,
        handle token);

    export extern "C" bool __stdcall duplicate_token(handle token,
        uint level,
        handle * duplicate);

    export extern "C" bool __stdcall duplicate_token_extended(handle existing,
        uint access_required,
        security_attributes * attributes,
        uint duplicate,
        uint impersonation,
        handle * new_token);

    export extern "C" bool __stdcall create_restricted_token(handle existing_token,
        uint flags,
        uint disable_identity_count,
        identity_attributes * identities_to_disable,
        uint delete_privilege_count,
        privilege * privileges_to_delete,
        uint restricted_identity_count,
        identity_attributes * identities_to_restrict,
        handle * new_token);

    export extern "C" bool __stdcall get_token_information(handle token,
        uint information_class,
        void* token_information,
        uint length,
        uint * returned_length);

    export extern "C" bool __stdcall set_token_information(handle token,
        uint information_class,
        void* token_information,
        uint length);

    export extern "C" bool __stdcall adjust_token_privileges(handle token,
        bool all,
        token_privileges * new_token_privileges,
        uint length,
        token_privileges * previous,
        uint * returned_length);

    export extern "C" bool __stdcall adjust_token_groups(handle token,
        bool reset,
        token_groups * groups,
        uint length,
        token_groups * previous,
        uint * returned_length);

    export extern "C" bool __stdcall check_privileges(handle token,
        privileges * required,
        bool* result);

    export extern "C" bool __stdcall is_valid_identity(identity * ipointer);

    export extern "C" bool __stdcall equal_identity(identity * identity_a,
        identity * identity_b);

    export extern "C" bool __stdcall equal_identity_prefix(identity * identity_a,
        identity * identity_b);

    export extern "C" uint __stdcall get_identity_length_required(byte subauthority_count);

    export extern "C" bool __stdcall allocate_identity(const authority * a,
        byte subauthority_count,
        uint subauthority0,
        uint subauthority1,
        uint subauthority2,
        uint subauthority3,
        uint subauthority4,
        uint subauthority5,
        uint subauthority6,
        uint subauthority7,
        identity * *identity_allocate);

    export extern "C" void* __stdcall free_identity(identity * identity_free);

    export extern "C" bool __stdcall initialize_identity(identity * ipointer,
        const authority * authority_pointer,
        byte subauthority_count);

    export extern "C" authority * __stdcall get_identity_authority(identity * ipointer);

    export extern "C" uint * __stdcall get_identity_subauthority(identity * ipointer,
        uint subauthority);

    export extern "C" byte * __stdcall get_identity_subauthority_count(identity * ipointer);

    export extern "C" uint __stdcall get_identity_length(const identity * ipointer);

    export extern "C" bool __stdcall copy_identity(uint destination_length,
        identity * destination_identity,
        identity * source_identity);

    export extern "C" bool __stdcall lookup_account_identity_a(const char* system,
        identity * ipointer,
        const char* account,
        uint * account_name_length,
        const char* referenced_domain_name,
        uint * referenced_domain_name_length,
        uint * account_usage);

    export extern "C" bool __stdcall lookup_account_identity_w(const wchar_t* system,
        identity * ipointer,
        const wchar_t* account,
        uint * account_name_length,
        const wchar_t* referenced_domain_name,
        uint * referenced_domain_name_length,
        uint * account_usage);

    export template<class character>
        inline bool lookup_account_identity(const character* system,
            identity* ipointer,
            const character* account,
            uint* account_name_length,
            const character* referenced_domain_name,
            uint* referenced_domain_name_length,
            uint* account_usage)
    {
        if (sizeof(character) == 1)
            return lookup_account_identity_a((const char*)system,
                ipointer,
                (const char*)account,
                account_name_length,
                (const char*)referenced_domain_name,
                referenced_domain_name_length,
                account_usage);
        else
            return lookup_account_identity_w((const wchar_t*)system,
                ipointer,
                (const wchar_t*)account,
                account_name_length,
                (const wchar_t*)referenced_domain_name,
                referenced_domain_name_length,
                account_usage);
    }

    export extern "C" bool __stdcall lookup_account_name_a(const char* system,
        const char* account,
        identity * ipointer,
        uint * identity_size,
        char* referenced_domain_name,
        uint * referenced_domain_name_length,
        uint * account_usage);

    export extern "C" bool __stdcall lookup_account_name_w(const wchar_t* system,
        const wchar_t* account,
        identity * ipointer,
        uint * identity_size,
        wchar_t* referenced_domain_name,
        uint * referenced_domain_name_length,
        uint * account_usage);

    export template<class character>
        inline bool lookup_account_name(const character* system,
            const character* account,
            identity* ipointer,
            uint* identity_size,
            character* referenced_domain_name,
            uint* referenced_domain_name_length,
            uint* account_usage)
    {
        if (sizeof(character) == 1)
            return lookup_account_name_a((const char*)system,
                (const char*)account,
                ipointer,
                identity_size,
                (char*)referenced_domain_name,
                referenced_domain_name_length,
                account_usage);
        else
            return lookup_account_name_w((const wchar_t*)system,
                (const wchar_t*)account,
                ipointer,
                identity_size,
                (wchar_t*)referenced_domain_name,
                referenced_domain_name_length,
                account_usage);
    }

    export extern "C" bool __stdcall is_valid_access_list(access_list * access_list_check);

    export extern "C" bool __stdcall initialize_access_list(access_list * acces_list_initialize,
        uint length,
        uint revision);

    export extern "C" bool __stdcall get_access_list_information(access_list * access_list_get,
        void* information,
        uint length,
        uint information_class);

    export extern "C" bool __stdcall set_access_list_information(access_list * access_list_set,
        void* information,
        uint length,
        uint information_class);

    export extern "C" bool __stdcall add_access_entry(access_list * access_list_add,
        uint revision,
        uint index,
        void* entry,
        uint length);

    export extern "C" bool __stdcall delete_access_entry(access_list * acess_list_delete,
        uint index);

    export extern "C" bool __stdcall get_access_entry(access_list * access_list_get,
        uint index,
        access_entry * *access_entry_pointer);

    export extern "C" bool __stdcall add_access_allowed_entry(access_list * access_list_add,
        uint revision,
        uint access_mask,
        const identity * ipointer);

    export extern "C" bool __stdcall add_access_denied_entry(access_list * access_list_add,
        uint revision,
        uint access_mask,
        const identity * ipointer);

    export extern "C" bool __stdcall add_audit_access_entry(access_list * access_list_add,
        uint revision,
        uint access_mask,
        const identity * ipointer,
        bool audit_success,
        bool audit_failure);

    export extern "C" bool __stdcall find_first_free_access_entry(access_list * access_list_find,
        access_entry * *access_entry_pointer);

    export extern "C" bool __stdcall initialize_security_descriptor(void* descriptor,
        uint revision);

    export extern "C" bool __stdcall is_valid_security_descriptor(const descriptor * security);

    export extern "C" uint __stdcall get_descriptor_length(const descriptor * security);

    export extern "C" bool __stdcall get_security_descriptor_control(const descriptor * security,
        part * descriptor_control,
        uint * revision);

    export extern "C" bool __stdcall set_descriptor_discretionary_access_list(void* security,
        bool discretionary_present,
        access_list * discretionary,
        bool discretionary_defaulted);

    export extern "C" bool __stdcall get_descriptor_discretionary_access_list(void* security,
        bool* discretionary_present,
        access_list * *discretionary,
        bool* discretionary_defaulted);

    export extern "C" bool __stdcall set_descriptor_system_access_list(void* security,
        bool system_present,
        access_list * system,
        bool system_defaulted);

    export extern "C" bool __stdcall get_descriptor_system_access_list(void* security,
        bool* system_present,
        access_list * *system,
        bool* system_defaulted);

    export extern "C" bool __stdcall set_descriptor_owner(void* security,
        identity * owner,
        bool owner_defaulted);

    export extern "C" bool __stdcall get_descriptor_owner(void* security,
        identity * *owner,
        bool* owner_defaulted);

    export extern "C" bool __stdcall set_descriptor_group(void* security,
        identity * group,
        bool group_defaulted);

    export extern "C" bool __stdcall get_descriptor_group(void* security,
        identity * *group,
        bool* group_defaulted);

    export extern "C" bool __stdcall create_private_object_security(descriptor * parent,
        descriptor * creator,
        descriptor * *descriptor_new,
        bool directory,
        handle token,
        const generic_mask * generic_rights);

    export extern "C" bool __stdcall set_private_object_security(uint security_information,
        descriptor * descriptor_modify,
        descriptor * *object_descriptor,
        const generic_mask * generic_rights,
        handle token);

    export extern "C" bool __stdcall get_private_object_security(descriptor * object_descriptor,
        uint security_information,
        descriptor * descriptor_result,
        uint length,
        uint * returned_length);

    export extern "C" bool __stdcall destroy_private_object_security(void** object);

    export extern "C" bool __stdcall make_descriptor_self_relative(const void* absolute,
        void* selfrelative,
        uint * length);

    export extern "C" bool __stdcall make_descriptor_absolute(const descriptor * selfrelative,
        descriptor * absolute,
        uint * absolute_size,
        access_list * discretionary,
        uint * discretionary_size,
        access_list * system,
        uint * system_size,
        identity * owner,
        uint * owner_size,
        identity * primary_group,
        uint * primary_group_size);

    export extern "C" bool __stdcall set_file_security_a(const char* file_name,
        uint information,
        const descriptor * descriptor_file);

    export extern "C" bool __stdcall set_file_security_w(const wchar_t* file_name,
        uint information,
        const descriptor * descriptor_file);

    export template<class character>
        inline bool set_file_security(const character* file_name,
            uint information,
            const descriptor* descriptor_file)
    {
        if (sizeof(character) == 1)
            return set_file_security_a((const char*)file_name,
                information,
                descriptor_file);
        else
            return set_file_security_w((const wchar_t*)file_name,
                information,
                descriptor_file);
    }

    export extern "C" bool __stdcall get_file_security_a(const char* file_name,
        uint information,
        descriptor * descriptor_file,
        uint length,
        uint * required);

    export extern "C" bool __stdcall get_file_security_w(const wchar_t* file_name,
        uint information,
        descriptor * descriptor_file,
        uint length,
        uint * required);

    export template<class character>
        inline bool get_file_security(const character* file_name,
            uint information,
            descriptor* descriptor_file,
            uint length,
            uint* required)
    {
        if (sizeof(character) == 1)
            return get_file_security_a((const char*)file_name,
                information,
                descriptor_file,
                length,
                required);
        else
            return get_file_security_w((const wchar_t*)file_name,
                information,
                descriptor_file,
                length,
                required);
    }

    export extern "C" bool __stdcall get_kernel_object_security(handle object,
        uint information,
        descriptor * object_descriptor,
        uint length,
        uint * required);

    export extern "C" bool __stdcall set_kernel_object_security(handle object,
        uint information,
        descriptor * object_descriptor);

    export extern "C" bool __stdcall are_all_accesses_granted(uint granted,
        uint desired);

    export extern "C" bool __stdcall are_any_accesses_granted(uint granted,
        uint desired);

    export extern "C" bool __stdcall check_access_with_audit_alarm_a(const char* subsystem,
        void* object,
        const char* name,
        const char* object_name,
        void* security_descriptor,
        uint access,
        const generic_mask * generic_check,
        bool create,
        uint * granted,
        bool* access_status,
        bool* generate);

    export extern "C" bool __stdcall check_access_with_audit_alarm_w(const wchar_t* subsystem,
        void* object,
        const wchar_t* name,
        const wchar_t* object_name,
        void* security_descriptor,
        uint access,
        const generic_mask * generic_check,
        bool create,
        uint * granted,
        bool* access_status,
        bool* generate);

    export template<class character>
        inline bool check_access_with_audit_alarm(const character* subsystem,
            void* object,
            const character* name,
            const character* object_name,
            void* security_descriptor,
            uint access,
            const generic_mask* generic_check,
            bool create,
            uint* granted,
            bool* access_status,
            bool* generate)
    {
        if (sizeof(character) == 1)
            return check_access_with_audit_alarm_a((const char*)subsystem,
                object,
                (const char*)name,
                (const char*)object_name,
                security_descriptor,
                access,
                generic_check,
                create,
                granted,
                access_status,
                generate);
        else
            return check_access_with_audit_alarm_a((const wchar_t*)subsystem,
                object,
                (const wchar_t*)name,
                (const wchar_t*)object_name,
                security_descriptor,
                access,
                generic_check,
                create,
                granted,
                access_status,
                generate);
    }

    export extern "C" bool __stdcall open_object_audit_alarm_a(const char* subsystem,
        void* object,
        const char* type_name,
        const char* object_name,
        void* security_descriptor,
        handle client,
        uint desired,
        uint granted,
        privilege_set * object_privileges,
        bool create,
        bool grant_access,
        bool* generate);

    export extern "C" bool __stdcall open_object_audit_alarm_w(const wchar_t* subsystem,
        void* object,
        const wchar_t* type_name,
        const wchar_t* object_name,
        void* security_descriptor,
        handle client,
        uint desired,
        uint granted,
        privilege_set * object_privileges,
        bool create,
        bool grant_access,
        bool* generate);

    export template<class character>
        inline bool open_object_audit_alarm(const character* subsystem,
            void* object,
            const character* type_name,
            const character* object_name,
            void* security_descriptor,
            handle client,
            uint desired,
            uint granted,
            privilege_set* object_privileges,
            bool create,
            bool grant_access,
            bool* generate)
    {
        if (sizeof(character) == 1)
            return open_object_audit_alarm_a((const char*)subsystem,
                object,
                (const char*)type_name,
                (const char*)object_name,
                security_descriptor,
                client,
                desired,
                granted,
                object_privileges,
                create,
                grant_access,
                generate);
        else
            return open_object_audit_alarm_w((const wchar_t*)subsystem,
                object,
                (const wchar_t*)type_name,
                (const wchar_t*)object_name,
                security_descriptor,
                client,
                desired,
                granted,
                object_privileges,
                create,
                grant_access,
                generate);
    }

    export extern "C" bool __stdcall object_privilege_audit_alarm_a(const char* subsystem,
        void* object,
        handle client,
        uint desired,
        privilege_set * object_privileges,
        bool granted);

    export extern "C" bool __stdcall object_privilege_audit_alarm_w(const wchar_t* subsystem,
        void* object,
        handle client,
        uint desired,
        privilege_set * object_privileges,
        bool granted);

    export template<class character>
        inline bool object_privilege_audit_alarm(const character* subsystem,
            void* object,
            handle client,
            uint desired,
            privilege_set* object_privileges,
            bool granted)
    {
        if (sizeof(character) == 1)
            return object_privilege_audit_alarm_a((const char*)subsystem,
                object,
                client,
                desired,
                object_privileges,
                granted);
        else
            return object_privilege_audit_alarm_w((const wchar_t*)subsystem,
                object,
                client,
                desired,
                object_privileges,
                granted);
    }

    export extern "C" bool __stdcall close_object_audit_alarm_a(const char* subsystem,
        void* object,
        bool generate);

    export extern "C" bool __stdcall close_object_audit_alarm_w(const wchar_t* subsystem,
        void* object,
        bool generate);

    export template<class character>
        inline bool close_object_audit_alarm(const character* subsystem,
            void* object,
            bool generate)
    {
        if (sizeof(character) == 1)
            return close_object_audit_alarm_a((const char*)subsystem,
                object,
                generate);
        else
            return close_object_audit_alarm_w((const wchar_t*)subsystem,
                object,
                generate);
    }

    export extern "C" bool __stdcall privileged_service_audit_alarm_a(const char* subsystem,
        const char* service_name,
        handle client,
        privilege_set * privileges_service,
        bool granted);

    export extern "C" bool __stdcall privileged_service_audit_alarm_w(const wchar_t* subsystem,
        const wchar_t* service_name,
        handle client,
        privilege_set * privileges_service,
        bool granted);

    export template<class character>
        inline bool privileged_service_audit_alarm(const character* subsystem,
            const character* service_name,
            handle client,
            privilege_set* privileges_service,
            bool granted)
    {
        if (sizeof(character) == 1)
            return privileged_service_audit_alarm_a((const char*)subsystem,
                (const char*)service_name,
                client,
                privileges_service,
                granted);
        else
            return privileged_service_audit_alarm_w((const wchar_t*)subsystem,
                (const wchar_t*)service_name,
                client,
                privileges_service,
                granted);
    }

    export extern "C" void __stdcall map_generic_mask(uint * access_mask,
        generic_mask * generic_mask);

    export extern "C" bool __stdcall lookup_privilege_value_a(const char* system,
        const char* name,
        unique * lookup);

    export extern "C" bool __stdcall lookup_privilege_value_w(const wchar_t* system,
        const wchar_t* name,
        unique * lookup);

    export template<class character>
        inline bool lookup_privilege_value(const character* system,
            const character* name,
            unique* lookup)
    {
        if (sizeof(character) == 1)
            return lookup_privilege_value_a((const char*)system,
                (const char*)name,
                lookup);
        else
            return lookup_privilege_value_w((const wchar_t*)system,
                (const wchar_t*)name,
                lookup);
    }

    export extern "C" bool __stdcall lookup_privilege_name_a(const char* system,
        unique * unique_lookup,
        char* name,
        uint * length);

    export extern "C" bool __stdcall lookup_privilege_name_w(const wchar_t* system,
        unique * unique_lookup,
        wchar_t* name,
        uint * length);

    export template<class character>
        inline bool  lookup_privilege_name(const character* system,
            unique* unique_lookup,
            character* name,
            uint* length)
    {
        if (sizeof(character) == 1)
            return lookup_privilege_name_a((const char*)system,
                unique_lookup,
                (char*)name,
                length);
        else
            return lookup_privilege_name_w((const wchar_t*)system,
                unique_lookup,
                (wchar_t*)name,
                length);
    }

    export extern "C" bool __stdcall lookup_privilege_display_name_a(const char* system,
        const char* name,
        char* display_name,
        uint * length,
        uint * language_identity);

    export extern "C" bool __stdcall lookup_privilege_display_name_w(const wchar_t* system,
        const wchar_t* name,
        wchar_t* display_name,
        uint * length,
        uint * language_identity);

    export template<class character>
        inline bool lookup_privilege_display_name(const character* system,
            const character* name,
            character* display_name,
            uint* length,
            uint* language_identity)
    {
        if (sizeof(character) == 1)
            return lookup_privilege_display_name_a((const char*)system,
                (const char*)name,
                (char*)display_name,
                length,
                language_identity);
        else
            return lookup_privilege_display_name_w((const wchar_t*)system,
                (const wchar_t*)name,
                (wchar_t*)display_name,
                length,
                language_identity);
    }

    //*** services

    export extern "C" bool __stdcall change_service_configuration_a(handle service,
        uint service_type,
        uint destination_type,
        uint error_control,
        const char* binary_path_name,
        const char* load_order_group,
        uint * tag_identity,
        const char* dependencies,
        const char* service_start_name,
        const char* password,
        const char* display_name);

    export extern "C" bool __stdcall change_service_configuration_w(handle service,
        uint service_type,
        uint destination_type,
        uint error_control,
        const wchar_t* binary_path_name,
        const wchar_t* load_order_group,
        uint * tag_identity,
        const wchar_t* dependencies,
        const wchar_t* service_start_name,
        const wchar_t* password,
        const wchar_t* display_name);

    export template<class character>
        inline bool change_service_configuration(handle service,
            uint service_type,
            uint destination_type,
            uint error_control,
            const character* binary_path_name,
            const character* load_order_group,
            uint* tag_identity,
            const character* dependencies,
            const character* service_start_name,
            const character* password,
            const character* display_name)
    {
        if (sizeof(character) == 1)
            return change_service_configuration_a(service,
                service_type,
                destination_type,
                error_control,
                (const char*)binary_path_name,
                (const char*)load_order_group,
                tag_identity,
                (const char*)dependencies,
                (const char*)service_start_name,
                (const char*)password,
                (const char*)display_name);
        else
            return change_service_configuration_w(service,
                service_type,
                destination_type,
                error_control,
                (const wchar_t*)binary_path_name,
                (const wchar_t*)load_order_group,
                tag_identity,
                (const wchar_t*)dependencies,
                (const wchar_t*)service_start_name,
                (const wchar_t*)password,
                (const wchar_t*)display_name);

    }


    export extern "C" bool __stdcall change_service_configuration2_a(handle service,
        uint information_level,
        void* information);

    export extern "C" bool __stdcall change_service_configuration2_w(handle service,
        uint information_level,
        void* information);

    export extern "C" bool __stdcall close_service_handle(handle control);

    export extern "C" handle __stdcall open_service_manager_a(const char* machine_name,
        const char* database_name,
        uint desired);

    export extern "C" handle __stdcall open_service_manager_w(const wchar_t* machine_name,
        const wchar_t* database_name,
        uint desired);

    export template<class character>
        inline handle open_service_manager(const character* machine_name,
            const character* database_name,
            uint desired)
    {
        if (sizeof(character) == 1)
            return open_service_manager_a((const char*)machine_name,
                (const char*)database_name,
                desired);
        else
            return open_service_manager_w((const wchar_t*)machine_name,
                (const wchar_t*)database_name,
                desired);
    }

    export extern "C" bool __stdcall enumerate_services_status_a(handle manager,
        uint type,
        uint state,
        enumerate_service_status<char> *services,
        uint size,
        uint * needed,
        uint * returned,
        uint * resume);

    export extern "C" bool __stdcall enumerate_services_status_w(handle manager,
        uint type,
        uint state,
        enumerate_service_status<wchar_t> *services,
        uint size,
        uint * needed,
        uint * returned,
        uint * resume);

    export template<class character>
        inline bool enumerate_services_status(handle manager,
            uint type,
            uint state,
            enumerate_service_status<character>* services,
            uint size,
            uint* needed,
            uint* returned,
            uint* resume)
    {
        if (sizeof(character) == 1)
            return enumerate_services_status_a(manager,
                type,
                state,
                (enumerate_service_status<char>*) services,
                size,
                needed,
                returned,
                resume);
        else
            return enumerate_services_status_w(manager,
                type,
                state,
                (enumerate_service_status<wchar_t>*) services,
                size,
                needed,
                returned,
                resume);
    }

    export extern "C" bool __stdcall enumerate_services_status_extended_a(handle manager,
        uint information_level,
        uint service_type,
        uint service_state,
        enumerate_service_status_process<char> *services,
        uint buffer_size,
        uint * bytes_needed,
        uint * services_returned,
        uint * resume_handle,
        const char* group_name);

    export extern "C" bool __stdcall enumerate_services_status_extended_w(handle manager,
        uint information_level,
        uint service_type,
        uint service_state,
        enumerate_service_status_process<wchar_t> *services,
        uint buffer_size,
        uint * bytes_needed,
        uint * services_returned,
        uint * resume_handle,
        const wchar_t* group_name);

    export template<class character>
        inline bool enumerate_services_status_extended(handle manager,
            uint information_level,
            uint service_type,
            uint service_state,
            enumerate_service_status_process<character>* services,
            uint buffer_size,
            uint* bytes_needed,
            uint* services_returned,
            uint* resume_handle,
            const character* group_name)
    {
        if (sizeof(character) == 1)
            return enumerate_services_status_extended_a(manager,
                information_level,
                service_type,
                service_state,
                (enumerate_service_status_process<char>*) services,
                buffer_size,
                bytes_needed,
                services_returned,
                resume_handle,
                (const char*)group_name);
        else
            return enumerate_services_status_extended_w(manager,
                information_level,
                service_type,
                service_state,
                (enumerate_service_status_process<wchar_t>*) services,
                buffer_size,
                bytes_needed,
                services_returned,
                resume_handle,
                (const wchar_t*)group_name);

    }

    export extern "C" bool __stdcall get_service_key_name_a(handle manager,
        const char* display_name,
        const char* service_name,
        uint * buffer);

    export extern "C" bool __stdcall get_service_key_name_w(handle manager,
        const wchar_t* display_name,
        const wchar_t* service_name,
        uint * buffer);

    export template<class character>
        inline bool get_service_key_name(handle manager,
            const character* display_name,
            const character* service_name,
            uint* buffer)
    {
        if (sizeof(character) == 1)
            return get_service_key_name_a(manager,
                (const char*)display_name,
                (const char*)service_name,
                buffer);
        else
            return get_service_key_name_w(manager,
                (const wchar_t*)display_name,
                (const wchar_t*)service_name,
                buffer);
    }

    export extern "C" bool __stdcall get_service_display_name_a(handle manager,
        const char* service_name,
        char* display_name,
        uint * buffer);

    export extern "C" bool __stdcall get_service_display_name_w(handle manager,
        const wchar_t* service_name,
        wchar_t* display_name,
        uint * buffer);

    export template<class character>
        inline bool get_service_display_name(handle manager,
            const character* service_name,
            character* display_name,
            uint* buffer)
    {
        if (sizeof(character) == 1)
            return get_service_display_name_a(manager,
                (const char*)service_name,
                (char*)display_name,
                buffer);
        else
            return get_service_display_name_w(manager,
                (const wchar_t*)service_name,
                (wchar_t*)display_name,
                buffer);

    }

    export extern "C" handle __stdcall lock_service_database(handle manager);

    export extern "C" bool __stdcall unlock_service_database(handle lock);

    export extern "C" bool __stdcall notify_boot_configuration_status(bool boot_acceptable);

    export extern "C" handle __stdcall open_service_a(handle manager,
        const char* service_name,
        uint desired);

    export extern "C" handle __stdcall open_service_w(handle manager,
        const wchar_t* service_name,
        uint desired);

    export template<class character>
        inline handle open_service(handle manager,
            const character* service_name,
            uint desired)
    {
        if (sizeof(character) == 1)
            return open_service_a(manager,
                (const char*)service_name,
                desired);
        else
            return open_service_w(manager,
                (const wchar_t*)service_name,
                desired);
    }

    export extern "C" handle __stdcall create_service_a(handle manager,
        const char* service_name,
        const char* display_name,
        uint desired,
        uint service_type,
        uint destination_type,
        uint error_control,
        const char* binary_path_name,
        const char* load_order_group,
        uint * tag_identity,
        const char* dependencies,
        const char* service_start_name,
        const char* password);

    export extern "C" handle __stdcall create_service_w(handle manager,
        const wchar_t* service_name,
        const wchar_t* display_name,
        uint desired,
        uint service_type,
        uint destination_type,
        uint error_control,
        const wchar_t* binary_path_name,
        const wchar_t* load_order_group,
        uint * tag_identity,
        const wchar_t* dependencies,
        const wchar_t* service_start_name,
        const wchar_t* password);

    export template<class character>
        inline handle create_service(handle manager,
            const character* service_name,
            const character* display_name,
            uint desired,
            uint service_type,
            uint destination_type,
            uint error_control,
            const character* binary_path_name,
            const character* load_order_group,
            uint* tag_identity,
            const character* dependencies,
            const character* service_start_name,
            const character* password)
    {
        if (sizeof(character) == 1)
            return create_service_a(manager,
                (const char*)service_name,
                (const char*)display_name,
                desired,
                service_type,
                destination_type,
                error_control,
                (const char*)binary_path_name,
                (const char*)load_order_group,
                tag_identity,
                (const char*)dependencies,
                (const char*)service_start_name,
                (const char*)password);
        else
            return create_service_w(manager,
                (const wchar_t*)service_name,
                (const wchar_t*)display_name,
                desired,
                service_type,
                destination_type,
                error_control,
                (const wchar_t*)binary_path_name,
                (const wchar_t*)load_order_group,
                tag_identity,
                (const wchar_t*)dependencies,
                (const wchar_t*)service_start_name,
                (const wchar_t*)password);
    }

    export extern "C" bool __stdcall delete_service(handle service);

    export extern "C" bool __stdcall control_service(handle service,
        uint control,
        service_status * service_status);

    export extern "C" bool __stdcall query_service_configuration_a(handle service,
        service_configuration<char> *configuration,
        uint size,
        uint * bytes_needed);

    export extern "C" bool __stdcall query_service_configuration_w(handle service,
        service_configuration<wchar_t> *configuration,
        uint size,
        uint * bytes_needed);

    export template<class character>
        inline bool  query_service_configuration(handle service,
            service_configuration<character>* configuration,
            uint size,
            uint* bytes_needed)
    {
        if (sizeof(character) == 1)
            return query_service_configuration_a(service,
                (service_configuration<char>*)configuration,
                size,
                bytes_needed);
        else
            return query_service_configuration_w(service,
                (service_configuration<wchar_t>*)configuration,
                size,
                bytes_needed);
    }

    export extern "C" bool __stdcall query_service_configuration2_a(handle service,
        uint information_level,
        byte * buffer,
        uint buffer_size,
        uint * bytes_needed);

    export extern "C" bool __stdcall query_service_configuration2_w(handle service,
        uint information_level,
        byte * buffer,
        uint buffer_size,
        uint * bytes_needed);

    export extern "C" bool __stdcall enumerate_dependent_services_a(handle service,
        uint service_state,
        enumerate_service_status<char> *services,
        uint size,
        uint * bytes_needed,
        uint * returned);

    export extern "C" bool __stdcall enumerate_dependent_services_w(handle service,
        uint service_state,
        enumerate_service_status<wchar_t> *services,
        uint size,
        uint * bytes_needed,
        uint * returned);

    export template<class character>
        inline bool enumerate_dependent_services(handle service,
            uint service_state,
            enumerate_service_status<character>* services,
            uint size,
            uint* bytes_needed,
            uint* returned)
    {
        if (sizeof(character) == 1)
            return enumerate_dependent_services_a(service,
                service_state,
                (enumerate_service_status<char>*)services,
                size,
                bytes_needed,
                returned);
        else
            return enumerate_dependent_services_w(service,
                service_state,
                (enumerate_service_status<wchar_t>*)services,
                size,
                bytes_needed,
                returned);
    }

    export extern "C" bool __stdcall query_service_lock_status_a(handle manager,
        service_lock_status<char> *status,
        uint size,
        uint * bytes_needed);

    export extern "C" bool __stdcall query_service_lock_status_w(handle manager,
        service_lock_status<wchar_t> *status,
        uint size,
        uint * bytes_needed);

    export template<class character>
        inline bool query_service_lock_status(handle manager,
            service_lock_status<character>* status,
            uint size,
            uint* bytes_needed)
    {
        if (sizeof(character) == 1)
            return query_service_lock_status_a(manager,
                (service_lock_status<char>*)status,
                size,
                bytes_needed);
        else
            return query_service_lock_status_w(manager,
                (service_lock_status<wchar_t>*)status,
                size,
                bytes_needed);
    }

    export extern "C" bool __stdcall query_service_object_security(handle service,
        uint security_information,
        void* security_descriptor,
        uint size,
        uint * bytes_needed);

    export extern "C" bool __stdcall set_service_object_security(handle service,
        uint security_information,
        void* security_descriptor);

    export extern "C" bool __stdcall query_service_status(handle service,
        service_status * status);

    export extern "C" bool __stdcall query_service_status_extended(handle service,
        uint level,
        byte * buffer,
        uint size,
        uint * bytes_needed);

    export extern "C" bool __stdcall start_service_a(handle service,
        uint service_parameters,
        const char* service_parameter_vectors);

    export extern "C" bool __stdcall start_service_w(handle service,
        uint service_parameters,
        const wchar_t* service_parameter_vectors);

    export template<class character>
        inline bool start_service(handle service,
            uint service_parameters,
            const character* service_parameter_vectors)
    {
        if (sizeof(character) == 1)
            return start_service_a(service,
                service_parameters,
                (const char*)service_parameter_vectors);
        else
            return start_service_w(service,
                service_parameters,
                (const wchar_t*)service_parameter_vectors);
    }

    export extern "C" handle __stdcall register_service_control_handler_a(const char* name,
        service_handler handler);

    export extern "C" handle __stdcall register_service_control_handler_w(const wchar_t* name,
        service_handler handler);

    export template<class character>
        inline handle register_service_control_handler(const character* name,
            service_handler handler)
    {
        if (sizeof(character) == 1)
            return register_service_control_handler_a((const char*)name,
                handler);
        else
            return register_service_control_handler_w((const wchar_t*)name,
                handler);
    }

    export extern "C" handle __stdcall register_service_control_handler_extended_a(const char* name,
        service_handler_extended handler,
        void* context);

    export extern "C" handle __stdcall register_service_control_handler_extended_w(const wchar_t* name,
        service_handler_extended handler,
        void* context);

    export template<class character>
        inline handle register_service_control_handler_extended(const character* name,
            service_handler_extended handler,
            void* context)
    {
        if (sizeof(character) == 1)
            return register_service_control_handler_extended_a((const char*)name,
                handler,
                context);
        else
            return register_service_control_handler_extended_w((const wchar_t*)name,
                handler,
                context);
    }

    export extern "C" bool __stdcall set_service_status(handle service_status_handle,
        service_status * status);

    export extern "C" bool __stdcall start_service_control_dispatcher_a(service_table_entry<char> *table_entries);

    export extern "C" bool __stdcall start_service_control_dispatcher_w(service_table_entry<wchar_t> *table_entries);

    export template<class character>
        inline bool start_service_control_dispatcher(service_table_entry<character>* table_entries)
    {
        if (sizeof(character) == 1)
            return start_service_control_dispatcher_a((service_table_entry<char> *) table_entries);
        else
            return start_service_control_dispatcher_w((service_table_entry<wchar_t> *) table_entries);

    }


    //*** other miscellaneous control program functions

    export extern "C" bool __stdcall is_bad_read_pointer(const void* read,
        uint size);

    export extern "C" bool __stdcall is_bad_write_pointer(void* write,
        uint size);

    export extern "C" bool __stdcall is_bad_huge_read_pointer(const void* read,
        uint size);

    export extern "C" bool __stdcall is_bad_huge_write_pointer(void* write,
        uint size);

    export extern "C" bool __stdcall is_bad_code_pointer(function_type function_test);

    export extern "C" bool __stdcall is_bad_string_pointer(const character * string,
        uint maximum_size);

    export extern "C" bool __stdcall get_computer_name_a(char* buffer,
        uint * size);

    export extern "C" bool __stdcall get_computer_name_w(wchar_t* buffer,
        uint * size);

    export template<class character>
        inline bool get_computer_name(character* buffer,
            uint* size)
    {
        if (sizeof(character) == 1)
            return get_computer_name_a((char*)buffer,
                size);
        else
            return get_computer_name_w((wchar_t*)buffer,
                size);
    }

    export extern "C" bool __stdcall set_computer_name_a(const char* computer_name);

    export extern "C" bool __stdcall set_computer_name_w(const wchar_t* computer_name);

    export template<class character>
        inline bool set_computer_name(const character* computer_name)
    {
        if (sizeof(character) == 1)
            return set_computer_name_a((const char*)computer_name);
        else
            return set_computer_name_w((const wchar_t*)computer_name);
    }

    export extern "C" bool __stdcall get_computer_name_extended_a(uint format,
        char* buffer,
        uint * size);

    export extern "C" bool __stdcall get_computer_name_extended_w(uint format,
        wchar_t* buffer,
        uint * size);

    export template<class character>
        inline bool get_computer_name_extended(uint format,
            character* buffer,
            uint* size)
    {
        if (sizeof(character) == 1)
            return get_computer_name_extended_a(format,
                (char*)buffer,
                size);
        else
            return get_computer_name_extended_w(format,
                (wchar_t*)buffer,
                size);
    }

    export extern "C" bool __stdcall set_computer_name_extended_a(uint format,
        const char* buffer);

    export extern "C" bool __stdcall set_computer_name_extended_w(uint format,
        const wchar_t* buffer);

    export template<class character>
        inline bool set_computer_name_extended(uint format,
            const character* buffer)
    {
        if (sizeof(character) == 1)
            return set_computer_name_extended_a(format,
                (const char*)buffer);
        else
            return set_computer_name_extended_w(format,
                (const wchar_t*)buffer);
    }

    export extern "C" bool __stdcall get_user_name_a(char* buffer,
        uint * size);

    export extern "C" bool __stdcall get_user_name_w(wchar_t* buffer,
        uint * size);

    export template<class character>
        inline bool get_user_name(character* buffer,
            uint* size)
    {
        if (sizeof(character) == 1)
            return get_user_name_a((char*)buffer,
                size);
        else
            return get_user_name_a((wchar_t*)buffer,
                size);

    }

    export extern "C" bool __stdcall logon_user_a(const char* user,
        const char* domain,
        const char* password,
        uint logon_type,
        uint logon_providor,
        handle * token);

    export extern "C" bool __stdcall logon_user_w(const wchar_t* user,
        const wchar_t* domain,
        const wchar_t* password,
        uint logon_type,
        uint logon_providor,
        handle * token);

    export template<class character>
        inline bool logon_user(const character* user,
            const character* domain,
            const character* password,
            uint logon_type,
            uint logon_providor,
            handle* token)
    {
        if (sizeof(character) == 1)
            return logon_user_a((const char*)user,
                (const char*)domain,
                (const char*)password,
                logon_type,
                logon_providor,
                token);
        else
            return logon_user_w((const wchar_t*)user,
                (const wchar_t*)domain,
                (const wchar_t*)password,
                logon_type,
                logon_providor,
                token);
    }

    export extern "C" bool __stdcall query_performance_counter(ulong * performance_count);

    export extern "C" bool __stdcall query_performance_frequency(ulong * frequency);

    //*** locales

    export extern "C" bool __stdcall is_valid_codepage(uint codepage);

    export extern "C" uint __stdcall get_ansi_codepage();

    export extern "C" uint __stdcall get_local_codepage();

    export extern "C" bool __stdcall get_codepage_information(uint codepage,
        codepage_information * information);

    export extern "C" bool __stdcall get_codepage_information_extended_a(uint codepage,
        uint flags,
        codepage_information_extended<char> *information);

    export extern "C" bool __stdcall get_codepage_information_extended_b(uint codepage,
        uint flags,
        codepage_information_extended<wchar_t> *information);

    export template<class character>
        inline bool  get_codepage_information_extended(uint codepage,
            uint flags,
            codepage_information_extended<character>* information)
    {
        if (sizeof(character) == 1)
            return get_codepage_information_extended_a(codepage,
                flags,
                (codepage_information_extended<char>*) information);
        else
            return get_codepage_information_extended_w(codepage,
                flags,
                (codepage_information_extended<wchar_t>*) information);
    }

    export extern "C" bool __stdcall is_double_byte_lead_byte(byte test_byte);

    export extern "C" bool __stdcall is_double_byte_lead_byte_extended(uint codepage,
        byte test_byte);

    export extern "C"  int __stdcall multibyte_to_wide_character(uint codepage,
        uint flags,
        const char* multi_byte,
        int multi_byte_length,
        wchar_t* string,
        int string_length);

    export extern "C" int __stdcall wide_character_to_multibyte(uint codepage,
        uint flags,
        const wchar_t* wide,
        int wchar_t_length,
        char* multi_byte,
        int multi_byte_length,
        const char* default_character,
        bool* used_default_character);

    export extern "C" int __stdcall compare_strings_via_locale_a(uint locale_compare,
        uint compare_flags,
        const char* string1,
        int length1,
        const char* string2,
        int length2);

    export extern "C" int __stdcall compare_strings_via_locale_w(uint locale_compare,
        uint compare_flags,
        const wchar_t* string1,
        int length1,
        const wchar_t* string2,
        int length2);

    export template<class character>
        inline int compare_strings_via_locale(uint locale_compare,
            uint compare_flags,
            const character* string1,
            int length1,
            const character* string2,
            int length2)
    {
        if (sizeof(character) == 1)
            return compare_strings_via_locale_a(locale_compare,
                compare_flags,
                (const char*)string1,
                length1,
                (const char*)string2,
                length2);
        else
            return compare_strings_via_locale_w(locale_compare,
                compare_flags,
                (const wchar_t*)string1,
                length1,
                (const wchar_t*)string2,
                length2);
    }

    export extern "C" int __stdcall map_string_via_locale_a(uint locale_map,
        uint map_flags,
        const char* source,
        int source_length,
        char* destination,
        int destination_length);

    export extern "C" int __stdcall map_string_via_locale_w(uint locale_map,
        uint map_flags,
        const wchar_t* source,
        int source_length,
        wchar_t* destination,
        int destination_length);

    export template<class character>
        inline int map_string_via_locale(uint locale_map,
            uint map_flags,
            const character* source,
            int source_length,
            character* destination,
            int destination_length)
    {
        if (sizeof(character) == 1)
            return map_string_via_locale_a(locale_map,
                map_flags,
                (const char*)source,
                source_length,
                (char*)destination,
                destination_length);
        else
            return map_string_via_locale_w(locale_map,
                map_flags,
                (const wchar_t*)source,
                source_length,
                (wchar_t*)destination,
                destination_length);
    }

    export extern "C" int __stdcall get_locale_information_a(uint locale_get,
        locale_type locale_type_get,
        char* locale_data,
        int data_length);

    export extern "C" int __stdcall get_locale_information_w(uint locale_get,
        locale_type locale_type_get,
        wchar_t* locale_data,
        int data_length);

    export template<class character>
        inline int get_locale_information(int locale_get,
            locale_type locale_type_get,
            character* locale_data,
            int data_length)
    {
        if (sizeof(character) == 1)
            return get_locale_information_a(locale_get,
                locale_type_get,
                (char*)locale_data,
                data_length);
        else
            return get_locale_information_w(locale_get,
                locale_type_get,
                (wchar_t*)locale_data,
                data_length);
    }

    export extern "C" bool __stdcall set_locale_information_a(uint locale_set,
        locale_type locale_type_set,
        const char* locale_data);

    export extern "C" bool __stdcall set_locale_information_w(uint locale_set,
        locale_type locale_type_set,
        const wchar_t* locale_data);

    export template<class character>
        inline bool set_locale_information(uint locale_set,
            locale_type locale_type_set,
            const character* locale_data)
    {
        if (sizeof(character) == 1)
            return set_locale_information_a(locale_set,
                locale_type_set,
                (const char*)locale_data);
        else
            return set_locale_information_w(locale_set,
                locale_type_set,
                (const wchar_t*)locale_data);
    }

    export extern "C" int __stdcall get_time_format_a(uint locale_time,
        uint flags,
        const system_time * time,
        const char* format,
        char* time_string,
        int time_length);

    export extern "C" int __stdcall get_time_format_w(uint locale_time,
        uint flags,
        const system_time * time,
        const wchar_t* format,
        wchar_t* time_string,
        int time_length);

    export template<class character>
        inline int get_time_format(uint locale_time,
            uint flags,
            const system_time* time,
            const character* format,
            character* time_string,
            int time_length)
    {
        if (sizeof(character) == 1)
            return get_time_format_a(locale_time,
                flags,
                time,
                (const char*)format,
                (char*)time_string,
                time_length);
        else
            return get_time_format_w(locale_time,
                flags,
                time,
                (const wchar_t*)format,
                (wchar_t*)time_string,
                time_length);
    }

    export extern "C" int __stdcall get_date_format_a(uint locale_date,
        uint flags,
        const system_time * system_time_date,
        const char* format,
        char* date,
        int date_length);

    export extern "C" int __stdcall get_date_format_w(uint locale_date,
        uint flags,
        const system_time * system_time_date,
        const wchar_t* format,
        wchar_t* date,
        int date_length);

    export template<class character>
        inline int get_date_format(uint locale_date,
            uint flags,
            const system_time* system_time_date,
            const character* format,
            character* date,
            int date_length)
    {
        if (sizeof(character) == 1)
            return get_date_format_a(locale_date,
                flags,
                system_time_date,
                (const char*)format,
                (char*)date,
                date_length);
        else
            return get_date_format_w(locale_date,
                flags,
                system_time_date,
                (const wchar_t*)format,
                (wchar_t*)date,
                date_length);
    }

    export extern "C" int __stdcall get_number_format_a(uint locale_number,
        uint flags,
        const char* value,
        const number_format_flags<char> *number_format,
        char* number_string,
        int number_length);

    export extern "C" int __stdcall get_number_format_w(uint locale_number,
        uint flags,
        const wchar_t* value,
        const number_format_flags<wchar_t> *number_format,
        wchar_t* number_string,
        int number_length);

    export template<class character>
        inline int get_number_format(uint locale_number,
            uint flags,
            const character* value,
            const number_format_flags<character>* number_format,
            character* number_string,
            int number_length)
    {
        if (sizeof(character) == 1)
            return get_number_format_a(locale_number,
                flags,
                (const char*)value,
                (const number_format_flags<char>*) number_format,
                (char*)number_string,
                number_length);
        else
            return get_number_format_w(locale_number,
                flags,
                (const wchar_t*)value,
                (const number_format_flags<wchar_t>*) number_format,
                (wchar_t*)number_string,
                number_length);
    }

    export extern "C" int __stdcall get_currency_format_a(uint locale_currency,
        uint flags,
        const char* value,
        const currency_format_flags<char> *currency_format,
        char* currency,
        int currency_length);

    export extern "C" int __stdcall get_currency_format_w(uint locale_currency,
        uint flags,
        const wchar_t* value,
        const currency_format_flags<wchar_t> *currency_format,
        wchar_t* currency,
        int currency_length);


    export template<class character>
        inline int get_currency_format(uint locale_currency,
            uint flags,
            const character* value,
            const currency_format_flags<character>* currency_format,
            character* currency,
            int currency_length)
    {
        if (sizeof(character) == 1)
            return get_currency_format_a(locale_currency,
                flags,
                (const char*)value,
                (const currency_format_flags<char>*) currency_format,
                char* currency,
                currency_length);
        else
            return get_currency_format_a(locale_currency,
                flags,
                (const wchar_t*)value,
                (const currency_format_flags<wchar_t>*) currency_format,
                wchar_t* currency,
                currency_length);
    }

    export extern "C" bool __stdcall enumerate_calendar_information_a(calendar_information_callback_a callback,
        uint locale_calendar,
        uint calendar_identity,
        uint calendar_type);

    export extern "C" bool __stdcall enumerate_calendar_information_w(calendar_information_callback_w callback,
        uint locale_calendar,
        uint calendar_identity,
        uint calendar_type);

    export  inline bool enumerate_calendar_information(calendar_information_callback callback,
        uint locale_calendar,
        uint calendar_identity,
        uint calendar_type)
    {
        return enumerate_calendar_information_w((calendar_information_callback_w)callback,
            locale_calendar,
            calendar_identity,
            calendar_type);
    }

    export extern "C" bool __stdcall enumerate_calendar_information_extended_a(calendar_information_extended_callback_a callback,
        uint locale_calendar,
        uint calendar_identity,
        uint calendar_type);

    export extern "C" bool __stdcall enumerate_calendar_information_extended_w(calendar_information_extended_callback_w callback,
        uint locale_calendar,
        uint calendar_identity,
        uint calendar_type);

    export  inline bool enumerate_calendar_information_extended(calendar_information_extended_callback callback,
        uint locale_calendar,
        uint calendar_identity,
        uint calendar_type)
    {
        return enumerate_calendar_information_extended_w((calendar_information_extended_callback_w)callback,
            locale_calendar,
            calendar_identity,
            calendar_type);
    }

    export extern "C" bool __stdcall enumerate_time_formats_a(time_format_callback_a callback,
        uint locale_time,
        uint flags);

    export extern "C" bool __stdcall enumerate_time_formats_w(time_format_callback_w callback,
        uint locale_time,
        uint flags);

    export  inline bool enumerate_time_formats(time_format_callback callback,
        uint locale_time,
        uint flags)
    {
        return enumerate_time_formats_w((time_format_callback_w)callback,
            locale_time,
            flags);
    }

    export extern "C" bool __stdcall enumerate_date_formats_a(format_date_callback_a callback,
        uint locale_date,
        uint flags);

    export extern "C" bool __stdcall enumerate_date_formats_w(format_date_callback_w callback,
        uint locale_date,
        uint flags);

    export  inline bool enumerate_date_formats(format_date_callback callback,
        uint locale_date,
        uint flags)
    {
        return enumerate_date_formats_w((format_date_callback_w)callback,
            locale_date,
            flags);
    }

    export extern "C" bool __stdcall enumerate_date_formats_extended_a(format_date_extended_callback_a callback,
        uint locale_date,
        uint flags);

    export extern "C" bool __stdcall enumerate_date_formats_extended_w(format_date_extended_callback_w callback,
        uint locale_date,
        uint flags);

    export  inline bool enumerate_date_formats_extended(format_date_extended_callback callback,
        uint locale_date,
        uint flags)
    {
        return enumerate_date_formats_extended_w((format_date_extended_callback_w)callback,
            locale_date,
            flags);
    }

    export extern "C" bool __stdcall is_valid_locale(uint locale_validate,
        uint flags);

    export extern "C" uint __stdcall convert_default_locale(uint locale_to_convert);

    export extern "C" uint __stdcall get_thread_locale();

    export extern "C" bool __stdcall set_thread_locale(uint locale_thread);

    export extern "C" language_identity __stdcall get_system_default_language_identity();

    export extern "C" language_identity __stdcall get_default_language_identity();

    export extern "C" uint __stdcall get_system_default_locale_identity();

    export extern "C" uint __stdcall get_default_locale_identity();

    export extern "C" bool __stdcall get_string_type_extended_a(uint locale_string,
        uint information_type,
        const char* source,
        int source_length,
        part * character_type_pointer);

    export extern "C" bool __stdcall get_string_type_extended_w(uint locale_string,
        uint information_type,
        const wchar_t* source,
        int source_length,
        part * character_type_pointer);

    export template<class character>
        inline bool get_string_type_extended(uint locale_string,
            uint information_type,
            const character* source,
            int source_length,
            part* character_type_pointer)
    {
        if (sizeof(character) == 1)
            return get_string_type_extended_a(locale_string,
                information_type,
                (const char*)source,
                source_length,
                character_type_pointer);
        else
            return get_string_type_extended_w(locale_string,
                information_type,
                (const wchar_t*)source,
                source_length,
                character_type_pointer);
    }

    export extern "C"  bool get_string_type_a(uint information_type,
        const char* source,
        int source_length,
        part * type);

    export extern "C"  bool get_string_type_w(uint information_type,
        const wchar_t* source,
        int source_length,
        part * type);

    export template<class character>
        inline bool get_string_type(uint information_type,
            const character* source,
            int source_length,
            part* type)
    {
        if (sizeof(character) == 1)
            return get_string_type_a(information_type,
                (const char*)source,
                source_length,
                type);
        else
            return get_string_type_w(information_type,
                (const wchar_t*)source,
                source_length,
                type);
    }

    export extern "C" int __stdcall fold_string_a(uint map_flags,
        const char* source,
        int source_length,
        char* destination,
        int destination_length);

    export extern "C" int __stdcall fold_string_w(uint map_flags,
        const wchar_t* source,
        int source_length,
        wchar_t* destination,
        int destination_length);

    export template<class character>
        inline int fold_string(uint map_flags,
            const character* source,
            int source_length,
            character* destination,
            int destination_length)
    {
        if (sizeof(character) == 1)
            return fold_string_a(map_flags,
                (const char*)source,
                source_length,
                (char*)destination,
                destination_length);
        else
            return fold_string_w(map_flags,
                (const wchar_t*)source,
                source_length,
                (wchar_t*)destination,
                destination_length);

    }

    export extern "C" bool __stdcall enumerate_system_locales_a(locale_callback_a callback,
        uint flags);

    export extern "C" bool __stdcall enumerate_system_locales_w(locale_callback_w callback,
        uint flags);

    export  inline bool enumerate_system_locales(locale_callback callback,
        uint flags)
    {
        return enumerate_system_locales_w((locale_callback_w)callback,
            flags);
    }

    export extern "C" bool __stdcall enumerate_system_codepages_a(codepage_callback_a callback,
        uint flags);

    export extern "C" bool __stdcall enumerate_system_codepages_w(codepage_callback_w callback,
        uint flags);

    export  inline bool enumerate_system_codepages(codepage_callback callback,
        uint flags)
    {
        return enumerate_system_codepages_w((codepage_callback_w)callback,
            flags);
    }

    //*** registry

    export extern "C" int __stdcall close_registry_key(handle key);

    export extern "C" int __stdcall connect_registry_a(const char* machine_name,
        handle key,
        handle * result);

    export extern "C" int __stdcall connect_registry_w(const wchar_t* machine_name,
        handle key,
        handle * result);

    export template<class character>
        inline int connect_registry(const character* machine_name,
            handle key,
            handle* result)
    {
        if (sizeof(character) == 1)
            return connect_registry_a((const char*)machine_name,
                key,
                result);
        else
            return connect_registry_w((const wchar_t*)machine_name,
                key,
                result);
    }

    export extern "C" int __stdcall create_registry_key_old_a(handle key,
        const char* subkey,
        handle * result);

    export extern "C" int __stdcall create_registry_key_old_w(handle key,
        const wchar_t* subkey,
        handle * result);

    export template<class character>
        inline int create_registry_key_old(handle key,
            const character* subkey,
            handle* result)
    {
        if (sizeof(character) == 1)
            return create_registry_key_old_a(key,
                (const char*)subkey,
                result);
        else
            return create_registry_key_old_w(key,
                (const wchar_t*)subkey,
                result);
    }

    export extern "C" int __stdcall create_registry_key_a(handle key,
        const char* subkey,
        uint reserved,
        const char* key_class,
        uint options,
        uint desired,
        const security_attributes * security,
        handle * result,
        uint * disposition);

    export extern "C" int __stdcall create_registry_key_w(handle key,
        const wchar_t* subkey,
        uint reserved,
        const wchar_t* key_class,
        uint options,
        uint desired,
        const security_attributes * security,
        handle * result,
        uint * disposition);

    export template<class character>
        inline int create_registry_key(handle key,
            const character* subkey,
            uint reserved,
            const character* key_class,
            uint options,
            uint desired,
            const security_attributes* security,
            handle* result,
            uint* disposition)
    {
        if (sizeof(character) == 1)
            return create_registry_key_a(key,
                (const char*)subkey,
                reserved,
                (const char*)key_class,
                options,
                desired,
                security,
                result,
                disposition);
        else
            return create_registry_key_w(key,
                (const wchar_t*)subkey,
                reserved,
                (const wchar_t*)key_class,
                options,
                desired,
                security,
                result,
                disposition);

    }

    export extern "C" int __stdcall open_registry_key_old_a(handle key,
        const char* subkey,
        handle * result);

    export extern "C" int __stdcall open_registry_key_old_w(handle key,
        const character * subkey,
        handle * result);

    export template<class character>
        inline int open_registry_key_old(handle key,
            const character* subkey,
            handle* result)
    {
        if (sizeof(character) == 1)
            return open_registry_key_old_a(key,
                (const char*)subkey,
                result);
        else
            return open_registry_key_old_w(key,
                (const wchar_t*)subkey,
                result);
    }

    export extern "C" int __stdcall open_registry_key_a(handle key,
        const char* subkey,
        uint options,
        uint desired,
        handle * result);

    export extern "C" int __stdcall open_registry_key_w(handle key,
        const wchar_t* subkey,
        uint options,
        uint desired,
        handle * result);

    export template<class character>
        inline int open_registry_key(handle key,
            const character* subkey,
            uint options,
            uint desired,
            handle* result)
    {
        if (sizeof(character) == 1)
            return open_registry_key_a(key,
                (const char*)subkey,
                options,
                desired,
                result);
        else
            return open_registry_key_w(key,
                (const wchar_t*)subkey,
                options,
                desired,
                result);
    }

    export extern "C" int __stdcall delete_registry_key_a(handle key,
        const char* subkey);

    export extern "C" int __stdcall delete_registry_key_w(handle key,
        const wchar_t* subkey);

    export template<class character>
        inline int delete_registry_key(handle key,
            const character* subkey)
    {
        if (sizeof(character) == 1)
            return delete_registry_key_a(key,
                (const char*)subkey);
        else
            return delete_registry_key_w(key,
                (const wchar_t*)subkey);
    }

    export extern "C" int __stdcall delete_registry_value_a(handle key,
        const char* value_name);

    export extern "C" int __stdcall delete_registry_value_w(handle key,
        const wchar_t* value_name);

    export template<class character>
        inline int delete_registry_value(handle key,
            const character* value_name)
    {
        if (sizeof(character) == 1)
            return delete_registry_value_a(key,
                (const char*)value_name);
        else
            return delete_registry_value_w(key,
                (const wchar_t*)value_name);

    }

    export extern "C" int __stdcall enumerate_registry_keys_old_a(handle key,
        uint index,
        const char* name,
        uint size);

    export extern "C" int __stdcall enumerate_registry_keys_old_w(handle key,
        uint index,
        const wchar_t* name,
        uint size);

    export template<class character>
        inline int enumerate_registry_keys_old(handle key,
            uint index,
            const character* name,
            uint size)
    {
        if (sizeof(character) == 1)
            return enumerate_registry_keys_old_a(key,
                index,
                (const char*)name,
                size);
        else
            return enumerate_registry_keys_old_w(key,
                index,
                (const wchar_t*)name,
                size);
    }

    export extern "C" int __stdcall enumerate_registry_keys_a(handle key,
        uint index,
        char* name,
        uint * length,
        uint * reserved,
        char* key_class,
        uint * class_length,
        file_time * file_time_last_write);

    export extern "C" int __stdcall enumerate_registry_keys_w(handle key,
        uint index,
        wchar_t* name,
        uint * length,
        uint * reserved,
        wchar_t* key_class,
        uint * class_length,
        file_time * file_time_last_write);

    export template<class character>
        inline int enumerate_registry_keys(handle key,
            uint index,
            character* name,
            uint* length,
            uint* reserved,
            character* key_class,
            uint* class_length,
            file_time* file_time_last_write)
    {
        if (sizeof(character) == 1)
            return enumerate_registry_keys_a(key,
                index,
                (char*)name,
                length,
                reserved,
                (char*)key_class,
                class_length,
                file_time_last_write);
        else
            return enumerate_registry_keys_w(key,
                index,
                (wchar_t*)name,
                length,
                reserved,
                (wchar_t*)key_class,
                class_length,
                file_time_last_write);
    }

    export extern "C" int __stdcall enumerate_registry_values_a(handle key,
        uint index,
        char* value_name,
        uint * value_name_length,
        uint * reserved,
        uint * type,
        byte * data,
        uint * data_length);

    export extern "C" int __stdcall enumerate_registry_values_w(handle key,
        uint index,
        wchar_t* value_name,
        uint * value_name_length,
        uint * reserved,
        uint * type,
        byte * data,
        uint * data_length);

    export template<class character>
        inline int enumerate_registry_values(handle key,
            uint index,
            character* value_name,
            uint* value_name_length,
            uint* reserved,
            uint* type,
            byte* data,
            uint* data_length)
    {
        if (sizeof(character) == 1)
            return enumerate_registry_values_a(key,
                index,
                (char*)value_name,
                value_name_length,
                reserved,
                type,
                data,
                data_length);
        else
            return enumerate_registry_values_w(key,
                index,
                (wchar_t*)value_name,
                value_name_length,
                reserved,
                type,
                data,
                data_length);
    }

    export extern "C" int __stdcall flush_registry_key(handle key);

    export extern "C" int __stdcall get_registry_key_security(handle key,
        uint information_type,
        descriptor * security_descriptor,
        uint * security_descriptor_length);

    export extern "C" int __stdcall load_registry_key_a(handle key,
        const char* subkey,
        const char* file);

    export extern "C" int __stdcall load_registry_key_w(handle key,
        const wchar_t* subkey,
        const wchar_t* file);

    export template<class character>
        inline int load_registry_key(handle key,
            const character* subkey,
            const character* file)
    {
        if (sizeof(character) == 1)
            return load_registry_key_a(key,
                (const char*)subkey,
                (const char*)file);
        else
            return load_registry_key_w(key,
                (const wchar_t*)subkey,
                (const wchar_t*)file);
    }

    export extern "C" int __stdcall notify_change_registry_key_value(handle key,
        bool watch,
        uint filter,
        handle file,
        bool asynchronous);

    export extern "C" int __stdcall query_registry_key_information_a(handle key,
        char* key_class,
        uint * class_length,
        uint * reserved,
        uint * subkeys,
        uint * maximum_subkey_length,
        uint * maximum_class_length,
        uint * number_values,
        uint * maximum_value_name_length,
        uint * maximum_value_length,
        uint * security_descriptor_length,
        file_time * file_time_last_write);

    export extern "C" int __stdcall query_registry_key_information_w(handle key,
        wchar_t* key_class,
        uint * class_length,
        uint * reserved,
        uint * subkeys,
        uint * maximum_subkey_length,
        uint * maximum_class_length,
        uint * number_values,
        uint * maximum_value_name_length,
        uint * maximum_value_length,
        uint * security_descriptor_length,
        file_time * file_time_last_write);

    export template<class character>
        inline int query_registry_key_information(handle key,
            character* key_class,
            uint* class_length,
            uint* reserved,
            uint* subkeys,
            uint* maximum_subkey_length,
            uint* maximum_class_length,
            uint* number_values,
            uint* maximum_value_name_length,
            uint* maximum_value_length,
            uint* security_descriptor_length,
            file_time* file_time_last_write)
    {
        if (sizeof(character) == 1)
            return query_registry_key_information_a(key,
                (char*)key_class,
                class_length,
                reserved,
                subkeys,
                maximum_subkey_length,
                maximum_class_length,
                number_values,
                maximum_value_name_length,
                maximum_value_length,
                security_descriptor_length,
                file_time_last_write);
        else
            return query_registry_key_information_w(key,
                (wchar_t*)key_class,
                class_length,
                reserved,
                subkeys,
                maximum_subkey_length,
                maximum_class_length,
                number_values,
                maximum_value_name_length,
                maximum_value_length,
                security_descriptor_length,
                file_time_last_write);
    }

    export extern "C" int __stdcall query_registry_value_old_a(handle key,
        const char* subkey,
        char* value,
        int* value_length);

    export extern "C" int __stdcall query_registry_value_old_w(handle key,
        const wchar_t* subkey,
        wchar_t* value,
        int* value_length);

    export template<class character>
        inline int query_registry_value_old(handle key,
            const character* subkey,
            character* value,
            int* value_length)
    {
        if (sizeof(character) == 1)
            return query_registry_value_old_a(key,
                (const char*)subkey,
                (char*)value,
                value_length);
        else
            return query_registry_value_old_w(key,
                (const wchar_t*)subkey,
                (wchar_t*)value,
                value_length);
    }

    export extern "C" int __stdcall query_registry_value_a(handle key,
        const char* value_name,
        uint * reserved,
        uint * type,
        byte * data,
        uint * data_length);

    export extern "C" int __stdcall query_registry_value_w(handle key,
        const wchar_t* value_name,
        uint * reserved,
        uint * type,
        byte * data,
        uint * data_length);

    export template<class character>
        inline int query_registry_value(handle key,
            const character* value_name,
            uint* reserved,
            uint* type,
            byte* data,
            uint* data_length)
    {
        if (sizeof(character) == 1)
            return query_registry_value_a(key,
                (const char*)value_name,
                reserved,
                type,
                data,
                data_length);
        else
            return query_registry_value_w(key,
                (const wchar_t*)value_name,
                reserved,
                type,
                data,
                data_length);
    }

    export extern "C" int __stdcall query_multiple_registry_values_a(handle key,
        value_entry<char> *value_entry_list,
        uint values,
        char* value_buffer,
        uint * total_size);

    export extern "C" int __stdcall query_multiple_registry_values_w(handle key,
        value_entry<wchar_t> *value_entry_list,
        uint values,
        wchar_t* value_buffer,
        uint * total_size);

    export template<class character>
        inline int query_multiple_registry_values(handle key,
            value_entry<char>* value_entry_list,
            uint values,
            character* value_buffer,
            uint* total_size)
    {
        if (sizeof(character) == 1)
            return query_multiple_registry_values_a(key,
                (value_entry<char>*) value_entry_list,
                values,
                (char*)value_buffer,
                total_size);
        else
            return query_multiple_registry_values_w(key,
                (value_entry<wchar_t>*) value_entry_list,
                values,
                (wchar_t*)value_buffer,
                total_size);
    }

    export extern "C" int __stdcall replace_registry_key_a(handle key,
        const char* subkey,
        const char* new_text,
        const char* old_text);

    export extern "C" int __stdcall replace_registry_key_w(handle key,
        const wchar_t* subkey,
        const wchar_t* new_text,
        const wchar_t* old_text);

    export template<class character>
        inline int replace_registry_key(handle key,
            const character* subkey,
            const character* new_text,
            const character* old_text)
    {
        if (sizeof(character) == 1)
            return replace_registry_key_a(key,
                (const char*)subkey,
                (const char*)new_text,
                (const char*)old_text);
        else
            return replace_registry_key_w(key,
                (const wchar_t*)subkey,
                (const wchar_t*)new_text,
                (const wchar_t*)old_text);
    }

    export extern "C" int __stdcall restore_registry_key_a(handle key,
        const char* file,
        uint flags);

    export extern "C" int __stdcall restore_registry_key_w(handle key,
        const wchar_t* file,
        uint flags);

    export template<class character>
        inline int restore_registry_key(handle key,
            const character* file,
            uint flags)
    {
        if (sizeof(character) == 1)
            return restore_registry_key_a(key,
                (const char*)file,
                flags);
        else
            return restore_registry_key_w(key,
                (const wchar_t*)file,
                flags);
    }

    export extern "C" int __stdcall save_registry_key_a(handle key,
        const char* file,
        security_attributes * security);

    export extern "C" int __stdcall save_registry_key_w(handle key,
        const wchar_t* file,
        security_attributes * security);

    export template<class character>
        inline int save_registry_key(handle key,
            const character* file,
            security_attributes* security)
    {
        if (sizeof(character) == 1)
            return save_registry_key_a(key,
                (const char*)file,
                security);
        else
            return save_registry_key_w(key,
                (const wchar_t*)file,
                security);
    }

    export extern "C" int __stdcall set_registry_key_security(handle key,
        uint information_set,
        descriptor * key_descriptor);

    export extern "C" int __stdcall set_registry_value_old_a(handle key,
        const char* subkey,
        uint type,
        const char* data,
        uint data_length);

    export extern "C" int __stdcall set_registry_value_old_w(handle key,
        const wchar_t* subkey,
        uint type,
        const wchar_t* data,
        uint data_length);

    export template<class character>
        inline int set_registry_value_old(handle key,
            const character* subkey,
            uint type,
            const character* data,
            uint data_length)
    {
        if (sizeof(character) == 1)
            return set_registry_value_old_a(key,
                (const char*)subkey,
                type,
                (const char*)data,
                data_length);
        else
            return set_registry_value_old_w(key,
                (const wchar_t*)subkey,
                type,
                (const wchar_t*)data,
                data_length);
    }

    export extern "C" int __stdcall set_registry_value_a(handle key,
        const char* value_name,
        uint reserved,
        uint type,
        const byte * data,
        uint data_length);

    export extern "C" int __stdcall set_registry_value_w(handle key,
        const wchar_t* value_name,
        uint reserved,
        uint type,
        const byte * data,
        uint data_length);

    export template<class character>
        inline int set_registry_value(handle key,
            const character* value_name,
            uint reserved,
            uint type,
            const byte* data,
            uint data_length)
    {
        if (sizeof(character) == 1)
            return set_registry_value_a(key,
                (const char*)value_name,
                reserved,
                type,
                data,
                data_length);
        else
            return set_registry_value_w(key,
                (const wchar_t*)value_name,
                reserved,
                type,
                data,
                data_length);


    }

    export extern "C" int __stdcall unload_registry_key_a(handle key,
        const char* subkey);

    export extern "C" int __stdcall unload_registry_key_w(handle key,
        const wchar_t* subkey);

    export template<class character>
        inline int unload_registry_key(handle key,
            const character* subkey)
    {
        if (sizeof(character) == 1)
            return unload_registry_key_a(key,
                (const char*)subkey);
        else
            return unload_registry_key_w(key,
                (const char*)subkey);
    }

    // new stuff

    export  enum { maximum_processors = 64 };

    export  enum non_uniform_preferred { no_preferred_node = -1 };

    export extern "C" bool __stdcall get_process_affinity_mask(handle process,
        ulong * process_affinity_mask,
        ulong * system_affinity_mask);

    export extern "C" bool __stdcall set_process_affinity_mask(handle process,
        ulong process_affinity_mask);

    export extern "C" ulong __stdcall set_thread_affinity_mask(handle thread,
        ulong thread_affinity_mask);

    export extern "C" uint __stdcall set_thread_ideal_processor(handle thread,
        uint ideal_processor);

    export extern "C" uint __stdcall get_current_processor_number();

    export extern "C" bool __stdcall set_process_priority_iplusplus(handle process,
        bool disable_priority_iplusplus);

    export extern "C" bool __stdcall get_process_priority_iplusplus(handle process,
        bool* disable_priority_iplusplus);

    export extern "C" bool __stdcall set_thread_priority_iplusplus(handle thread,
        bool disable_priority_iplusplus);

    export extern "C" bool __stdcall get_thread_priority_iplusplus(handle thread,
        bool* disable_priority_iplusplus);

    export extern "C" bool __stdcall is_system_resume_automatic();

    export extern "C" bool __stdcall get_thread_input_output_pending_flag(handle thread,
        bool* input_output_is_pending);

    export struct execution_state
    {
        enum
        {
            system_required = 0x00000001,
            display_required = 0x00000002,
            user_present = 0x00000004,
            away_mode_required = 0x00000040,
            continuous = 0x80000000
        };
    };

    export extern "C" uint __stdcall set_thread_execution_state(uint flags);

    export extern "C" void* __stdcall allocate_memory_non_uniform(handle process,
        void* address,
        ulong size,
        uint allocation_type,
        uint protect,
        uint preferred);

    export extern "C" handle __stdcall create_file_mapping_non_uniform(handle file,
        security_attributes * attributes,
        uint protect,
        uint maximum_size_high,
        uint maximum_size_low,
        const character * name,
        uint preferred);

    export extern "C" void* __stdcall map_view_of_file_non_uniform(handle file_mapping_object,
        uint desired_access,
        uint file_offset_high,
        uint file_offset_low,
        ulong number_of_bytes_to_map,
        void* base_address,
        uint preferred);

    export extern "C" bool __stdcall get_non_uniform_highest_node_number(uint * highest_node_number);

    export extern "C" bool __stdcall get_non_uniform_processor_node(byte processor,
        byte * node_number);

    export extern "C" bool __stdcall get_non_uniform_node_processor_mask(byte node,
        ulong * processor_mask);

    export extern "C" bool __stdcall get_non_uniform_available_memory_node(byte node,
        ulong * available_bytes);

    export extern "C" bool __stdcall get_non_uniform_proximity_node(ulong proximity_identity,
        byte * node_number);

    // GDI

      //*** device contexts

    export extern "C" int __stdcall set_image_color_mode(handle device,
        int flags_enable);

    export extern "C" bool __stdcall check_colors_in_gamut(handle device,
        uint * rgb_array,
        void* buffer,
        uint count);

    export extern "C" handle __stdcall get_color_space(handle device);


    export extern "C" bool __stdcall get_logical_color_space_a(handle space,
        logical_color_space<char> *color_space,
        uint size);

    export extern "C" bool __stdcall get_logical_color_space_w(handle space,
        logical_color_space<wchar_t> *color_space,
        uint size);

    export template<class character>
        inline bool get_logical_color_space(handle space,
            logical_color_space<char>* color_space,
            uint size)
    {
        if (sizeof(character) == 1)
            return get_logical_color_space_a(space,
                (logical_color_space<char>*) color_space,
                size);
        else
            return get_logical_color_space_w(space,
                (logical_color_space<wchar_t>*) color_space,
                size);
    }

    export extern "C" handle __stdcall create_color_space_a(logical_color_space<char> *color_space);

    export extern "C" handle __stdcall create_color_space_w(logical_color_space<wchar_t> *color_space);

    export template<class character>
        inline handle create_color_space(logical_color_space<character>* color_space)
    {
        if (sizeof(character) == 1)
            return create_color_space_a((logical_color_space<char>*) color_space);
        else
            return create_color_space_w((logical_color_space<wchar_t>*) color_space);

    }

    export extern "C" handle __stdcall set_color_space(handle device,
        handle space);

    export extern "C" bool __stdcall delete_color_space(handle space);

    export extern "C" bool __stdcall get_image_color_profile_a(handle device,
        uint * size,
        char* buffer);

    export extern "C" bool __stdcall get_image_color_profile_w(handle device,
        uint * size,
        wchar_t* buffer);

    export template<class character>
        inline bool get_image_color_profile(handle device,
            uint* size,
            character* buffer)
    {
        if (sizeof(character) == 1)
            return get_image_color_profile_a(device,
                size,
                (char*)buffer);
        else
            return get_image_color_profile_w(device,
                size,
                (wchar_t*)buffer);
    }

    export extern "C" bool __stdcall set_image_color_profile_a(handle device,
        const char* path_name);

    export extern "C" bool __stdcall set_image_color_profile_w(handle device,
        const wchar_t* path_name);

    export template<class character>
        inline bool set_image_color_profile(handle device,
            const character* path_name)
    {
        if (sizeof(character) == 1)
            return set_image_color_profile_a(device,
                (const char*)path_name);
        else
            return set_image_color_profile_w(device,
                (const wchar_t*)path_name);
    }


    export extern "C" bool __stdcall get_device_gamma_ramp(handle device,
        void* gamma);

    export extern "C" bool __stdcall set_device_gamma_ramp(handle device,
        void* gamma);

    export extern "C" bool __stdcall match_color_to_target(handle device,
        handle target,
        uint color_space_match);

    export extern "C" int __stdcall enumerate_image_color_profiles(handle device,
        enumerate_image_color callback,
        parameter parameter_enumerate);

    export extern "C" bool __stdcall color_correct_palette(handle device,
        handle palette,
        uint start,
        uint entries);

    export extern "C" bool __stdcall gradient_fill(handle device,
        trivertex * trivertex_array,
        uint vertices,
        void* mesh,
        uint elements,
        uint mode);

    export extern "C" uint __stdcall get_font_language_information(handle device);

    export extern "C" uint __stdcall get_fontunicode_ranges(handle device,
        glyph_set * glyph_set_get);

    export extern "C" uint __stdcall get_glyph_indices_a(handle device,
        const char* string,
        int length,
        part * glyphs,
        uint flags);

    export extern "C" uint __stdcall get_glyph_indices_w(handle device,
        const wchar_t* string,
        int length,
        part * glyphs,
        uint flags);

    export template<class character>
        inline uint  get_glyph_indices(handle device,
            const character* string,
            int length,
            part* glyphs,
            uint flags)
    {
        if (sizeof(character) == 1)
            return get_glyph_indices_a(device,
                (const char*)string,
                length,
                glyphs,
                flags);
        else
            return get_glyph_indices_w(device,
                (const wchar_t*)string,
                length,
                glyphs,
                flags);
    }

    export extern "C" uint __stdcall get_device_context_pen_color(handle device);

    export extern "C" uint __stdcall set_device_context_pen_color(handle device,
        uint color_pen);

    export extern "C" uint __stdcall get_device_context_brush_color(handle device);

    export extern "C" uint __stdcall set_device_context_brush_color(handle device,
        uint color_brush);

    export extern "C" bool __stdcall draw_caption(handle window,
        handle device,
        const irectangle * draw,
        uint flags);

    export extern "C" handle __stdcall create_memory_device_context(handle device = 0);

    export extern "C" handle __stdcall create_device_context_a(const char* driver,
        const char* device,
        const char* output,
        const device_mode<char> *initial_device_mode);

    export extern "C" handle __stdcall create_device_context_w(const wchar_t* driver,
        const wchar_t* device,
        const wchar_t* output,
        const device_mode<wchar_t> *initial_device_mode);

    export template<class character>
        inline handle  create_device_context(const character* driver,
            const character* device,
            const character* output,
            const device_mode<character>* initial_device_mode)
    {
        if (sizeof(character) == 1)
            return create_device_context_a((const char*)driver,
                (const char*)device,
                (const char*)output,
                (const device_mode<char>*) initial_device_mode);
        else
            return create_device_context_w((const wchar_t*)driver,
                (const wchar_t*)device,
                (const wchar_t*)output,
                (const device_mode<wchar_t>*) initial_device_mode);
    }

    export extern "C" handle __stdcall create_informational_device_context_a(const char* driver,
        const char* device,
        const char* output,
        const device_mode<char> *initial_device_mode);

    export extern "C" handle __stdcall create_informational_device_context_w(const wchar_t* driver,
        const wchar_t* device,
        const wchar_t* output,
        const device_mode<wchar_t> *initial_device_mode);

    export template<class character>
        inline handle create_informational_device_context(const character* driver,
            const character* device,
            const character* output,
            const device_mode<character>* initial_device_mode)
    {
        if (sizeof(character) == 1)
            return create_informational_device_context_a((const char*)driver,
                (const char*)device,
                (const char*)output,
                (const device_mode<char>*) initial_device_mode);
        else
            return create_informational_device_context_w((const wchar_t*)driver,
                (const wchar_t*)device,
                (const wchar_t*)output,
                (const device_mode<wchar_t>*) initial_device_mode);
    }

    export extern "C" handle __stdcall get_device_context(handle window);

    export extern "C" handle __stdcall get_device_context_extended(handle window,
        handle region,
        uint flags);

    export extern "C" handle __stdcall get_window_device_context(handle window);

    export extern "C" int __stdcall release_device_context(handle window,
        handle device);

    export extern "C" handle __stdcall begin_paint(handle window,
        paint * paint_structure);

    export extern "C" bool __stdcall end_paint(handle window,
        const paint * paint_structure);

    export extern "C" bool __stdcall delete_device_context(handle device);

    export extern "C" bool __stdcall draw_arc(handle device,
        int left,
        int top,
        int right,
        int bottom,
        int start_x,
        int start_y,
        int end_x,
        int end_y);

    export extern "C" bool __stdcall draw_arc_to(handle device,
        int left,
        int top,
        int right,
        int bottom,
        int start_x,
        int start_y,
        int end_x,
        int end_y);

    export extern "C" bool __stdcall draw_angle_arc(handle device,
        int center_x,
        int center_y,
        uint radius,
        float start,
        float sweep);

    export extern "C" int __stdcall get_arc_direction(handle device);

    export extern "C" int __stdcall set_arc_direction(handle device,
        int direction);

    export extern "C" bool __stdcall get_aspect_ratio_filter(handle device,
        idimensions * aspect);

    export extern "C" bool __stdcall bit_block_transfer(handle device,
        int x,
        int y,
        int width,
        int height,
        handle source,
        int left,
        int top,
        uint raster);

    export extern "C" bool __stdcall masked_bit_block_transfer(handle device,
        int destination_left,
        int destination_top,
        int width,
        int height,
        handle source,
        int source_left,
        int source_top,
        handle mask,
        int mask_offset_x,
        int mask_offset_y,
        uint raster);

    export extern "C" bool __stdcall parallelogram_bit_block_transfer(handle device,
        const ipoint * vertices,
        handle source,
        int source_left,
        int source_top,
        int width,
        int height,
        handle mask_bitmap,
        int mask_offset_x,
        int mask_offset_y);

    export extern "C" bool __stdcall pattern_bit_block_transfer(handle device,
        int left,
        int top,
        int width,
        int height,
        uint raster_operation);

    export extern "C" bool __stdcall stretch_bit_block_transfer(handle device,
        int destination_left,
        int destination_top,
        int destination_width,
        int destination_height,
        handle source,
        int source_left,
        int source_top,
        int source_width,
        int source_height,
        uint raster_operation);

    export extern "C" int __stdcall get_stretch_bit_block_mode(handle device);

    export extern "C" int __stdcall set_stretch_bit_block_mode(handle device,
        int mode);

    export extern "C" uint __stdcall get_bounds_rectangle(handle device,
        irectangle * bounds,
        uint flags);

    export extern "C" uint __stdcall set_bounds_rectangle(handle device,
        const irectangle * bounds,
        uint flags);

    export extern "C" bool __stdcall get_brush_origin(handle device,
        ipoint * origin);

    export extern "C" bool __stdcall set_brush_origin(handle device,
        int x,
        int y,
        ipoint * previous);

    export extern "C" bool __stdcall cancel_device_context(handle device);

    export extern "C" int __stdcall get_device_capabilities(handle device,
        int index);

    export extern "C" bool __stdcall get_character_widths(handle device,
        uint first,
        uint last,
        int* widths);

    export extern "C" bool __stdcall get_decimal_character_widths(handle device,
        uint first,
        uint last,
        float* widths);

    export extern "C" bool __stdcall get_character_abc_widths(handle device,
        uint first,
        uint last,
        abc * abc_widths);

    export extern "C" bool __stdcall get_decimal_character_abc_widths(handle device,
        uint first,
        uint last,
        decimal_abc * abc_widths);

    export extern "C" bool __stdcall draw_chord(handle device,
        int left,
        int top,
        int right,
        int bottom,
        int radial1x,
        int radial1y,
        int radial2x,
        int radial2y);

    export extern "C" int __stdcall get_clip_box(handle device,
        irectangle * clip);

    export extern "C" bool __stdcall select_clipping_path(handle device,
        int mode);

    export extern "C" int __stdcall exclude_clipping_rectangle(handle device,
        int left,
        int top,
        int right,
        int bottom);

    export extern "C" int __stdcall intersect_clipping_rectangle(handle device,
        int left,
        int top,
        int right,
        int bottom);

    export extern "C" int __stdcall offset_clipping_region(handle device,
        int offset_x,
        int offset_y);

    export extern "C" int __stdcall get_clipping_region(handle device,
        handle region);

    export extern "C" int __stdcall select_clipping_region(handle device,
        handle region);

    export extern "C" int __stdcall extended_select_clipping_region(handle device,
        handle region,
        int mode);

    export extern "C" bool __stdcall get_color_adjustment(handle device,
        color_adjustment * adjustment);

    export extern "C" bool __stdcall set_color_adjustment(handle device,
        const color_adjustment * adjustment);

    export extern "C" uint __stdcall get_background_color(handle device);

    export extern "C" uint __stdcall set_background_color(handle device,
        uint color_set);

    export extern "C" bool __stdcall update_colors(handle device);

    export extern "C" bool __stdcall gdi_comment(handle device,
        uint size,
        const byte * comment);

    export extern "C" bool __stdcall get_device_context_origin(handle device,
        ipoint * origin);

    export extern "C" int __stdcall stretch_device_independent_bits(handle device,
        int destination_left,
        int destination_top,
        int destination_width,
        int destination_height,
        int source_left,
        int source_top,
        int source_width,
        int source_height,
        const void* data,
        const bitmap_information * information,
        uint usage,
        uint raster_operation);

    export extern "C" int __stdcall set_device_independent_bits_to_device(handle device,
        int destination_left,
        int destination_top,
        uint width,
        uint height,
        int source_bottom_left_x,
        int source_bottom_left_y,
        uint start,
        uint lines,
        const void* data,
        const bitmap_information * information,
        uint usage);

    export extern "C" uint __stdcall get_device_independent_bitmap_color_table(handle device,
        uint start,
        uint entries,
        uint * colors);

    export extern "C" uint __stdcall set_device_independent_bitmap_color_table(handle device,
        uint start,
        uint entries,
        const uint * colors);

    export extern "C" int __stdcall start_document_a(handle device,
        const document_information<char> *information);

    export extern "C" int __stdcall start_document_w(handle device,
        const document_information<wchar_t> *information);

    export template<class character>
        inline int start_document(handle device,
            const document_information<character>* information)
    {
        if (sizeof(character) == 1)
            return start_document_a(device,
                (const document_information<char>*) information);
        else
            return start_document_w(device,
                (const document_information<wchar_t>*) information);

    }

    export extern "C" int __stdcall end_document(handle device);

    export extern "C" int __stdcall start_page(handle device);

    export extern "C" int __stdcall end_page(handle device);

    export extern "C" int __stdcall cancel_document(handle device);

    export extern "C" int __stdcall set_cancellation_procedure(handle device,
        cancel_document_callback cancellation_callback);

    export extern "C" bool __stdcall device_points_to_logical_points(handle device,
        ipoint * points_to_convert,
        int points);

    export extern "C" bool __stdcall draw_edge(handle device,
        const irectangle * bounds,
        uint type,
        uint flags);

    export extern "C" bool __stdcall draw_frame_control(handle device,
        const irectangle * frame,
        uint type,
        uint state);

    export extern "C" bool __stdcall draw_ellipse(handle device,
        int left,
        int top,
        int right,
        int bottom);

    export extern "C" int __stdcall escape_a(handle device,
        int escape,
        int input_buffer_length,
        const char* input_buffer,
        void* output_buffer);

    export extern "C" int __stdcall escape_w(handle device,
        int escape,
        int input_buffer_length,
        const wchar_t* input_buffer,
        void* output_buffer);

    export template<class character>
        inline int escape(handle device,
            int escape,
            int input_buffer_length,
            const character* input_buffer,
            void* output_buffer)
    {
        if (sizeof(character) == 1)
            return escape_a(device,
                escape,
                input_buffer_length,
                (const char*)input_buffer,
                output_buffer);
        else
            return escape_w(device,
                escape,
                input_buffer_length,
                (const wchar_t*)input_buffer,
                output_buffer);
    }

    export extern "C" int __stdcall extended_escape_a(handle device,
        int escape,
        int input_buffer_length,
        const char* input_buffer,
        int output_buffer_length,
        char* output_buffer);

    export extern "C" int __stdcall extended_escape_w(handle device,
        int escape,
        int input_buffer_length,
        const wchar_t* input_buffer,
        int output_buffer_length,
        wchar_t* output_buffer);

    export template<class character>
        inline int extended_escape(handle device,
            int escape,
            int input_buffer_length,
            const character* input_buffer,
            int output_buffer_length,
            character* output_buffer)
    {
        if (sizeof(character) == 1)
            return extended_escape_a(device,
                escape,
                input_buffer_length,
                (const char*)input_buffer,
                output_buffer_length,
                (char*)output_buffer);
        else
            return extended_escape_w(device,
                escape,
                input_buffer_length,
                (const wchar_t*)input_buffer,
                output_buffer_length,
                (wchar_t*)output_buffer);
    }

    export extern "C" int __stdcall draw_escape_a(handle device,
        int escape,
        int length,
        const char* buffer);

    export extern "C" int __stdcall draw_escape_w(handle device,
        int escape,
        int length,
        const wchar_t* buffer);

    export template<class character>
        inline int draw_escape(handle device,
            int escape,
            int length,
            const character* buffer)
    {
        if (sizeof(character) == 1)
            return draw_escape_a(device,
                escape,
                length,
                (const char*)buffer);
        else
            return draw_escape_w(device,
                escape,
                length,
                (const wchar_t*)buffer);
    }

    export extern "C" bool __stdcall close_figure(handle device);

    export extern "C" bool __stdcall flood_fill(handle device,
        int start_x,
        int start_y,
        uint color_fill);

    export extern "C" bool __stdcall extended_flood_fill(handle device,
        int start_x,
        int start_y,
        uint color_fill,
        uint fill_type);

    export extern "C" uint __stdcall get_font_data(handle device,
        uint metric,
        uint offset,
        void* buffer,
        uint length);

    export extern "C" int __stdcall enumerate_font_families_old_a(handle device,
        const char* family,
        enumerate_font_simple callback,
        parameter parameter_enumerate);

    export extern "C" int __stdcall enumerate_font_families_old_w(handle device,
        const wchar_t* family,
        enumerate_font_simple callback,
        parameter parameter_enumerate);

    export template<class character>
        inline int enumerate_font_families_old(handle device,
            const character* family,
            enumerate_font_simple callback,
            parameter parameter_enumerate)
    {
        if (sizeof(character) == 1)
            return enumerate_font_families_old_a(device,
                (const char*)family,
                callback,
                parameter_enumerate);
        else
            return enumerate_font_families_old_w(device,
                (const wchar_t*)family,
                callback,
                parameter_enumerate);
    }

    export extern "C" int __stdcall enumerate_font_families_a(handle device,
        const logical_font<char> *font,
        enumerate_font callback,
        parameter parameter_enumerate,
        uint flags);

    export extern "C" int __stdcall enumerate_font_families_w(handle device,
        const logical_font<wchar_t> *font,
        enumerate_font callback,
        parameter parameter_enumerate,
        uint flags);

    export template<class character>
        inline int enumerate_font_families(handle device,
            const logical_font<character>* font,
            enumerate_font callback,
            parameter parameter_enumerate,
            uint flags)
    {
        if (sizeof(character) == 1)
            return enumerate_font_families_a(device,
                (const logical_font<char>*) font,
                callback,
                parameter_enumerate,
                flags);
        else
            return enumerate_font_families_w(device,
                (const logical_font<wchar_t>*) font,
                callback,
                parameter_enumerate,
                flags);
    }

    export extern "C" int __stdcall enumerate_fonts_a(handle device,
        const char* face_name,
        enumerate_font_simple callback,
        parameter parameter_enumerate);

    export extern "C" int __stdcall enumerate_fonts_w(handle device,
        const wchar_t* face_name,
        enumerate_font_simple callback,
        parameter parameter_enumerate);

    export template<class character>
        inline int enumerate_fonts(handle device,
            const character* face_name,
            enumerate_font_simple callback,
            parameter parameter_enumerate)
    {
        if (sizeof(character) == 1)
            return enumerate_fonts_a(device,
                (const char*)face_name,
                callback,
                parameter_enumerate);
        else
            return enumerate_fonts_w(device,
                (const wchar_t*)face_name,
                callback,
                parameter_enumerate);
    }

    export extern "C"  bool __stdcall draw_focus_rectangle(handle device,
        const irectangle * draw);

    export extern "C" uint __stdcall get_glyph_outline(handle device,
        uint codeipoint,
        uint format,
        glyph_metric * metrics,
        uint length,
        void* buffer,
        const imatrix * transform);

    export extern "C" uint __stdcall get__mode(handle device);

    export extern "C" uint __stdcall set__mode(handle device,
        uint mode);

    export extern "C" bool __stdcall draw_icon(handle device,
        int x,
        int y,
        handle icon);

    export extern "C" bool __stdcall draw_icon_extended(handle device,
        int x,
        int y,
        handle icon,
        int width,
        int height,
        uint step,
        handle brush,
        uint flags);

    export extern "C" bool __stdcall ipoint_visible(handle device,
        int x,
        int y);

    export extern "C" bool __stdcall rectangle_visible(handle device,
        const irectangle * test);

    export extern "C" uint __stdcall get_kerning_pairs(handle device,
        uint pairs,
        close_pair * close_pairs);

    export extern "C" bool __stdcall draw_line_to(handle device,
        int x,
        int y);

    export extern "C" bool __stdcall plot_line(int start_x,
        int start_y,
        int end_x,
        int end_y,
        plot callback,
        parameter parameter_plot);

    export extern "C" bool __stdcall draw_lines(handle device,
        const ipoint * vertices,
        uint count);

    export extern "C" bool __stdcall draw_lines_to(handle device,
        const ipoint * vertices,
        uint count);

    export extern "C" bool __stdcall draw_polylines(handle device,
        const ipoint * vertices,
        const uint * counts,
        uint figures);

    export extern "C" bool __stdcall logical_points_to_device_points(handle device,
        ipoint * array,
        int points);

    export extern "C" int __stdcall get_mapping_mode(handle device);

    export extern "C" int __stdcall set_mapping_mode(handle device,
        int mode);

    export extern "C" uint __stdcall set_mapper_flags(handle device,
        uint flags);

    export extern "C" uint __stdcall get_metafile_bits(handle metafile,
        uint size,
        byte * buffer);

    export extern "C" uint __stdcall get_metafile_description_a(handle metafile,
        uint size,
        char* buffer);

    export extern "C" uint __stdcall get_metafile_description_w(handle metafile,
        uint size,
        wchar_t* buffer);

    export template<class character>
        inline uint get_metafile_description(handle metafile,
            uint size,
            char* buffer)
    {
        if (sizeof(character) == 1)
            return get_metafile_description_a(metafile,
                size,
                (char*)buffer);
        else
            return get_metafile_description_w(metafile,
                size,
                (wchar_t*)buffer);

    }

    export extern "C" bool __stdcall enumerate_metafile(handle device,
        handle metafile,
        metafile_callback callback,
        void* enumeration_data,
        const irectangle * bounds);

    export extern "C" bool __stdcall play_metafile(handle device,
        handle metafile,
        const irectangle * bounds);

    export extern "C" bool __stdcall play_metafile_record(handle device,
        handle * handle_table,
        const meta * metaplay,
        uint handles);

    export extern "C" uint __stdcall get_metafile_header(handle metafile,
        uint size,
        meta_header * buffer);

    export extern "C" uint __stdcall get_metafile_palette_entries(handle metafile,
        uint entries,
        palette_entry * palette);

    export extern "C" uint __stdcall get_win_metafile_bits(handle metafile,
        uint size,
        byte * buffer,
        int mode,
        handle reference);

    export extern "C" bool __stdcall get_meta_region(handle device,
        handle region);

    export extern "C" int __stdcall set_meta_region(handle device);

    export extern "C" bool __stdcall get_mitre_limit(handle device,
        float* limit);

    export extern "C" bool __stdcall set_mitre_limit(handle device,
        float new_limit,
        float* previous_limit);

    export extern "C" int __stdcall get_background_mode(handle device);

    export extern "C" int __stdcall set_background_mode(handle device,
        int mode);

    export extern "C" int __stdcall get_foreground_mix(handle device);

    export extern "C" int __stdcall set_foreground_mix(handle device,
        int mix);

    export extern "C" uint __stdcall get_nearest_color(handle device,
        uint color_nearest);

    export extern "C" int __stdcall enumerate_objects(handle device,
        uint object_type,
        void* callback,
        parameter parameter_enumerate);

    export extern "C" handle __stdcall select_object(handle device,
        handle object);

    export extern "C" handle __stdcall get_current_object(handle device,
        uint object_type);

    export extern "C" uint __stdcall get_outline_text_metrics_a(handle device,
        uint size,
        outline_text_metrics<char> *buffer);

    export extern "C" uint __stdcall get_outline_text_metrics_w(handle device,
        uint size,
        outline_text_metrics<wchar_t> *buffer);

    export template<class character>
        inline uint get_outline_text_metrics(handle device,
            uint size,
            outline_text_metrics<character>* buffer)
    {
        if (sizeof(character) == 1)
            return get_outline_text_metrics_a(device,
                size,
                (outline_text_metrics<char>*) buffer);
        else
            return get_outline_text_metrics_w(device,
                size,
                (outline_text_metrics<wchar_t>*) buffer);
    }

    export extern "C" uint __stdcall get_character_placement_a(handle device,
        const char* string,
        int string_length,
        int maximum_extent,
        character_placement<char> *placement,
        uint flags);

    export extern "C" uint __stdcall get_character_placement_w(handle device,
        const wchar_t* string,
        int string_length,
        int maximum_extent,
        character_placement<wchar_t> *placement,
        uint flags);

    export template<class character>
        inline uint get_character_placement(handle device,
            const character* string,
            int string_length,
            int maximum_extent,
            character_placement<character>* placement,
            uint flags)
    {
        if (sizeof(character) == 1)
            return get_character_placement_a(device,
                (const char*)string,
                string_length,
                maximum_extent,
                (character_placement<char>*) placement,
                flags);
        else
            return get_character_placement_w(device,
                (const wchar_t*)string,
                string_length,
                maximum_extent,
                (character_placement<wchar_t>*) placement,
                flags);
    }

    export extern "C" uint __stdcall realize_palette(handle device);

    export extern "C" handle __stdcall select_palette(handle device,
        handle palette,
        bool force_background);

    export extern "C" bool __stdcall cancel_path(handle device);

    export extern "C" bool __stdcall begin_path(handle device);

    export extern "C" bool __stdcall end_path(handle device);

    export extern "C" bool __stdcall fill_path(handle device);

    export extern "C" bool __stdcall flatten_path(handle device);

    export extern "C" int __stdcall get_path(handle device,
        ipoint * vertices,
        byte * types,
        uint count);

    export extern "C" bool __stdcall stroke_path(handle device);

    export extern "C" bool __stdcall stroke_and_fill_path(handle device);

    export extern "C" bool __stdcall widen_path(handle device);

    export extern "C" bool __stdcall draw_sector(handle device,
        int left,
        int top,
        int right,
        int bottom,
        int start_x,
        int start_y,
        int end_x,
        int end_y);

    export extern "C" int __stdcall get_pixel_format(handle device);

    export extern "C" bool __stdcall set_pixel_format(handle device,
        int index,
        const pixel_format_descriptor * format);

    export extern "C" uint __stdcall get_pixel(handle device,
        int x,
        int y);

    export extern "C" uint __stdcall set_pixel(handle device,
        int x,
        int y,
        uint color_pixel);

    export extern "C" bool __stdcall set_pixel_v(handle device,
        int x,
        int y,
        uint color_pixel);

    export extern "C" bool __stdcall polydraw(handle device,
        const ipoint * points,
        const byte * types,
        int count);

    export extern "C" int __stdcall get_fill_mode(handle device);

    export extern "C" int __stdcall set_fill_mode(handle device,
        int mode);

    export extern "C" bool __stdcall draw_polygon(handle device,
        const ipoint * vertices,
        int count);

    export extern "C" bool __stdcall draw_polygons(handle device,
        const ipoint * vertices,
        const uint * counts,
        uint figures);

    export extern "C" bool __stdcall get_current_position(handle device,
        ipoint * position);

    export extern "C" bool __stdcall move_to(handle device,
        int x,
        int y,
        ipoint * previous = 0);

    export extern "C" bool __stdcall draw_rectangle(handle device,
        int left,
        int top,
        int right,
        int bottom);

    export extern "C" bool __stdcall draw_rounded_rectangle(handle device,
        int left,
        int top,
        int right,
        int bottom,
        int width,
        int height);

    export extern "C" bool __stdcall fill_rectangle(handle device,
        const irectangle * rectanglefill,
        handle brush);

    export extern "C" bool __stdcall frame_rectangle(handle device,
        const irectangle * rectangle_frame,
        handle brush);

    export extern "C" bool __stdcall invert_rectangle(handle device,
        const irectangle * rectangle_invert);

    export extern "C" bool __stdcall fill_region(handle device,
        handle region,
        handle brush);

    export extern "C" bool __stdcall frame_region(handle device,
        handle region,
        handle brush,
        int width,
        int height);

    export extern "C" bool __stdcall invert_region(handle device,
        handle region);

    export extern "C" bool __stdcall paint_region(handle device,
        handle region);

    export extern "C" int __stdcall offset_region(handle device,
        int x,
        int y);

    export extern "C" handle __stdcall reset_device_context_a(handle device,
        const device_mode<char> *reset);

    export extern "C" handle __stdcall reset_device_context_w(handle device,
        const device_mode<wchar_t> *reset);

    export template<class character>
        inline handle reset_device_context(handle device,
            const device_mode<character>* reset)
    {
        if (sizeof(character) == 1)
            return reset_device_context_a(device,
                (const device_mode<char> *) reset);
        else
            return reset_device_context_w(device,
                (const device_mode<wchar_t> *) reset);
    }

    export extern "C" bool __stdcall restore_device_context(handle device,
        int identity);

    export extern "C" int __stdcall save_device_context(handle device);

    export extern "C" handle __stdcall window_from_device_context(handle device);

    export extern "C" int __stdcall exclude_update_region(handle device,
        handle window);

    export extern "C" bool __stdcall scroll_device_context(handle device,
        int x,
        int y,
        const irectangle * scroll,
        const irectangle * clip,
        handle region,
        irectangle * update);

    export extern "C" bool __stdcall draw_splines(handle device,
        const ipoint * points,
        uint count);

    export extern "C" bool __stdcall draw_splines_to(handle device,
        const ipoint * points,
        uint count);

    export extern "C" uint __stdcall get_system_palette_entries(handle device,
        uint start,
        uint count,
        palette_entry * entries);

    export extern "C" uint __stdcall get_system_palette_use(handle device);

    export extern "C" uint __stdcall set_system_palette_use(handle device,
        uint usage);

    export extern "C" bool __stdcall text_out_a(handle device,
        int x,
        int y,
        const char* text,
        int length);

    export extern "C" bool __stdcall text_out_w(handle device,
        int x,
        int y,
        const wchar_t* text,
        int length);

    export template<class character>
        inline bool text_out(handle device,
            int x,
            int y,
            const character* text,
            int length)
    {
        if (sizeof(character) == 1)
            return text_out_a(device,
                x,
                y,
                (const char*)text,
                length);
        else
            return text_out_w(device,
                x,
                y,
                (const wchar_t*)text,
                length);
    }

    export extern "C" bool __stdcall extended_text_out_a(handle device,
        int x,
        int y,
        uint options,
        const irectangle * clip,
        const char* text,
        uint length,
        const int* vector);

    export extern "C" bool __stdcall extended_text_out_w(handle device,
        int x,
        int y,
        uint options,
        const irectangle * clip,
        const wchar_t* text,
        uint length,
        const int* vector);

    export template<class character>
        inline bool extended_text_out(handle device,
            int x,
            int y,
            uint options,
            const irectangle* clip,
            const character* text,
            uint length,
            const int* vector)
    {
        if (sizeof(character) == 1)
            return extended_text_out_a(device,
                x,
                y,
                options,
                clip,
                (const char*)text,
                length,
                vector);
        else
            return extended_text_out_w(device,
                x,
                y,
                options,
                clip,
                (const wchar_t*)text,
                length,
                vector);
    }

    export extern "C" int __stdcall draw_text_a(handle device,
        const char* string,
        uint count,
        irectangle * rectangle,
        uint format);

    export extern "C" int __stdcall draw_text_w(handle device,
        const wchar_t* string,
        uint count,
        irectangle * rectangle,
        uint format);

    export template<class character>
        inline int draw_text(handle device,
            const character* string,
            uint count,
            irectangle* rectangle,
            uint format)
    {
        if (sizeof(character) == 1)
            return draw_text_a(device,
                (const char*)string,
                count,
                rectangle,
                format);
        else
            return draw_text_w(device,
                (const wchar_t*)string,
                count,
                rectangle,
                format);
    }

    export extern "C" int __stdcall draw_text_extended_a(handle device,
        const char* string,
        uint count,
        irectangle * rectangle,
        uint format,
        draw_text_parameters * parameters);

    export extern "C" int __stdcall draw_text_extended_w(handle device,
        const wchar_t* string,
        uint count,
        irectangle * rectangle,
        uint format,
        draw_text_parameters * parameters);

    export template<class character>
        inline int draw_text_extended(handle device,
            const character* string,
            uint count,
            irectangle* rectangle,
            uint format,
            draw_text_parameters* parameters)
    {
        if (sizeof(character) == 1)
            return draw_text_extended_a(device,
                (const char*)string,
                count,
                rectangle,
                format,
                parameters);
        else
            return draw_text_extended_w(device,
                (const wchar_t*)string,
                count,
                rectangle,
                format,
                parameters);
    }

    export extern "C" bool __stdcall gray_string_a(handle device,
        handle brush,
        gray_text_callback callback,
        parameter parameter_gray,
        int count,
        int x,
        int y,
        int width,
        int height);

    export extern "C" bool __stdcall gray_string_w(handle device,
        handle brush,
        gray_text_callback callback,
        parameter parameter_gray,
        int count,
        int x,
        int y,
        int width,
        int height);

    export extern "C" bool __stdcall draw_image_state(handle device,
        handle brush,
        draw_state_callback callback,
        parameter parameter2,
        parameter parameter1,
        int x,
        int y,
        int width,
        int height,
        uint flags);

    export extern "C" int __stdcall tabbed_text_out_a(handle device,
        int x,
        int y,
        const char* string,
        int count,
        int tab_position_count,
        const int* tab_positions,
        int tab_origin);

    export extern "C" int __stdcall tabbed_text_out_w(handle device,
        int x,
        int y,
        const wchar_t* string,
        int count,
        int tab_position_count,
        const int* tab_positions,
        int tab_origin);

    export template<class character>
        inline int tabbed_text_out(handle device,
            int x,
            int y,
            const character* string,
            int count,
            int tab_position_count,
            const int* tab_positions,
            int tab_origin)
    {
        if (sizeof(character) == 1)
            return tabbed_text_out_a(device,
                x,
                y,
                (const char*)string,
                count,
                tab_position_count,
                tab_positions,
                tab_origin);
        else
            return tabbed_text_out_w(device,
                x,
                y,
                (const wchar_t*)string,
                count,
                tab_position_count,
                tab_positions,
                tab_origin);
    }

    export extern "C" uint __stdcall get_tabbed_text_extent_a(handle device,
        const char* string,
        int count,
        int tab_position_count,
        int* tab_positions);

    export extern "C" uint __stdcall get_tabbed_text_extent_w(handle device,
        const wchar_t* string,
        int count,
        int tab_position_count,
        int* tab_positions);

    export template<class character>
        inline uint get_tabbed_text_extent(handle device,
            const character* string,
            int count,
            int tab_position_count,
            int* tab_positions)
    {
        if (sizeof(character) == 1)
            return get_tabbed_text_extent_a(device,
                (const char*)string,
                count,
                tab_position_count,
                tab_positions);
        else
            return get_tabbed_text_extent_w(device,
                (const wchar_t*)string,
                count,
                tab_position_count,
                tab_positions);
    }

    export extern "C" uint __stdcall get_text_alignment(handle device);

    export extern "C" uint __stdcall set_text_alignment(handle device,
        uint alignment);

    export extern "C" int __stdcall get_text_character_extra(handle device);

    export extern "C" int __stdcall set_text_character_extra(handle device,
        int extra);

    export extern "C" uint __stdcall get_text_color(handle device);

    export extern "C" uint __stdcall set_text_color(handle device,
        uint color_text);

    export extern "C" bool __stdcall get_text_extent_a(handle device,
        const char* text,
        int length,
        idimensions * extent);

    export extern "C" bool __stdcall get_text_extent_w(handle device,
        const wchar_t* text,
        int length,
        idimensions * extent);

    export template<class character>
        inline bool get_text_extent(handle device,
            const character* text,
            int length,
            idimensions* extent)
    {
        if (sizeof(character) == 1)
            return get_text_extent_a(device,
                (const char*)text,
                length,
                extent);
        else
            return get_text_extent_w(device,
                (const wchar_t*)text,
                length,
                extent);
    }

    export extern "C" bool __stdcall get_text_extent_point_a(handle device,
        const char* text,
        int length,
        int maximum,
        int* fit,
        int* dx,
        idimensions * extent);

    export extern "C" bool __stdcall get_text_extent_point_w(handle device,
        const wchar_t* text,
        int length,
        int maximum,
        int* fit,
        int* dx,
        idimensions * extent);

    export template<class character>
        inline bool get_text_extent_point(handle device,
            const character* text,
            int length,
            int maximum,
            int* fit,
            int* dx,
            idimensions* extent)
    {
        if (sizeof(character) == 1)
            return get_text_extent_point_a(device,
                (const char*)text,
                length,
                maximum,
                fit,
                dx,
                extent);
        else
            return get_text_extent_point_w(device,
                (const wchar_t*)text,
                length,
                maximum,
                fit,
                dx,
                extent);
    }

    export extern "C" int __stdcall get_text_face_a(handle device,
        int size,
        char* buffer);

    export extern "C" int __stdcall get_text_face_w(handle device,
        int size,
        wchar_t* buffer);

    export template<class character>
        inline int get_text_face(handle device,
            int size = 0,
            character* buffer = 0)
    {
        if (sizeof(character) == 1)
            return get_text_face_a(device,
                size,
                (char*)buffer);
        else
            return get_text_face_w(device,
                size,
                (wchar_t*)buffer);
    }

    export extern "C" bool __stdcall set_text_justification(handle device,
        int break_extra = 0,
        int break_count = 0);

    export extern "C" bool __stdcall get_text_metrics_a(handle device,
        text_metrics<char> *metrics);

    export extern "C" bool __stdcall get_text_metrics_w(handle device,
        text_metrics<wchar_t> *metrics);

    export template<class character>
        inline bool  get_text_metrics(handle device,
            text_metrics<character>* metrics)
    {
        if (sizeof(character) == 1)
            return get_text_metrics_a(device,
                (text_metrics<char>*) metrics);
        else
            return get_text_metrics_w(device,
                (text_metrics<wchar_t>*) metrics);

    }

    export extern "C" bool __stdcall poly_text_out_a(handle device,
        const polytext_information<char> *information,
        int strings);

    export extern "C" bool __stdcall poly_text_out_w(handle device,
        const polytext_information<wchar_t> *information,
        int strings);

    export template<class character>
        inline bool poly_text_out(handle device,
            const polytext_information<character>* information,
            int strings)
    {
        if (sizeof(character) == 1)
            return poly_text_out_a(device,
                (const polytext_information<char>*) information,
                strings);
        else
            return poly_text_out_w(device,
                (const polytext_information<wchar_t>*) information,
                strings);
    }

    export extern "C" bool __stdcall get_viewport_extent(handle device,
        idimensions * extent);

    export extern "C" bool __stdcall set_viewport_extent(handle device,
        int x,
        int y,
        idimensions * previous = 0);

    export extern "C" bool __stdcall scale_viewport_extent(handle device,
        int numerator_x,
        int denominator_x,
        int numerator_y,
        int denominator_y,
        idimensions * previous = 0);

    export extern "C" bool __stdcall offset_viewport_origin(handle device,
        int x,
        int y,
        ipoint * previous = 0);

    export extern "C" bool __stdcall get_viewport_origin(handle device,
        ipoint * origin);

    export extern "C" bool __stdcall set_viewport_origin(handle device,
        int x,
        int y,
        ipoint * previous = 0);

    export extern "C" bool __stdcall offset_window_origin(handle device,
        int x,
        int y,
        ipoint * previous = 0);

    export extern "C" bool __stdcall get_window_origin(handle device,
        ipoint * origin);

    export extern "C" bool __stdcall set_window_origin(handle device,
        int x,
        int y,
        ipoint * previous = 0);

    export extern "C" bool __stdcall scale_window_extent(handle device,
        int numerator_x,
        int denominator_x,
        int numerator_y,
        int denominator_y,
        idimensions * previous = 0);

    export extern "C" bool __stdcall get_window_extent(handle device,
        idimensions * extent);

    export extern "C" bool __stdcall set_window_extent(handle device,
        int x,
        int y,
        idimensions * previous = 0);

    export extern "C" bool __stdcall get_world_transform(handle device,
        xform * transform);

    export extern "C" bool __stdcall set_world_transform(handle device,
        const xform * transform);

    export extern "C" bool __stdcall modify_world_transform(handle device,
        const xform * transform,
        uint mode);

    export extern "C" int __stdcall describe_pixel_format(handle device,
        int index,
        uint bytes,
        pixel_format_descriptor * format);

    //*** bitmaps

    export extern "C" handle __stdcall load_bitmap_a(handle module,
        const char* name);

    export extern "C" handle __stdcall load_bitmap_w(handle module,
        const wchar_t* name);

    export template<class character>
        inline handle load_bitmap(handle module,
            const character* name)
    {
        if (sizeof(character) == 1)
            return load_bitmap_a(module,
                (const char*)name);
        else
            return load_bitmap_w(module,
                (const wchar_t*)name);
    }

    export extern "C" handle __stdcall create_compatible_bitmap(handle device,
        int x,
        int y);

    export extern "C" handle __stdcall create_discardable_bitmap(handle device,
        int width,
        int height);

    export extern "C" handle __stdcall create_device_dependent_bitmap(handle device,
        const bitmap_information * header,
        uint initialize,
        const void* data,
        const bitmap_information * information,
        uint usage);

    export extern "C" handle __stdcall create_device_independent_bitmap_section(handle device,
        const bitmap_information * information,
        uint usage,
        void** bits,
        handle mapping,
        uint offset_mapping);

    export extern "C" handle __stdcall create_bitmap(int width,
        int height,
        uint planes,
        uint bits_per_pixel,
        const void* color_data);

    export extern "C" handle __stdcall create_bitmap_indirect(const bitmap_definition * bitmap_definition_pointer);

    export extern "C" int __stdcall get_bitmap_bits(handle device,
        int bits,
        void* data);

    export extern "C" int __stdcall set_bitmap_bits(handle handle,
        uint bits,
        const void* data);

    export extern "C" int __stdcall get_device_independent_bitmap_bits(handle device,
        handle bitmap,
        uint start,
        uint lines,
        void* bits,
        bitmap_information * information,
        uint usage);

    export extern "C" int __stdcall set_device_independent_bitmap_bits(handle device,
        handle bitmap,
        uint start,
        uint lines,
        const void* data,
        const bitmap_information * information,
        uint usage);

    export extern "C" bool __stdcall get_bitmap_idimensions(handle device,
        idimensions * idimensions_bitmap);

    export extern "C" bool __stdcall set_bitmap_dimensions(handle device,
        int width,
        int height,
        idimensions * previous);

    export extern "C" bool __stdcall alpha_blend(handle destination,
        int destination_x,
        int destination_y,
        int destination_width,
        int destination_height,
        handle source,
        int source_x,
        int source_y,
        int source_width,
        int source_height,
        blend_function blend);

    export extern "C" bool __stdcall transparent_bit_block_transfer(handle destination,
        int destination_x,
        int destination_y,
        int destination_width,
        int destination_height,
        handle source,
        int source_x,
        int source_y,
        int source_width,
        int source_height,
        uint transparent_red_green_blue);

    //*** brushes

    export extern "C" handle __stdcall create_brush_indirect(const logical_brush * brush);

    export extern "C" handle __stdcall create_device_independent_bitmap_pattern_brush(handle global,
        uint colors);

    export extern "C" handle __stdcall create_device_independent_bitmap_pattern_brush_pointer(const bitmap_information * information,
        uint colors);

    export extern "C" handle __stdcall create_pattern_brush(handle bitmap);

    export extern "C" handle __stdcall create_hatch_brush(int style,
        uint color_brush);

    export extern "C" handle __stdcall create_solid_brush(uint color_solid);

    //*** fonts

    export extern "C" handle __stdcall create_font_indirect_a(const logical_font<char> *font);

    export extern "C" handle __stdcall create_font_indirect_w(const logical_font<wchar_t> *font);

    export template<class character>
        inline handle create_font_indirect(const logical_font<character>* font)
    {
        if (sizeof(character) == 1)
            return create_font_indirect_a((const logical_font<char>*) font);
        else
            return create_font_indirect_w((const logical_font<wchar_t>*) font);
    }

    export extern "C" handle __stdcall create_font_a(int height,
        int width,
        int escapement,
        int orientation,
        int weight,
        uint italic,
        uint underline,
        uint strikeout,
        uint character_set,
        uint output_precision,
        uint clip_precision,
        uint quality,
        uint pitch_and_family,
        const char* face);

    export extern "C" handle __stdcall create_font_w(int height,
        int width,
        int escapement,
        int orientation,
        int weight,
        uint italic,
        uint underline,
        uint strikeout,
        uint character_set,
        uint output_precision,
        uint clip_precision,
        uint quality,
        uint pitch_and_family,
        const wchar_t* face);

    export template<class character>
        inline handle create_font(int height,
            int width,
            int escapement,
            int orientation,
            int weight,
            uint italic,
            uint underline,
            uint strikeout,
            uint character_set,
            uint output_precision,
            uint clip_precision,
            uint quality,
            uint pitch_and_family,
            const character* face)
    {
        if (sizeof(character) == 1)
            return create_font_a(height,
                width,
                escapement,
                orientation,
                weight,
                italic,
                underline,
                strikeout,
                character_set,
                output_precision,
                clip_precision,
                quality,
                pitch_and_family,
                (const char*)face);
        else
            return create_font_w(height,
                width,
                escapement,
                orientation,
                weight,
                italic,
                underline,
                strikeout,
                character_set,
                output_precision,
                clip_precision,
                quality,
                pitch_and_family,
                (const wchar_t*)face);
    }


    export extern "C" handle __stdcall create_font_indirect_extended_a(const logical_font_design_vector<char>*vector);

    export extern "C" handle __stdcall create_font_indirect_extended_w(const logical_font_design_vector<wchar_t*> vector);

    export template<class character>
        inline handle create_font_indirect_extended(const logical_font_design_vector<character>* vector)
    {
        if (sizeof(character) == 1)
            return create_font_indirect_extended_a((const logical_font_design_vector<char>*) vector);
        else
            return create_font_indirect_extended_w((const logical_font_design_vector<wchar_t>*) vector);
    }

    export extern "C" int __stdcall add_font_resource_a(const char* file_name);

    export extern "C" int __stdcall add_font_resource_w(const wchar_t* file_name);

    export template<class character>
        inline int add_font_resource(const character* file_name)
    {
        if (sizeof(character) == 1)
            return add_font_resource_a((const char*)file_name);
        else
            return add_font_resource_a((const wchar_t*)file_name);
    }

    export extern "C" int __stdcall add_font_resource_extended_a(const char* file_name,
        uint flags,
        design_vector * vector);

    export extern "C" int __stdcall add_font_resource_extended_w(const wchar_t* file_name,
        uint flags,
        design_vector * vector);

    export template<class character>
        inline int add_font_resource_extended(const character* file_name,
            uint flags,
            design_vector* vector)
    {
        if (sizeof(character) == 1)
            return add_font_resource_extended_a((const char*)file_name,
                flags,
                vector);
        else
            return add_font_resource_extended_w((const wchar_t*)file_name,
                flags,
                vector);
    }

    export extern "C" bool __stdcall remove_font_resource_extended_a(const char* file_name,
        uint flags,
        design_vector * vector);

    export extern "C" bool __stdcall remove_font_resource_extended_w(const wchar_t* file_name,
        uint flags,
        design_vector * vector);

    export template<class character>
        inline bool remove_font_resource_extended(const character* file_name,
            uint flags,
            design_vector* vector)
    {
        if (sizeof(character) == 1)
            return remove_font_resource_extended_a((const char*)file_name,
                flags,
                vector);
        else
            return remove_font_resource_extended_w((const wchar_t*)file_name,
                flags,
                vector);
    }

    export extern "C" handle __stdcall add_font_memory_resource(void*,
        uint,
        design_vector*,
        uint*);

    export extern "C" bool __stdcall remove_font_memory_resource(handle resource);

    export extern "C" bool __stdcall create_scalable_font_resource_a(uint hidden,
        const char* font_resource,
        const char* font_file,
        const char* path);

    export extern "C" bool __stdcall create_scalable_font_resource_w(uint hidden,
        const wchar_t* font_resource,
        const wchar_t* font_file,
        const wchar_t* path);

    export template<class character>
        inline bool create_scalable_font_resource(uint hidden,
            const character* font_resource,
            const character* font_file,
            const character* path)
    {
        if (sizeof(character) == 1)
            return create_scalable_font_resource_a(hidden,
                (const char*)font_resource,
                (const char*)font_file,
                (const char*)path);
        else
            return create_scalable_font_resource_w(hidden,
                (const wchar_t*)font_resource,
                (const wchar_t*)font_file,
                (const wchar_t*)path);
    }

    export extern "C" bool __stdcall remove_font_resource_a(const char* file_name);

    export extern "C" bool __stdcall remove_font_resource_w(const wchar_t* file_name);

    export template<class character>
        inline bool remove_font_resource(const character* file_name)
    {
        if (sizeof(character) == 1)
            return remove_font_resource_a((const char*)file_name);
        else
            return remove_font_resource_w((const wchar_t*)file_name);
    }

    //*** metafiles

    export extern "C" handle __stdcall create_metafile_a(handle device,
        const char* file_name,
        const irectangle * bounds,
        const char* description);

    export extern "C" handle __stdcall create_metafile_w(handle device,
        const wchar_t* file_name,
        const irectangle * bounds,
        const wchar_t* description);

    export template<class character>
        inline handle create_metafile(handle device = 0,
            const character* file_name = 0,
            const irectangle* bounds = 0,
            const character* description = 0)
    {
        if (sizeof(character) == 1)
            return create_metafile_a(device,
                (const char*)file_name,
                bounds,
                (const char*)description);
        else
            return create_metafile_w(device,
                (const wchar_t*)file_name,
                bounds,
                (const wchar_t*)description);
    }

    export extern "C" handle __stdcall close_metafile(handle device);

    export extern "C" handle __stdcall copy_metafile_a(handle metafile,
        const char* file_name);

    export extern "C" handle __stdcall copy_metafile_w(handle metafile,
        const wchar_t* file_name);

    export template<class character>
        inline handle copy_metafile(handle metafile,
            const character* file_name)
    {
        if (sizeof(character) == 1)
            return copy_metafile_a(metafile,
                (const char*)file_name);
        else
            return copy_metafile_w(metafile,
                (const wchar_t*)file_name);
    }

    export extern "C" handle __stdcall get_metafile_a(const char* file_name);

    export extern "C" handle __stdcall get_metafile_w(const wchar_t* file_name);

    export template<class character>
        inline handle get_metafile(const character* file_name)
    {
        if (sizeof(character) == 1)
            return get_metafile_a((const char*)file_name);
        else
            return get_metafile_w((const wchar_t*)file_name);
    }

    export extern "C" handle __stdcall set_metafile_bits(uint size,
        const byte * buffer);

    export extern "C" handle __stdcall set_win_metafile_bits(uint size,
        const byte * buffer,
        handle device,
        const meta_picture * picture);

    export extern "C" bool __stdcall delete_metafile(handle metafile);

    //*** graphics objects

    export extern "C" bool __stdcall delete_object(handle object);

    export extern "C" handle __stdcall get_standard_object(int object);

    export extern "C" uint __stdcall get_object_type(handle object);


    export extern "C" int __stdcall get_object_a(handle object,
        int length,
        void* buffer);

    export extern "C" int __stdcall get_object_w(handle object,
        int length,
        void* buffer);

    export extern "C" inline int get_object(handle object,
        int length,
        void* buffer)
    {
        return get_object_w(object,
            length,
            buffer);
    }

    //*** palettes

    export extern "C" handle __stdcall create_palette(const logical_palette * logical_palette_create);

    export extern "C" handle __stdcall create_halftone_palette(handle device);

    export extern "C" bool __stdcall animate_palette(handle palette,
        uint start,
        uint count,
        const palette_entry * entries);

    export extern "C" uint __stdcall get_palette_entries(handle palette,
        uint start,
        uint count,
        palette_entry * entries);

    export extern "C" uint __stdcall set_palette_entries(handle palette,
        uint start,
        uint count,
        const palette_entry * entries);

    export extern "C" bool __stdcall resize_palette(handle palette,
        uint new_size);

    export extern "C" uint __stdcall get_nearest_palette_index(handle palette,
        uint color_query);

    export extern "C" bool __stdcall unrealize_object(handle object);

    //*** pens

    export extern "C" handle __stdcall create_pen(int style,
        int width,
        uint color_pen);

    export extern "C" handle __stdcall create_pen_indirect(const logical_pen * pen);

    export extern "C" handle __stdcall extended_create_pen(uint style,
        uint width,
        const logical_brush * brush,
        uint count = 0,
        const uint * custom = 0);

    //*** regions

    export extern "C" handle __stdcall extended_create_region(const xform * transform,
        uint count,
        const region_data * data);

    export extern "C" handle __stdcall create_elliptic_region(int left,
        int top,
        int right,
        int bottom);

    export extern "C" handle __stdcall create_elliptic_region_indirect(const irectangle * region);

    export extern "C" handle __stdcall create_rectangular_region_indirect(const irectangle * region);

    export extern "C" handle __stdcall create_rectangular_region(int left,
        int top,
        int right,
        int bottom);

    export extern "C" handle __stdcall create_rounded_rectangular_region(int left,
        int top,
        int right,
        int bottom,
        int width,
        int height);

    export extern "C" handle __stdcall create_polygonal_region(const ipoint * points,
        uint count,
        int fill_mode);

    export extern "C" handle __stdcall create_polypolygonal_region(const ipoint * points,
        const uint * counts,
        uint polygons,
        int fill_mode);

    export extern "C" handle __stdcall path_to_region(handle device);

    export extern "C" bool __stdcall rectangle_in_region(handle device,
        const irectangle * test);

    export extern "C" bool __stdcall set_rectangle_region(handle device,
        int left,
        int top,
        int right,
        int bottom);

    export extern "C" int __stdcall combine_region(handle destination,
        handle source1,
        handle source2,
        int mode);

    export extern "C" bool __stdcall equal_region(handle region_a,
        handle region_b);

    export extern "C" uint __stdcall get_region_data(handle device,
        uint count,
        region_data * data);

    export extern "C" int __stdcall get_region_box(handle device,
        irectangle * bounds);

    export extern "C" bool __stdcall ipoint_in_region(handle device,
        int x,
        int y);

    //*** miscellaneous graphics functions

    export extern "C" int __stdcall device_capabilities_a(const char* device,
        const char* port,
        part capability,
        char* output,
        const device_mode<char> *mode);

    export extern "C" int __stdcall device_capabilities_w(const wchar_t* device,
        const wchar_t* port,
        part capability,
        wchar_t* output,
        const device_mode<wchar_t> *mode);

    export template<class character>
        inline int device_capabilities(const character* device,
            const character* port,
            part capability,
            character* output,
            const device_mode<character>* mode)
    {
        if (sizeof(character) == 1)
            return device_capabilities_a((const char*)device,
                (const char*)port,
                capability,
                (char*)output,
                (const device_mode<char>*) mode);
        else
            return device_capabilities_w((const wchar_t*)device,
                (const wchar_t*)port,
                capability,
                (wchar_t*)output,
                (const device_mode<wchar_t>*) mode);
    }

    export extern "C" bool __stdcall get_rasterizer_capabilities(rasterizer_status * raster,
        uint size);

    export extern "C" bool __stdcall flush_graphics();

    export extern "C" uint __stdcall set__batch_limit(uint limit);

    export extern "C" uint __stdcall get__batch_limit();

    export extern "C" int __stdcall choose_pixel_format(handle device,
        const pixel_format_descriptor * descriptor);

    export extern "C" bool __stdcall combine_transform(xform * result,
        const xform * source_a,
        const xform * source_b);

    // Windows Subsystem

    export extern "C" bool __stdcall win_help_a(handle window,
        const char* help,
        uint command,
        void* data);

    export extern "C" bool __stdcall win_help_w(handle window,
        const wchar_t* help,
        uint command,
        void* data);

    export template<class character>
        inline bool win_help(handle window,
            const character* help,
            uint command,
            void* data)
    {
        if (sizeof(character) == 1)
            return win_help_a(window,
                (const char*)help,
                command,
                data);
        else
            return win_help_w(window,
                (const wchar_t*)help,
                command,
                data);
    }

    //*** register window classes

    export extern "C" atom __stdcall register_class_a(const window_class<char> *class_information);

    export extern "C" atom __stdcall register_class_w(const window_class<wchar_t> *class_information);

    export template<class character>
        inline atom register_class(const window_class<character>* class_information)
    {
        if (sizeof(character) == 1)
            return register_class_a((const window_class<char>*) class_information);
        else
            return register_class_w((const window_class<wchar_t>*) class_information);
    }

    export extern "C" atom __stdcall register_class_extended_a(const window_class_new<char> *class_information);

    export extern "C" atom __stdcall register_class_extended_w(const window_class_new<wchar_t> *class_information);

    export template<class character>
        inline atom register_class_extended(const window_class_new<character>* class_information)
    {
        if (sizeof(character) == 1)
            return register_class_extended_a((const window_class_new<char>*) class_information);
        else
            return register_class_extended_w((const window_class_new<wchar_t>*) class_information);

    }

    export extern "C" bool __stdcall deregister_class(int name,
        handle module);

    export extern "C" bool __stdcall get_class_information_a(handle module,
        const char* class_name,
        window_class<char> *class_information);

    export extern "C" bool __stdcall get_class_information_w(handle module,
        const wchar_t* class_name,
        window_class<wchar_t> *class_information);

    export template<class character>
        inline bool get_class_information(handle module,
            const character* class_name,
            window_class<character>* class_information)
    {
        if (sizeof(character) == 1)
            return get_class_information_a(module,
                (const char*)class_name,
                (window_class<char>*) class_information);
        else
            return get_class_information_w(module,
                (const wchar_t*)class_name,
                (window_class<wchar_t>*) class_information);
    }

    export template<class character>
        inline bool get_class_information_extended_a(handle module,
            const char* class_name,
            window_class_new<char>* class_information);

    export template<class character>
        inline bool get_class_information_extended_w(handle module,
            const wchar_t* class_name,
            window_class_new<wchar_t>* class_information);

    export template<class character>
        inline bool get_class_information_extended(handle module,
            const character* class_name,
            window_class_new<character>* class_information)
    {
        if (sizeof(character) == 1)
            return get_class_information_a(module,
                (const char*)class_name,
                (window_class<char>*) class_information);
        else
            return get_class_information_w(module,
                (const wchar_t*)class_name,
                (window_class<wchar_t>*) class_information);

    }

    //*** messages and message queues

    export extern "C" int __stdcall get_message_a(queue_message * queue_message,
        handle window = 0,
        uint filter_minimum = 0,
        uint filter_maximum = 0);

    export extern "C" int __stdcall get_message_w(queue_message * queue_message,
        handle window = 0,
        uint filter_minimum = 0,
        uint filter_maximum = 0);

    export  extern "C"  int get_message(queue_message * queue_message,
        handle window = 0,
        uint filter_minimum = 0,
        uint filter_maximum = 0)
    {
        return get_message_w(queue_message,
            window,
            filter_minimum,
            filter_maximum);
    }

    export extern "C" bool __stdcall translate_message(const queue_message * queue_message);

    export extern "C" result __stdcall dispatch_message_a(const queue_message* const queue_message);

    export extern "C" result __stdcall dispatch_message_w(const queue_message* const queue_message);

    export  extern "C"  result dispatch_message(const queue_message* const queue_message)
    {
        return dispatch_message_w(queue_message);
    }

    export extern "C" bool __stdcall peek_message_a(queue_message * queue_message,
        handle window,
        uint filter_minimum,
        uint filter_maximum,
        uint message_remove);

    export extern "C" bool __stdcall peek_message_w(queue_message * queue_message,
        handle window,
        uint filter_minimum,
        uint filter_maximum,
        uint message_remove);

    export extern "C" inline bool peek_message(queue_message * queue_message,
        handle window,
        uint filter_minimum,
        uint filter_maximum,
        uint message_remove)
    {
        return peek_message_w(queue_message,
            window,
            filter_minimum,
            filter_maximum,
            message_remove);
    }

    export extern "C" bool __stdcall call_message_filter(queue_message * queue_message,
        int code);

    export extern "C" uint __stdcall register_window_message(const character * message);

    export extern "C" bool __stdcall set_message_queue(int message_maximum);

    export extern "C" uint __stdcall get_message_position();

    export extern "C" int __stdcall get_message_time();

    export extern "C" parameter __stdcall get_message_extra_information();

    export extern "C" parameter __stdcall set_message_extra_information(parameter information);

    export extern "C" bool __stdcall post_thread_message_a(uint thread,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" bool __stdcall post_thread_message_w(uint thread,
        uint message,
        parameter parameter1,
        parameter parameter2);

    inline bool post_thread_message(uint thread,
        uint message,
        parameter parameter1,
        parameter parameter2)
    {
        return post_thread_message_w(thread,
            message,
            parameter1,
            parameter2);
    }

    export extern "C" bool __stdcall attach_thread_input(uint source,
        uint destination,
        bool attach);

    export extern "C" bool __stdcall reply_message(result result_reply);

    export extern "C" bool __stdcall wait_message();

    export extern "C" uint __stdcall wait_for_input_idle(handle process,
        uint milliseconds);

    export extern "C" void __stdcall post_quit_message(int exit_code = 0);

    export extern "C" bool __stdcall in_send_message();

    export extern "C" uint __stdcall in_send_message_extended(void* reserved);

    export extern "C" uint __stdcall get_double_click_time();

    export extern "C" bool __stdcall set_double_click_time(uint milliseconds);

    export extern "C" uint __stdcall get_queue_status(uint flags);

    //*** windows

    export extern "C" handle __stdcall get_desktop_window();

    export extern "C" bool __stdcall draw_animated_rectangles(handle window,
        int flags,
        const irectangle * start,
        const irectangle * finish);

    export extern "C" void __stdcall drag_accept_files(handle window,
        bool accept);

    export extern "C" int __stdcall menu_item_from_point(handle window,
        handle menu,
        ipoint screen);

    export extern "C" bool __stdcall get_menu_item_rectangle(handle window,
        handle menu,
        uint item,
        irectangle * bounds);

    export extern "C" bool __stdcall any_popup();

    export extern "C" handle __stdcall window_from_point(ipoint position);

    export extern "C" handle __stdcall get_active_window();

    export extern "C" handle __stdcall get_focus();

    export extern "C" result __stdcall default_multiple_document_child_procedure_a(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" result __stdcall default_multiple_document_child_procedure_w(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" inline result default_multiple_document_child_procedure(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2)
    {
        return default_multiple_document_child_procedure_w(window,
            message,
            parameter1,
            parameter2);
    }

    export extern "C" result __stdcall default_frame_procedure_a(handle window,
        handle multidocument,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" result __stdcall default_frame_procedure_w(handle window,
        handle multidocument,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" inline result default_frame_procedure(handle window,
        handle multidocument,
        uint message,
        parameter parameter1,
        parameter parameter2)
    {
        return default_frame_procedure_w(window,
            multidocument,
            message,
            parameter1,
            parameter2);
    }


    export extern "C" handle __stdcall create_window_extended_a(uint extended,
        const char* class_name,
        const char* title,
        uint style,
        int x,
        int y,
        int width,
        int height,
        handle parent,
        handle menu,
        handle module,
        void* parameters);

    export extern "C" handle __stdcall create_window_extended_w(uint extended,
        const wchar_t* class_name,
        const wchar_t* title,
        uint style,
        int x,
        int y,
        int width,
        int height,
        handle parent,
        handle menu,
        handle module,
        void* parameters);

    export template<class character>
        inline handle create_window_extended(uint extended,
            const character* class_name,
            const character* title,
            uint style,
            int x,
            int y,
            int width,
            int height,
            handle parent,
            handle menu,
            handle module,
            void* parameters)
    {
        if (sizeof(character) == 1)
            return create_window_extended_a(extended,
                (const char*)class_name,
                (const char*)title,
                style,
                x,
                y,
                width,
                height,
                parent,
                menu,
                module,
                parameters);
        else
            return create_window_extended_w(extended,
                (const wchar_t*)class_name,
                (const wchar_t*)title,
                style,
                x,
                y,
                width,
                height,
                parent,
                menu,
                module,
                parameters);
    }

    export template<class character>
        inline handle create_window(int class_name,
            const character* window_name,
            uint style = style::standard,
            int x = use_default,
            int y = use_default,
            int width = use_default,
            int height = use_default,
            handle parent = 0,
            handle menu = 0,
            handle module = 0,
            void* parameters = 0)
    {
        return create_window_extended(0,
            (const character*)class_name,
            window_name,
            style,
            x,
            y,
            width,
            height,
            parent,
            menu,
            module,
            parameters);
    }

    export template<class character>
        inline handle create_window(const character* class_name,
            const character* window_name,
            uint style = style::standard,
            int x = use_default,
            int y = use_default,
            int width = use_default,
            int height = use_default,
            handle parent = 0,
            handle menu = 0,
            handle module = 0,
            void* parameters = 0)
    {
        return create_window_extended(0,
            class_name,
            window_name,
            style,
            x,
            y,
            width,
            height,
            parent,
            menu,
            module,
            parameters);
    }

    export extern "C" handle __stdcall create_multidocument_window_a(const char* class_name,
        const char* title,
        uint style,
        int x,
        int y,
        int width,
        int height,
        handle parent,
        handle module,
        parameter parameter2);

    export extern "C" handle __stdcall create_multidocument_window_w(const wchar_t* class_name,
        const wchar_t* title,
        uint style,
        int x,
        int y,
        int width,
        int height,
        handle parent,
        handle module,
        parameter parameter2);

    export template<class character>
        inline handle create_multidocument_window(const character* class_name,
            const character* title,
            uint style,
            int x,
            int y,
            int width,
            int height,
            handle parent,
            handle module,
            parameter parameter2)
    {
        if (sizeof(character) == 1)
            return create_multidocument_window_a((const char*)class_name,
                (const char*)title,
                style,
                x,
                y,
                width,
                height,
                parent,
                module,
                parameter2);
        else
            return create_multidocument_window_w((const wchar_t*)class_name,
                (const wchar_t*)title,
                style,
                x,
                y,
                width,
                height,
                parent,
                module,
                parameter2);
    }

    export extern "C" handle __stdcall get_child_window(handle window,
        int child_identity);

    export extern "C" bool __stdcall destroy_window(handle window);

    export extern "C" bool __stdcall get_window_placement(handle window,
        placement * placement_get);

    export extern "C" bool __stdcall set_window_placement(handle window,
        const placement * placement_set);

    export extern "C" bool __stdcall translate_accelerator(handle window,
        handle accelerator,
        const queue_message * message);

    export extern "C" bool __stdcall create_caret(handle window,
        handle bitmap,
        int width,
        int height);

    export extern "C" bool __stdcall hide_caret(handle window);

    export extern "C" bool __stdcall show_caret(handle window);

    export extern "C" handle __stdcall set_capture(handle window);

    export extern "C" handle __stdcall get_capture();

    export extern "C" bool __stdcall release_capture();

    export extern "C" uint __stdcall get_child_integer(handle dialog,
        int identity,
        bool* translated,
        bool is_signed);

    export extern "C" bool __stdcall set_child_integer(handle dialog,
        int identity,
        uint value,
        bool is_signed);

    export extern "C" uint __stdcall get_child_text_a(handle dialog,
        int identity,
        char* string,
        uint length);

    export extern "C" uint __stdcall get_child_text_w(handle dialog,
        int identity,
        wchar_t* string,
        uint length);

    export template<class character>
        inline uint get_child_text(handle dialog,
            int identity,
            character* string,
            uint length)
    {
        if (sizeof(character) == 1)
            return get_child_text_a(dialog,
                identity,
                (char*)string,
                length);
        else
            return get_child_text_w(dialog,
                identity,
                (wchar_t*)string,
                length);
    }

    export extern "C" bool __stdcall set_child_text_a(handle window,
        int identity,
        const char* string);

    export extern "C" bool __stdcall set_child_text_w(handle window,
        int identity,
        const wchar_t* string);

    export template<class character>
        inline bool set_child_text(handle window,
            int identity,
            const character* string)
    {
        if (sizeof(character) == 1)
            return set_child_text_a(window,
                identity,
                (const char*)string);
        else
            return set_child_text_w(window,
                identity,
                (const wchar_t*)string);
    }

    export extern "C" bool __stdcall check_child_button(handle window,
        int identity,
        uint check);

    export extern "C" bool __stdcall check_radio_button(handle dialog,
        int first,
        int last,
        int check);

    export extern "C" uint __stdcall is_child_checked(handle dialog,
        int identity);

    export extern "C" int __stdcall send_child_message(handle dialog,
        int identity,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" handle __stdcall child_window_from_point(handle parent,
        ipoint position);

    export extern "C" handle __stdcall child_window_from_point_extended(handle parent,
        ipoint position,
        uint skip);

    export extern "C" bool __stdcall enumerate_child_windows(handle parent,
        enumerate_window callback,
        parameter parameter_enumerate);

    export extern "C" handle __stdcall get_top_window(handle window);

    export extern "C" int __stdcall get_class_name_a(handle window,
        char* class_name,
        int length);

    export extern "C" int __stdcall get_class_name_w(handle window,
        wchar_t* class_name,
        int length);

    export template<class character>
        inline int get_class_name(handle window,
            character* class_name,
            int length)
    {
        if (sizeof(character) == 1)
            return get_class_name_a(window,
                (char*)class_name,
                length);
        else
            return get_class_name_w(window,
                (wchar_t*)class_name,
                length);
    }

    export extern "C" int __stdcall get_class_part(handle window,
        int index);

    export extern "C" int __stdcall set_class_part(handle window,
        int index,
        part value);

    export extern "C" int __stdcall get_class_integer_a(handle window,
        int index);

    export extern "C" int __stdcall get_class_integer_w(handle window,
        int index);

    export extern "C" inline int get_class_integer(handle window,
        int index)
    {
        return get_class_integer_w(window,
            index);
    }

    export extern "C" int __stdcall set_class_integer_a(handle window,
        int index,
        int value);

    export extern "C" int __stdcall set_class_integer_w(handle window,
        int index,
        int value);

    export extern "C" inline int set_class_integer(handle window,
        int index,
        int value)
    {
        return set_class_integer_w(window,
            index,
            value);
    }

    export extern "C" handle __stdcall set_window_pointer_a(handle window,
        int index,
        handle value);

    export extern "C" handle __stdcall set_window_pointer_w(handle window,
        int index,
        handle value);

    export  extern "C" inline handle  set_window_pointer(handle window,
        int index,
        handle value)
    {
        return set_window_pointer_w(window,
            index,
            value);
    }

    export extern "C" handle __stdcall get_window_pointer_a(handle window,
        int index);

    export extern "C" handle __stdcall get_window_pointer_w(handle window,
        int index);

    export  extern "C"  inline handle get_window_pointer(handle window,
        int index)
    {
        return get_window_pointer_w(window,
            index);
    }

    export extern "C" handle __stdcall set_class_pointer_a(handle window,
        int index,
        handle value);

    export extern "C" handle __stdcall set_class_pointer_w(handle window,
        int index,
        handle value);

    export extern "C" inline handle set_class_pointer(handle window,
        int index,
        handle value)
    {
        return set_class_pointer_w(window,
            index,
            value);
    }

    export extern "C" handle __stdcall get_class_pointer_a(handle window,
        int index);

    export extern "C" handle __stdcall get_class_pointer_w(handle window,
        int index);

    export extern "C" inline handle get_class_pointer(handle window,
        int index)
    {
        return get_class_pointer_w(window,
            index);
    }

    export extern "C" bool __stdcall get_client_rectangle(handle window,
        irectangle * client);

    export extern "C" bool __stdcall close_window(handle window);

    export extern "C" bool __stdcall client_to_screen(handle window,
        ipoint * convert);

    export extern "C" bool __stdcall list_directory_a(handle window,
        char* path,
        int listbox,
        int display,
        uint type);

    export extern "C" bool __stdcall list_directory_w(handle window,
        wchar_t* path,
        int listbox,
        int display,
        uint type);

    export template<class character>
        inline bool list_directory(handle window,
            character* path,
            int listbox,
            int display,
            uint type)
    {
        if (sizeof(character) == 1)
            return list_directory_a(window,
                (char*)path,
                listbox,
                display,
                type);
        else
            return list_directory_w(window,
                (wchar_t*)path,
                listbox,
                display,
                type);
    }

    export extern "C" bool __stdcall select_directory_a(handle window,
        char* string,
        int count,
        int listbox);

    export extern "C" bool __stdcall select_directory_w(handle window,
        wchar_t* string,
        int count,
        int listbox);

    export template<class character>
        inline bool select_directory(handle window,
            character* string,
            int count,
            int listbox)
    {
        if (sizeof(character) == 1)
            return select_directory_a(window,
                (char*)string,
                count,
                listbox);
        else
            return select_directory_w(window,
                (wchar_t*)string,
                count,
                listbox);
    }

    export extern "C" bool __stdcall list_directory_combobox_a(handle window,
        char* path,
        int combobox,
        int display,
        uint type);

    export extern "C" bool __stdcall list_directory_combobox_w(handle window,
        wchar_t* path,
        int combobox,
        int display,
        uint type);

    export template<class character>
        inline bool list_directory_combobox(handle window,
            character* path,
            int combobox,
            int display,
            uint type)
    {
        if (sizeof(character) == 1)
            return list_directory_combobox_a(window,
                (char*)path,
                combobox,
                display,
                type);
        else
            return list_directory_combobox_w(window,
                (wchar_t*)path,
                combobox,
                display,
                type);
    }

    export extern "C" bool __stdcall select_directory_combobox_a(handle window,
        char* string,
        int count,
        int combobox);

    export extern "C" bool __stdcall select_directory_combobox_w(handle window,
        wchar_t* string,
        int count,
        int combobox);

    export template<class character>
        inline bool select_directory_combobox(handle window,
            character* string,
            int count,
            int combobox)
    {
        if (sizeof(character) == 1)
            return select_directory_combobox_a(window,
                (char*)string,
                count,
                combobox);
        else
            return select_directory_combobox_w(window,
                (wchar_t*)string,
                count,
                combobox);
    }

    export extern "C" bool __stdcall enable_window(handle window,
        bool enable);

    export extern "C" bool __stdcall flash_window(handle window,
        bool invert);

    export extern "C" handle __stdcall set_focus(handle window);

    export extern "C" handle __stdcall get_next_dialog_group_item(handle dialog,
        handle control,
        bool previous);

    export extern "C" handle __stdcall get_next_dialog_tab_item(handle dialog,
        handle control,
        bool previous);

    export extern "C" bool __stdcall register_hotkey(handle window,
        int identity,
        uint modifiers,
        uint vkey);

    export extern "C" bool __stdcall deregister_hotkey(handle window,
        int identity);

    export extern "C" uint __stdcall arrange_minimized_windows(handle window);

    export extern "C" bool __stdcall restore_window(handle window);

    export extern "C" int __stdcall get_window_identity(handle window);

    export extern "C" bool __stdcall is_child(handle parent,
        handle child);

    export extern "C" bool __stdcall is_window_minimized(handle window);

    export extern "C" bool __stdcall is_menu(handle menu);

    export extern "C" bool __stdcall is_window_enabled(handle window);

    export extern "C" bool __stdcall is_windowunicode(handle window);

    export extern "C" bool __stdcall is_window(handle window);

    export extern "C" bool __stdcall is_window_visible(handle window);

    export extern "C" bool __stdcall is_window_maximized(handle window);

    export extern "C" bool __stdcall is_dialog_message_a(handle dialog,
        const queue_message * queue_message);

    export extern "C" bool __stdcall is_dialog_message_w(handle dialog,
        const queue_message * queue_message);

    export extern "C" inline bool is_dialog_message(handle dialog,
        const queue_message * queue_message)
    {
        return is_dialog_message_w(dialog,
            queue_message);
    }

    export extern "C" handle __stdcall get_last_active_popup(handle window);

    export extern "C" int __stdcall get_window_integer_a(handle window,
        int index);

    export extern "C" int __stdcall get_window_integer_w(handle window,
        int index);

    export extern "C" inline int get_window_integer(handle window,
        int index)
    {
        return get_window_integer_w(window,
            index);
    }

    export extern "C" int __stdcall set_window_integer_a(handle window,
        int index,
        int new_integer);

    export extern "C" int __stdcall set_window_integer_w(handle window,
        int index,
        int new_integer);

    export extern "C" inline int set_window_integer(handle window,
        int index,
        int new_integer)
    {
        return set_window_integer_w(window,
            index,
            new_integer);

    }

    export extern "C" bool __stdcall translate_multidocument_system_accelerator(handle window,
        queue_message * queue_message);

    export extern "C" bool __stdcall draw_menu_bar(handle window);

    export extern "C" handle __stdcall get_menu(handle window);

    export extern "C" bool __stdcall highlight_menu_item(handle window,
        handle menu,
        uint identity,
        uint highlight);

    export extern "C" bool __stdcall set_menu(handle window,
        handle menu);

    export extern "C" bool __stdcall post_message_a(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0);

    export extern "C" bool __stdcall post_message_w(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0);

    export extern "C" inline bool post_message(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0)
    {
        return post_message_w(window,
            message,
            parameter1,
            parameter2);
    }

    export extern "C" result __stdcall send_message_a(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0);

    export extern "C" result __stdcall send_message_w(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0);

    export  extern "C"  inline result send_message(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0)
    {
        return send_message_w(window,
            message,
            parameter1,
            parameter2);

    }

    export extern "C" bool __stdcall send_message_timeout_w(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2,
        uint flags,
        uint timeout,
        result * result_message);

    export extern "C" bool __stdcall send_message_timeout_a(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2,
        uint flags,
        uint timeout,
        result * result_message);

    export extern "C" inline bool send_message_timeout(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2,
        uint flags,
        uint timeout,
        result * result_message)
    {
        return send_message_timeout_a(window,
            message,
            parameter1,
            parameter2,
            flags,
            timeout,
            result_message);
    }

    export extern "C" bool __stdcall send_notify_message_a(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0);

    export extern "C" bool __stdcall send_notify_message_w(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0);

    export extern "C" inline bool send_notify_message(handle window,
        uint message,
        parameter parameter1 = 0,
        parameter parameter2 = 0)
    {
        return send_notify_message_w(window,
            message,
            parameter1,
            parameter2);
    }

    export extern "C" bool __stdcall send_message_callback_a(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2,
        completion callback,
        void* data);

    export extern "C" bool __stdcall send_message_callback_w(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2,
        completion callback,
        void* data);

    export extern "C" inline bool send_message_callback(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2,
        completion callback,
        void* data)
    {
        return send_message_callback_w(window,
            message,
            parameter1,
            parameter2,
            callback,
            data);
    }

    export extern "C" bool __stdcall move_window(handle window,
        int x,
        int y,
        int width,
        int height,
        bool repaint = false);

    export extern "C" bool __stdcall show_owned_popups(handle window,
        bool show);

    export extern "C" handle __stdcall get_parent(handle window);

    export extern "C"  handle __stdcall set_parent(handle child,
        handle parent);

    export extern "C"  int __stdcall enumerate_properties_extended(handle window,
        extended_property_callback callback,
        parameter parameter_enumerate);

    export extern "C" handle __stdcall get_property_a(handle window,
        const char* string);

    export extern "C" handle __stdcall get_property_w(handle window,
        const wchar_t* string);

    export template<class character>
        inline handle get_property(handle window,
            const character* string)
    {
        if (sizeof(character) == 1)
            return get_property_a(window,
                (const char*)string);
        else
            return get_property_w(window,
                (const wchar_t*)string);
    }

    export extern "C" handle __stdcall remove_property_a(handle window,
        const char* string);

    export extern "C" handle __stdcall remove_property_w(handle window,
        const wchar_t* string);

    export template<class character>
        inline handle remove_property(handle window,
            const character* string)
    {
        if (sizeof(character) == 1)
            return remove_property_a(window,
                (const char*)string);
        else
            return remove_property_w(window,
                (const wchar_t*)string);
    }

    export extern "C" bool __stdcall set_property_a(handle window,
        const char* string,
        handle data);

    export extern "C" bool __stdcall set_property_w(handle window,
        const wchar_t* string,
        handle data);

    export template<class character>
        inline bool set_property(handle window,
            const character* string,
            handle data)
    {
        if (sizeof(character) == 1)
            return set_property_a(window,
                (const char*)string,
                data);
        else
            return set_property_w(window,
                (const wchar_t*)string,
                data);
    }

    export extern "C" int __stdcall enumerate_properties(handle window,
        property_callback callback);

    export extern "C" bool __stdcall invalidate_rectangle(handle window,
        const irectangle * invalidate = 0,
        bool erase = false);

    export extern "C" bool __stdcall validate_rectangle(handle window,
        const irectangle * validate = 0);

    export extern "C" bool __stdcall get_window_rectangle(handle window,
        irectangle * bounds);

    export extern "C" bool __stdcall redraw_window(handle window,
        const irectangle * update,
        handle region,
        uint flags);

    export extern "C" bool __stdcall invalidate_region(handle window,
        handle region,
        bool erase);

    export extern "C" bool __stdcall validate_region(handle window,
        handle region);

    export extern "C" bool __stdcall screen_to_client(handle window,
        ipoint * convert);

    export extern "C" bool __stdcall scroll_window(handle window,
        int x,
        int y,
        const irectangle * scroll = 0,
        const irectangle * clip = 0);

    export extern "C" int __stdcall scroll_window_extended(handle window,
        int x,
        int y,
        const irectangle * scroll,
        const irectangle * clip,
        handle region,
        irectangle * update,
        uint flags);

    export extern "C" bool __stdcall enable_scrollbar(handle window,
        uint flags,
        uint arrows);

    export extern "C" bool __stdcall show_scrollbar(handle window,
        int bar,
        bool show);

    export extern "C" int __stdcall get_scroll_position(handle window,
        int bar);

    export extern "C" int __stdcall set_scroll_position(handle window,
        int bar,
        int position,
        bool redraw);

    export extern "C" bool __stdcall get_scroll_range(handle window,
        int bar,
        int* minimum,
        int* maximum);

    export extern "C" bool __stdcall set_scroll_range(handle window,
        int bar,
        int minimum,
        int maximum,
        bool redraw);

    export extern "C" int __stdcall set_scroll_information(handle window,
        int bar,
        const scrollbar_information * information,
        bool redraw);

    export extern "C" bool __stdcall get_scroll_information(handle window,
        int bar,
        scrollbar_information * information);

    export extern "C" bool __stdcall show_window(handle window,
        int show);

    export extern "C" int __stdcall get_window_text_length(handle window);

    export extern "C" int __stdcall get_window_text_a(handle window,
        char* buffer,
        int length);

    export extern "C" int __stdcall get_window_text_w(handle window,
        wchar_t* buffer,
        int length);

    export template<class character>
        inline int get_window_text(handle window,
            character* buffer,
            int length)
    {
        if (sizeof(character) == 1)
            return get_window_text_a(window,
                (char*)buffer,
                length);
        else
            return get_window_text_w(window,
                (wchar_t*)buffer,
                length);
    }

    export extern "C" bool __stdcall set_window_text_a(handle window,
        const char* string);

    export extern "C" bool __stdcall set_window_text_w(handle window,
        const wchar_t* string);

    export template<class character>
        inline bool set_window_text(handle window,
            const character* string)
    {
        if (sizeof(character) == 1)
            return set_window_text_a(window,
                (const char*)string);
        else
            return set_window_text_w(window,
                (const wchar_t*)string);
    }

    export extern "C" uint __stdcall get_window_thread_process_identity(handle window,
        uint * process);

    export extern "C" ulong __stdcall set_timer(handle window,
        ulong identity,
        uint timeout,
        timer_procedure procedure = 0);

    export extern "C" bool __stdcall cancel_timer(handle window,
        ulong identity);

    export extern "C" bool __stdcall bring_window_to_top(handle window);

    export extern "C" bool __stdcall update_window(handle window);

    export extern "C" bool __stdcall get_update_rectangle(handle window,
        irectangle * update,
        bool erase = false);

    export extern "C" int __stdcall get_update_region(handle window,
        handle region,
        bool erase = false);

    export extern "C" int __stdcall set_window_region(handle window,
        handle region,
        bool redraw);

    export extern "C" int __stdcall get_window_region(handle window,
        handle region);

    export extern "C" int __stdcall get_window_region_box(handle window,
        irectangle * regionrectangle);

    export extern "C" part __stdcall get_window_part(handle window,
        int index);

    export extern "C" part __stdcall set_window_part(handle window,
        int index,
        part value);

    export extern "C" bool __stdcall set_window_position(handle window,
        handle after,
        int x,
        int y,
        int width,
        int height,
        uint flags);

    export extern "C" handle __stdcall get_window(handle window,
        uint command);

    export extern "C" result __stdcall call_window_procedure_a(procedure previous,
        handle window,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" result __stdcall call_window_procedure_w(procedure previous,
        handle window,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" inline result call_window_procedure(procedure previous,
        handle window,
        uint message,
        parameter parameter1,
        parameter parameter2)
    {
        return call_window_procedure_w(previous,
            window,
            message,
            parameter1,
            parameter2);
    }

    export extern "C" handle __stdcall begin_defer_window_positioning(int windows);

    export extern "C" handle __stdcall defer_window_positioning(handle information,
        handle window,
        handle after,
        int x,
        int y,
        int width,
        int height,
        uint flags);

    export extern "C" bool __stdcall end_defer_window_positioning(handle information);

    export extern "C" result __stdcall default_window_procedure_a(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" result __stdcall default_window_procedure_w(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export  result   default_window_procedure(handle window,
        uint message,
        parameter parameter1,
        parameter parameter2)
    {
        return default_window_procedure_w(window,
            message,
            parameter1,
            parameter2);
    }



    export extern "C" handle __stdcall set_active_window(handle window);

    export extern "C" handle __stdcall get_foreground_window();

    export extern "C" bool __stdcall set_foreground_window(handle window);

    export extern "C" bool __stdcall lock_window_update(handle lock);

    export extern "C" bool __stdcall destroy_caret();

    export extern "C" uint __stdcall get_caret_blink_time();

    export extern "C" bool __stdcall set_caret_blink_time(uint milliseconds);

    export extern "C" bool __stdcall get_caret_position(ipoint * position);

    export extern "C" bool __stdcall set_caret_position(int x,
        int y);

    export extern "C" bool __stdcall adjust_window_rectangle(irectangle * adjust,
        uint style,
        bool menu);

    export extern "C" bool __stdcall adjust_window_rectangle_extended(irectangle * adjust,
        uint style,
        bool menu,
        uint extended_style);

    export extern "C" int __stdcall map_window_points(handle source,
        handle destination,
        ipoint * points,
        uint count);

    export extern "C" bool __stdcall set_system_colors(int count,
        const int* indices,
        const uint * red_green_blue);

    export extern "C" bool __stdcall enumerate_windows(enumerate_window callback,
        parameter parameter_enumerate);

    export extern "C" bool __stdcall enumerate_thread_windows(uint thread_identity,
        enumerate_window callback,
        parameter parameter_enumerate);

    export extern "C" handle __stdcall find_window_a(const char* class_name,
        const char* window_name);

    export extern "C" handle __stdcall find_window_w(const wchar_t* class_name,
        const wchar_t* window_name);

    export template<class character>
        inline handle find_window(const wchar_t* class_name,
            const wchar_t* window_name)
    {
        if (sizeof(character) == 1)
            return find_window_a((const char*)class_name,
                (const char*)window_name);
        else
            return find_window_w((const wchar_t*)class_name,
                (const wchar_t*)window_name);

    }


    export extern "C" part __stdcall tile_windows(handle parent,
        uint method,
        const irectangle * bounds,
        uint count,
        const handle * children);

    export extern "C" part __stdcall cascade_windows(handle parent,
        uint method,
        const irectangle * bounds,
        uint count,
        const handle * children);

    //*** cursors

    export extern "C" handle __stdcall load_cursor_a(handle module,
        const char* name);

    export extern "C" handle __stdcall load_cursor_w(handle module,
        const wchar_t* name);

    export template<class character>
        inline handle load_cursor(handle module,
            const character* name)
    {
        if (sizeof(character) == 1)
            return load_cursor_a(module,
                (const char*)name);
        else
            return load_cursor_w(module,
                (const wchar_t*)name);
    }

    export extern "C" handle __stdcall load_cursor_from_file_a(const char* file_name);

    export extern "C" handle __stdcall load_cursor_from_file_w(const wchar_t* file_name);

    export template<class character>
        inline handle load_cursor_from_file(const character* file_name)
    {
        if (sizeof(character) == 1)
            return load_cursor_from_file_a((const char*)file_name);
        else
            return load_cursor_from_file_w((const wchar_t*)file_name);
    }

    export extern "C" handle __stdcall create_cursor(handle module,
        int x_hotspot,
        int y_hotspot,
        int width,
        int height,
        const void* and_plane,
        const void* xor_plane);

    export extern "C" bool __stdcall destroy_cursor(handle cursor);

    export extern "C" int __stdcall show_cursor(bool show);

    export extern "C" bool __stdcall set_cursor_position(int x,
        int y);

    export extern "C" handle __stdcall set_cursor(handle cursor);

    export extern "C" bool __stdcall get_cursor_position(ipoint * position);

    export extern "C" bool __stdcall clip_cursor(const irectangle * bounds);

    export extern "C" bool __stdcall get_clip_cursor(irectangle * bounds);

    export extern "C" handle __stdcall get_cursor();

    //*** icons

    export extern "C" handle __stdcall load_icon_a(handle module,
        const char* name);

    export extern "C" handle __stdcall load_icon_w(handle module,
        const wchar_t* name);

    export template<class character>
        inline handle load_icon(handle module,
            const character* name)
    {
        if (sizeof(character) == 1)
            return load_icon_a(module,
                (const char*)name);
        else
            return load_icon_w(module,
                (const wchar_t*)name);
    }

    export extern "C" handle __stdcall create_icon(handle module,
        int width,
        int height,
        byte planes,
        byte bits_pixel,
        const byte * and_bits,
        const byte * exclusive_or_bits);

    export extern "C" handle __stdcall create_icon_from_resource(byte * bits,
        uint size,
        bool icon,
        uint version);

    export extern "C" handle __stdcall create_icon_from_resource_extended(byte * bits,
        uint size,
        bool icon,
        uint version,
        int width,
        int height,
        uint flags);

    export extern "C" handle __stdcall create_icon_indirect(icon_information * information);

    export extern "C" bool __stdcall destroy_icon(handle icon);

    export extern "C" handle __stdcall copy_icon(handle icon);

    export extern "C" handle copy_cursor(handle cursor) { return copy_icon(cursor); }

    export extern "C" int __stdcall lookup_icon_identity_from_directory(byte * resource_bits,
        bool icon);

    export extern "C" int __stdcall lookup_icon_identity_from_directory_extended(byte * resource_bits,
        bool icon,
        int width,
        int height,
        uint flags);

    export extern "C" bool __stdcall get_icon_information(handle icon,
        icon_information * information);

    //*** clipboards

    export extern "C" handle __stdcall get_open_clipboard_window();

    export extern "C" bool __stdcall open_clipboard(handle owner);

    export extern "C" bool __stdcall close_clipboard();

    export extern "C" handle __stdcall get_clipboard_owner();

    export extern "C" handle __stdcall set_clipboard_viewer(handle viewer);

    export extern "C" handle __stdcall get_clipboard_viewer();

    export extern "C" bool __stdcall change_clipboard_chain(handle remove,
        handle next);

    export extern "C" handle __stdcall set_clipboard_data(uint format,
        handle memory);

    export extern "C" handle __stdcall get_clipboard_data(uint format);

    export extern "C" uint __stdcall register_clipboard_format_a(const char* format);

    export extern "C" uint __stdcall register_clipboard_format_w(const wchar_t* format);

    export template<class character>
        inline uint register_clipboard_format(const character* format)
    {
        if (sizeof(character) == 1)
            return register_clipboard_format_a((const char*)format);
        else
            return register_clipboard_format_w((const wchar_t*)format);
    }

    export extern "C" int __stdcall count_clipboard_formats();

    export extern "C" uint __stdcall enumerate_clipboard_formats(uint format);

    export extern "C" int __stdcall get_clipboard_format_name(uint format,
        character * name,
        int length);

    export extern "C" bool __stdcall empty_clipboard();

    export extern "C" bool __stdcall is_clipboard_format_available(uint format);

    export extern "C" int __stdcall get_priority_clipboard_format(uint * priority_list,
        int formats);

    //*** keyboards

    export extern "C" handle __stdcall get_keyboard_layout(uint thread);

    export extern "C" uint __stdcall get_keyboard_layout_list(int count,
        handle * layouts);

    export extern "C" handle __stdcall load_keyboard_layout_a(const char* name,
        uint flags);

    export extern "C" handle __stdcall load_keyboard_layout_w(const wchar_t* name,
        uint flags);

    export template<class character>
        inline handle load_keyboard_layout(const character* name,
            uint flags)
    {
        if (sizeof(character) == 1)
            return load_keyboard_layout_a((const char*)name,
                flags);
        else
            return load_keyboard_layout_w((const wchar_t*)name,
                flags);
    }

    export extern "C" handle __stdcall activate_keyboard_layout(handle layout,
        uint flags);

    export extern "C" bool __stdcall unload_keyboard_layout(handle layout);

    export extern "C" bool __stdcall get_keyboard_layout_name_a(char* buffer);

    export extern "C" bool __stdcall get_keyboard_layout_name_w(wchar_t* buffer);

    export template <class character>
        inline bool get_keyboard_layout_name(character* buffer)
    {
        if (sizeof(character) == 1)
            return get_keyboard_layout_name_a((char*)buffer);
        else
            return get_keyboard_layout_name_w((wchar_t*)buffer);
    }

    //*** dialogs

    export extern "C" handle __stdcall create_dialog_a(handle module,
        const char* name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter);

    export extern "C" handle __stdcall create_dialog_w(handle module,
        const wchar_t* name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter);

    export template<class character>
        inline handle create_dialog(handle module,
            const character* name,
            handle parent,
            dialog_procedure procedure,
            parameter creation_parameter = 0)
    {
        if (sizeof(character) == 1)
            return create_dialog_a(module,
                (const char*)name,
                parent,
                procedure,
                creation_parameter);
        else
            return create_dialog_w(module,
                (const wchar_t*)name,
                parent,
                procedure,
                creation_parameter);

    }

    export extern "C" handle __stdcall create_dialog_indirect_a(handle module,
        dialog_template * name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter = 0);

    export extern "C" handle __stdcall create_dialog_indirect_w(handle module,
        dialog_template * name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter = 0);

    export extern "C" inline handle create_dialog_indirect(handle module,
        dialog_template * name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter = 0)
    {
        return create_dialog_indirect_w(module,
            name,
            parent,
            procedure,
            creation_parameter);
    }

    export extern "C" void* __stdcall dialog_box_a(handle module,
        const char* name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter);

    export extern "C" void* __stdcall dialog_box_w(handle module,
        const wchar_t* name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter);

    export template<class character>
        inline void* dialog_box(handle module,
            const character* name,
            handle parent,
            dialog_procedure procedure,
            parameter creation_parameter = 0)
    {
        if (sizeof(character) == 1)
            return dialog_box_a(module,
                (const char*)name,
                parent,
                procedure,
                creation_parameter);
        else
            return dialog_box_w(module,
                (const wchar_t*)name,
                parent,
                procedure,
                creation_parameter);

    }

    export extern "C" void* __stdcall dialog_box_indirect_a(handle module,
        dialog_template * name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter = 0);

    export extern "C" void* __stdcall dialog_box_indirect_w(handle module,
        dialog_template * name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter = 0);

    export extern "C" inline void* dialog_box_indirect(handle module,
        dialog_template * name,
        handle parent,
        dialog_procedure procedure,
        parameter creation_parameter = 0)
    {
        return dialog_box_indirect_w(module,
            name,
            parent,
            procedure,
            creation_parameter);

    }

    export extern "C" bool __stdcall end_dialog(handle dialog,
        void* result);

    export extern "C" bool __stdcall map_dialog_rectangle(handle dialog,
        irectangle * map);

    export extern "C" int __stdcall get_dialog_base_units();

    export extern "C" result __stdcall default_dialog_procedure(handle dialog,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" bool __stdcall is_character_alphabetic_a(char test);

    export extern "C" bool __stdcall is_character_alphabetic_w(wchar_t test);

    export template<class character>
        bool is_character_alphabetic(character test)
    {
        if (sizeof(character) == 1)
            return is_character_alphabetic_a(test);
        else
            return is_character_alphabetic_w(test);
    }

    export extern "C" bool __stdcall is_character_alphanumeric_a(char test);

    export extern "C" bool __stdcall is_character_alphanumeric_w(wchar_t test);

    export template<class character>
        bool is_character_alphanumeric(character test)
    {
        if (sizeof(character) == 1)
            return is_character_alphanumeric_a(test);
        else
            return is_character_alphanumeric_w(test);
    }

    export extern "C" bool __stdcall is_character_upper_case_a(char test);

    export extern "C" bool __stdcall is_character_upper_case_w(wchar_t test);

    export template<class character>
        bool is_character_upper_case(character test)
    {
        if (sizeof(character) == 1)
            return is_character_upper_case_a(test);
        else
            return is_character_upper_case_w(test);
    }

    export extern "C" bool __stdcall is_character_lower_case_a(char test);

    export extern "C" bool __stdcall is_character_lower_case_w(wchar_t test);

    export template<class character>
        bool is_character_lower_case(character test)
    {
        if (sizeof(character) == 1)
            return is_character_lower_case_a(test);
        else
            return is_character_lower_case_w(test);
    }

    //*** menus

    export extern "C" handle __stdcall create_menu();

    export extern "C" handle __stdcall create_popup_menu();

    export extern "C" handle __stdcall load_menu_a(handle module,
        const char* name);

    export extern "C" handle __stdcall load_menu_w(handle module,
        const wchar_t* name);

    export template<class character>
        inline handle load_menu(handle module,
            const character* name)
    {
        if (sizeof(character) == 1)
            return load_menu_a(module,
                (const char*)name);
        else
            return load_menu_w(module,
                (const wchar_t*)name);
    }

    export extern "C" handle __stdcall load_menu_indirect_a(const void* _template);

    export extern "C" handle __stdcall load_menu_indirect_w(const void* _template);

    export extern "C" handle __stdcall get_system_menu(handle window,
        bool revert);

    export extern "C" bool __stdcall destroy_menu(handle menu);

    export extern "C" bool __stdcall append_menu_a(handle menu,
        uint flags,
        void* identity,
        const char* item);

    export extern "C" bool __stdcall append_menu_w(handle menu,
        uint flags,
        void* identity,
        const wchar_t* item);

    export template<class character>
        inline bool append_menu(handle menu,
            uint flags,
            void* identity,
            const character* item)
    {
        if (sizeof(character) == 1)
            return append_menu_a(menu,
                flags,
                identity,
                (const char*)item);
        else
            return append_menu_w(menu,
                flags,
                identity,
                (const wchar_t*)item);
    }

    export extern "C" bool __stdcall change_menu_a(handle menu,
        uint command,
        const char* item,
        uint insert,
        uint flags);

    export extern "C" bool __stdcall change_menu_w(handle menu,
        uint command,
        const wchar_t* item,
        uint insert,
        uint flags);

    export template<class character>
        inline bool change_menu(handle menu,
            uint command,
            const character* item,
            uint insert,
            uint flags)
    {
        if (sizeof(character) == 1)
            return change_menu_a(menu,
                command,
                (const char*)item,
                insert,
                flags);
        else
            return change_menu_w(menu,
                command,
                (const wchar_t*)item,
                insert,
                flags);
    }

    export extern "C" int __stdcall get_menu_check_mark_dimensions();

    export extern "C" bool __stdcall delete_menu(handle menu,
        uint position,
        uint flags);

    export extern "C" bool __stdcall insert_menu_a(handle menu,
        uint position,
        uint flags,
        void* identity,
        const char* item);

    export extern "C" bool __stdcall insert_menu_w(handle menu,
        uint position,
        uint flags,
        void* identity,
        const wchar_t* item);

    export template<class character>
        inline bool insert_menu(handle menu,
            uint position,
            uint flags,
            void* identity,
            const character* item)
    {
        if (sizeof(character) == 1)
            return insert_menu_a(menu,
                position,
                flags,
                identity,
                (const char*)item);
        else
            return insert_menu_w(menu,
                position,
                flags,
                identity,
                (const wchar_t*)item);
    }

    export extern "C" bool __stdcall insert_menu_item_a(handle menu,
        uint item,
        bool by_position,
        menu_item_information<char> *information);

    export extern "C" bool __stdcall insert_menu_item_w(handle menu,
        uint item,
        bool by_position,
        menu_item_information<wchar_t> *information);

    export template<class character>
        inline bool insert_menu_item(handle menu,
            uint item,
            bool by_position,
            menu_item_information<character>* information)
    {
        if (sizeof(character) == 1)
            return insert_menu_item_a(menu,
                item,
                by_position,
                (menu_item_information<char>*) information);
        else
            return insert_menu_item_w(menu,
                item,
                by_position,
                (menu_item_information<wchar_t>*) information);

    }

    export extern "C" bool __stdcall get_menu_item_information_a(handle menu,
        uint item,
        bool by_position,
        menu_item_information<char> *information);

    export extern "C" bool __stdcall get_menu_item_information_w(handle menu,
        uint item,
        bool by_position,
        menu_item_information<wchar_t> *information);

    export template<class character>
        inline bool get_menu_item_information(handle menu,
            uint item,
            bool by_position,
            menu_item_information<character>* information)
    {
        if (sizeof(character) == 1)
            return get_menu_item_information_a(menu,
                item,
                by_position,
                (menu_item_information<char> *) information);
        else
            return get_menu_item_information_w(menu,
                item,
                by_position,
                (menu_item_information<wchar_t> *) information);
    }

    export extern "C" bool __stdcall set_menu_item_information_a(handle menu,
        uint item,
        bool by_position,
        menu_item_information<char> *information);

    export extern "C" bool __stdcall set_menu_item_information_w(handle menu,
        uint item,
        bool by_position,
        menu_item_information<wchar_t> *information);

    export template<class character>
        inline bool set_menu_item_information(handle menu,
            uint item,
            bool by_position,
            menu_item_information<character>* information)
    {
        if (sizeof(character) == 1)
            return set_menu_item_information_a(menu,
                item,
                by_position,
                (menu_item_information<char> *) information);
        else
            return set_menu_item_information_w(menu,
                item,
                by_position,
                (menu_item_information<wchar_t> *) information);
    }

    export extern "C" uint __stdcall get_menu_default_item(handle menu,
        uint by_position,
        uint flags);

    export extern "C" bool __stdcall set_menu_default_item(handle menu,
        uint item,
        bool by_position);

    export extern "C" bool __stdcall set_menu_item_bitmaps(handle menu,
        uint position,
        uint flags,
        handle unchecked,
        handle checked);

    export extern "C" uint __stdcall check_menu_item(handle menu,
        uint identity,
        uint check);

    export extern "C" int __stdcall get_menu_item_count(handle menu);

    export extern "C" uint __stdcall enable_menu_item(handle menu,
        uint identity,
        uint enable);

    export extern "C" uint __stdcall get_menu_item_identity(handle menu,
        int position);

    export extern "C" bool __stdcall modify_menu_a(handle menu,
        uint position,
        uint flags,
        void* identity,
        const char* item);

    export extern "C" bool __stdcall modify_menu_w(handle menu,
        uint position,
        uint flags,
        void* identity,
        const wchar_t* item);

    export template<class character>
        inline bool modify_menu(handle menu,
            uint position,
            uint flags,
            void* identity,
            const character* item)
    {
        if (sizeof(character) == 1)
            return modify_menu_a(menu,
                position,
                flags,
                identity,
                (const char*)item);
        else
            return modify_menu_w(menu,
                position,
                flags,
                identity,
                (const wchar_t*)item);
    }

    export extern "C" bool __stdcall track_popup_menu(handle menu,
        uint flags,
        int x,
        int y,
        int reserved,
        handle owner,
        const irectangle * track);

    export extern "C" bool __stdcall track_popup_menu_extended(handle menu,
        uint flags,
        int x,
        int y,
        handle owner,
        const track_parameters * parameters);

    export extern "C" bool __stdcall remove_menu(handle menu,
        uint position,
        uint flags);

    export extern "C" uint __stdcall get_menu_state(handle menu,
        uint identity,
        uint flags);

    export extern "C" int __stdcall get_menu_string_a(handle menu,
        uint identity,
        char* string,
        int length,
        uint flag);

    export extern "C" int __stdcall get_menu_string_w(handle menu,
        uint identity,
        wchar_t* string,
        int length,
        uint flag);

    export template<class character>
        inline int get_menu_string(handle menu,
            uint identity,
            character* string,
            int length,
            uint flag)
    {
        if (sizeof(character) == 1)
            return get_menu_string_a(menu,
                identity,
                (char*)string,
                length,
                flag);
        else
            return get_menu_string_w(menu,
                identity,
                (wchar_t*)string,
                length,
                flag);
    }

    export extern "C" handle __stdcall get_submenu(handle menu,
        int position);

    //*** accelerators

    export extern "C" handle __stdcall load_accelerators(handle module,
        const character * name);

    export extern "C" handle __stdcall create_accelerator_table(accelerator_entry * entries,
        int count);

    export extern "C" bool __stdcall destroy_accelerator_table(handle accelerator);

    export extern "C" int __stdcall copy_accelerator_table(handle accelerator,
        accelerator_entry * entries,
        int count);

    //*** hooks

    export extern "C" hook __stdcall set_windows_hook_old(int filter_type,
        hook callback);

    export extern "C" bool __stdcall unhook_windows_hook_old(int code,
        hook callback);

    export extern "C" handle __stdcall set_windows_hook(int identity,
        hook callback,
        handle module,
        uint thread);

    export extern "C" bool __stdcall unhook_windows_hook(handle hook);

    export extern "C" uint __stdcall call_next_hook(handle hook,
        int code,
        parameter parameter1,
        parameter parameter2);

    //*** desktops

    export extern "C" handle __stdcall get_thread_desktop(uint thread);

    export extern "C" handle __stdcall create_desktop_a(const char* desktop,
        const char* device,
        const void* device_mode,
        uint flags,
        uint access,
        const security_attributes * security);

    export extern "C" handle __stdcall create_desktop_w(const wchar_t* desktop,
        const wchar_t* device,
        const void* device_mode,
        uint flags,
        uint access,
        const security_attributes * security);

    export template<class character>
        inline handle create_desktop(const character* desktop,
            const character* device,
            const void* device_mode,
            uint flags,
            uint access,
            const security_attributes* security)
    {
        if (sizeof(character) == 1)
            return create_desktop_a((const char*)desktop,
                (const char*)device,
                device_mode,
                flags,
                access,
                security);
        else
            return create_desktop_w((const wchar_t*)desktop,
                (const wchar_t*)device,
                device_mode,
                flags,
                access,
                security);
    }

    export extern "C" handle __stdcall open_desktop_a(const char* desktop,
        uint flags,
        bool inherit,
        uint access);

    export extern "C" handle __stdcall open_desktop_w(const wchar_t* desktop,
        uint flags,
        bool inherit,
        uint access);

    export template<class character>
        inline handle open_desktop(const character* desktop,
            uint flags,
            bool inherit,
            uint access)
    {
        if (sizeof(character) == 1)
            return open_desktop_a((const char*)desktop,
                flags,
                inherit,
                access);
        else
            return open_desktop_w((const wchar_t*)desktop,
                flags,
                inherit,
                access);
    }

    export extern "C" handle __stdcall open_input_desktop(uint flags,
        bool inherit,
        uint access);

    export extern "C" bool __stdcall enumerate_desktops_a(handle station,
        enumerate_desktop_a callback,
        parameter parameter_enumerate);

    export extern "C" bool __stdcall enumerate_desktops_w(handle station,
        enumerate_desktop_w callback,
        parameter parameter_enumerate);

    export  inline bool enumerate_desktops(handle station,
        enumerate_desktop callback,
        parameter parameter_enumerate)
    {
        return enumerate_desktops_w(station,
            (enumerate_desktop_w)callback,
            parameter_enumerate);
    }

    export extern "C" bool __stdcall enumerate_desktop_windows(handle desktop,
        enumerate_window callback,
        parameter parameter_enumerate);

    export extern "C" bool __stdcall switch_desktop(handle desktop);

    export extern "C" bool __stdcall set_thread_desktop(handle desktop);

    export extern "C" bool __stdcall close_desktop(handle desktop);

    export extern "C" handle __stdcall get_process_window_station();

    export extern "C" handle __stdcall create_window_station_a(const char* station,
        uint reserved,
        uint access,
        const security_attributes * security);

    export extern "C" handle __stdcall create_window_station_w(const wchar_t* station,
        uint reserved,
        uint access,
        const security_attributes * security);

    export template<class character>
        inline handle create_window_station(const character* station,
            uint reserved,
            uint access,
            const security_attributes* security)
    {
        if (sizeof(character) == 1)
            return create_window_station_a((const char*)station,
                reserved,
                access,
                security);
        else
            return create_window_station_w((const wchar_t*)station,
                reserved,
                access,
                security);
    }

    export extern "C" handle __stdcall open_window_station_a(const char* station,
        bool inherit,
        uint access);

    export extern "C" handle __stdcall open_window_station_w(const wchar_t* station,
        bool inherit,
        uint access);

    export template<class character>
        inline handle open_window_station(const character* station,
            bool inherit,
            uint access)
    {
        if (sizeof(character) == 1)
            return open_window_station_a((const char*)station,
                inherit,
                access);
        else
            return open_window_station_w((const wchar_t*)station,
                inherit,
                access);
    }

    export extern "C" bool __stdcall enumerate_window_stations_a(enumerate_station_a callback,
        parameter parameter_enumerate);

    export extern "C" bool __stdcall enumerate_window_stations_w(enumerate_station_w callback,
        parameter parameter_enumerate);

    export  inline bool enumerate_window_stations(enumerate_station callback,
        parameter parameter_enumerate)
    {
        return enumerate_window_stations_w((enumerate_station_w)callback,
            parameter_enumerate);
    }

    export extern "C" bool __stdcall close_window_station(handle station);

    export extern "C" bool __stdcall set_process_window_station(handle station);

    //*** miscellaneous windows functions

    export extern "C" handle __stdcall monitor_from_point(ipoint from,
        uint flags);

    export extern "C" handle __stdcall monitor_from_rectangle(const irectangle * from,
        uint flags);

    export extern "C" handle __stdcall monitor_from_window(handle window,
        uint flags);

    export extern "C" bool __stdcall get_monitor_information_a(handle monitor,
        monitor_information * information);

    export extern "C" bool __stdcall get_monitor_information_w(handle monitor,
        monitor_information * information);

    export  inline bool get_monitor_information(handle monitor,
        monitor_information* information)
    {
        return get_monitor_information_w(monitor,
            information);
    }

    export  extern "C"  bool __stdcall enumerate_display_monitors(handle device,
        const irectangle * clip,
        monitor callback,
        parameter parameter_enumerate);

    export extern "C"  void __stdcall notify_windows_event(uint event,
        handle window,
        int object_identity,
        int child_identity);

    export extern "C" int __stdcall change_display_settings_a(device_mode<char> *mode,
        uint flags);

    export extern "C" int __stdcall change_display_settings_w(device_mode<wchar_t> *mode,
        uint flags);

    export template<class character>
        inline int change_display_settings(device_mode<character>* mode,
            uint flags)
    {
        if (sizeof(character) == 1)
            return change_display_settings_a((device_mode<char> *) mode,
                flags);
        else
            return change_display_settings_w((device_mode<wchar_t> *) mode,
                flags);
    }

    export extern "C" int __stdcall change_display_settings_extended_a(const char* device_name,
        device_mode<char> *mode,
        handle window,
        uint flags,
        void* parameters);

    export extern "C" int __stdcall change_display_settings_extended_w(const wchar_t* device_name,
        device_mode<wchar_t> *mode,
        handle window,
        uint flags,
        void* parameters);

    export template<class character>
        inline int change_display_settings_extended(const character* device_name,
            device_mode<character>* mode,
            handle window,
            uint flags,
            void* parameters)
    {
        if (sizeof(character) == 1)
            return change_display_settings_extended_a((const char*)device_name,
                (device_mode<char> *) mode,
                window,
                flags,
                parameters);
        else
            return change_display_settings_extended_w((const wchar_t*)device_name,
                (device_mode<wchar_t> *) mode,
                window,
                flags,
                parameters);
    }

    export extern "C" bool __stdcall enumerate_display_settings_a(const char* device_name,
        uint mode_value,
        device_mode<char> *mode);

    export extern "C" bool __stdcall enumerate_display_settings_w(const wchar_t* device_name,
        uint mode_value,
        device_mode<wchar_t> *mode);

    export template<class character>
        inline bool enumerate_display_settings(const character* device_name,
            uint mode_value,
            device_mode<character>* mode)
    {
        if (sizeof(character) == 1)
            return enumerate_display_settings_a((const char*)device_name,
                mode_value,
                (device_mode<char> *) mode);
        else
            return enumerate_display_settings_w((const wchar_t*)device_name,
                mode_value,
                (device_mode<wchar_t> *) mode);
    }

    export extern "C" bool __stdcall enumerate_display_devices_a(void* reserved,
        uint device_number,
        display_device<char> *device,
        uint flags);

    export extern "C" bool __stdcall enumerate_display_devices_w(void* reserved,
        uint device_number,
        display_device<wchar_t> *device,
        uint flags);

    export template<class character>
        inline bool enumerate_display_devices(void* reserved,
            uint device_number,
            display_device<character>* device,
            uint flags)
    {
        if (sizeof(character) == 1)
            return enumerate_display_devices_a(reserved,
                device_number,
                (display_device<char> *) device,
                flags);
        else
            return enumerate_display_devices_w(reserved,
                device_number,
                (display_device<wchar_t> *) device,
                flags);
    }

    export extern "C" bool __stdcall drag_detect(handle drag,
        ipoint position);

    export extern "C" uint __stdcall send_input(uint number_ofinputs,
        input * input_array,
        int size_input);

    export extern "C" handle __stdcall set_windows_event_hook(uint event_minimum,
        uint event_maximum,
        handle module,
        windows_event event,
        uint process_identity,
        uint thread_identity,
        uint flags);

    export extern "C" bool __stdcall unhook_windows_event(handle hook);

    export extern "C" uint __stdcall get_window_module_file_name_a(handle window,
        char* file_name,
        uint buffer_size);

    export extern "C" uint __stdcall get_window_module_file_name_w(handle window,
        wchar_t* file_name,
        uint buffer_size);

    export template<class character>
        inline uint get_window_module_file_name(handle window,
            character* file_name,
            uint buffer_size)
    {
        if (sizeof(character) == 1)
            return get_window_module_file_name_a(window,
                (char*)file_name,
                buffer_size);
        else
            return get_window_module_file_name_w(window,
                (wchar_t*)file_name,
                buffer_size);
    }

    export extern "C" bool __stdcall get_cursor_information(cursor_control_information * information);

    export extern "C" bool __stdcall get_window_information(handle window,
        window_information * information);

    export extern "C" bool __stdcall get_titlebar_information(handle window,
        titlebar_information * information);

    export extern "C" bool __stdcall get_menubar_information(handle window,
        int object_identity,
        int item_identity,
        menubar_information * information);

    export extern "C" bool __stdcall get_scrollbar_control_information(handle window,
        int object_identity,
        scrollbar_control_information * information);

    export extern "C" bool __stdcall get_combobox_information(handle combo,
        combobox_information * information);

    export extern "C" bool __stdcall get__thread_information(uint thread_identity,
        _thread_information * information);

    export extern "C" bool __stdcall get_last_input_information(input_information * information);

    export extern "C" int __stdcall broadcast_system_message(uint flags,
        uint * recipients,
        uint message,
        parameter parameter1,
        parameter parameter2);

    export extern "C" int __stdcall get_mouse_move_points(uint size,
        const mouse_move_point * search,
        mouse_move_point * buffer,
        int points,
        uint resolution);

    export extern "C" uint __stdcall drag_query_file_a(handle drop,
        uint index,
        char* file,
        uint length);

    export extern "C" uint __stdcall drag_query_file_w(handle drop,
        uint index,
        wchar_t* file,
        uint length);

    export template<class character>
        inline uint drag_query_file(handle drop,
            uint index,
            character* file,
            uint length)
    {
        if (sizeof(character) == 1)
            return drag_query_file_a(drop,
                index,
                (char*)file,
                length);
        else
            return drag_query_file_w(drop,
                index,
                (wchar_t*)file,
                length);
    }

    export extern "C" bool __stdcall drag_query_point(handle drop,
        ipoint * position);

    export extern "C" void __stdcall drag_finish(handle drop);

    export extern "C" bool __stdcall track_mouse_event(mouse_track * event_track);

    export extern "C" handle __stdcall load_image(handle module,
        const character * name,
        uint type,
        int width,
        int height,
        uint flags);

    export extern "C" handle __stdcall copy_image(handle image,
        uint type,
        int width,
        int height,
        uint flags);

    export extern "C" void __stdcall init_common_controls(void);

    export extern "C" uint __stdcall get_system_color(int index);

    export extern "C" int __stdcall to_ascii(uint v_key,
        uint scancode,
        byte * key_state,
        wchar_t* buffer,
        uint flags);

    export extern "C" int __stdcall to_ascii_extended(uint v_key,
        uint scancode,
        byte * key_state,
        wchar_t* buffer,
        uint flags,
        handle layout);

    export extern "C" int __stdcall tounicode(uint v_key,
        uint scan_code,
        byte * key_state,
        wchar_t* buffer,
        int length,
        uint flags);

    export extern "C" int __stdcall tounicode_extended(uint v_key,
        uint scan_code,
        byte * key_state,
        wchar_t* buffer,
        int length,
        uint flags,
        handle layout);

    export extern "C" uint __stdcall scan_local_key(part oem_character);

    export extern "C" void __stdcall keyboard_event(byte v_key,
        byte scan_code,
        uint flags,
        void* extra_information);

    export extern "C" void __stdcall mouse_event(uint flags,
        uint x,
        uint y,
        uint buttons,
        void* extra_information);

    export extern "C" bool __stdcall get_input_state();

    export extern "C" bool __stdcall swap_mouse_button(bool swap);

    export extern "C" uint __stdcall get_keyboard_codepage();

    export extern "C" short __stdcall get_key_state(int v_key);

    export extern "C" short __stdcall get_asynchronous_key_state(int v_key);

    export extern "C" bool __stdcall set_user_object_security(handle object,
        uint * information_set,
        void* identity_information);

    export extern "C" bool __stdcall get_user_object_security(handle object,
        uint * information_get,
        void* identity_information,
        uint length,
        uint * length_needed);

    export extern "C" bool __stdcall set_user_object_information(handle object,
        int index,
        const void* information,
        uint length);

    export extern "C" bool __stdcall get_user_object_information(handle object,
        int index,
        void* information,
        uint length,
        uint * length_needed);

    export extern "C" bool __stdcall exit_windows(uint flags = exit_flag::logoff,
        uint reserved = 0);

    export extern "C" bool __stdcall get_keyboard_state(byte * key_state);

    export extern "C" bool __stdcall set_keyboard_state(byte * key_state);

    export extern "C" int __stdcall get_key_name_text_a(parameter parameter2,
        char* string,
        int size);

    export extern "C" int __stdcall get_key_name_text_w(parameter parameter2,
        wchar_t* string,
        int size);

    export template<class character>
        inline int get_key_name_text(parameter parameter2,
            character* string,
            int size)
    {
        if (sizeof(character) == 1)
            return get_key_name_text_a(parameter2,
                (char*)string,
                size);
        else
            return get_key_name_text_w(parameter2,
                (wchar_t*)string,
                size);
    }

    export extern "C" int __stdcall get_keyboard_type(int type_flag);

    export extern "C" int __stdcall get_system_metrics(int index);

    export extern "C" int __stdcall load_string_a(handle module,
        uint identity,
        char* buffer,
        int length);

    export extern "C" int __stdcall load_string_w(handle module,
        uint identity,
        wchar_t* buffer,
        int length);

    export template<class character>
        inline int load_string(handle module,
            uint identity,
            character* buffer,
            int length)
    {
        if (sizeof(character) == 1)
            return load_string_a(module,
                identity,
                (char*)buffer,
                length);
        else
            return load_string_w(module,
                identity,
                (wchar_t*)buffer,
                length);
    }

    export extern "C" bool __stdcall system_parameters_information(uint action,
        uint parameter,
        void* ipointer,
        uint initial);

    export extern "C" short __stdcall scan_virtual_key(character scan);

    export extern "C" short __stdcall scan_virtual_key_extended(character scan,
        handle layout);

    export extern "C" uint __stdcall map_virtual_key(uint code,
        uint type);

    export extern "C" uint __stdcall map_virtual_key_extended(uint code,
        uint type,
        handle layout);

    //--------------------------------------------------------------------------
    // **** GDI+ Section ****
    //--------------------------------------------------------------------------

    export  typedef _int64 uint64;
    export  typedef int pixel_format;

    export extern "C" uint get_pixel_format_size(pixel_format pixfmt) { return (pixfmt >> 8) & 0xff; }

    //export extern "C" bool is_indexed_pixel_format(pixel_format pixfmt) { return (pixfmt & pixel_format_indexed) != 0; }

    //export extern "C" bool is_alphapixel_format(pixel_format pixfmt) { return (pixfmt & pixel_format_alpha) != 0; }

    //export extern "C" bool is_extended_pixel_format(pixel_format pixfmt) { return (pixfmt & pixel_format_extended) != 0; }

    //export extern "C" bool is_canonical_pixel_format(pixel_format pixfmt) { return (pixfmt & pixel_format_canonical) != 0; }

    export struct palette_flags
    {
        enum
        {
            has_alpha = 0x0001,
            gray_scale = 0x0002,
            halftone = 0x0004
        };
    };

    export struct color_palette
    {
        uint flags;
        uint count;
        uint entries[1];
    };

    //--------------------------------------------------------------------------
    // callback functions
    //--------------------------------------------------------------------------

    extern "C" {export  typedef bool(__stdcall* enumerate_metafile_proc)(uint, uint, uint, const byte*, void*);}

    //--------------------------------------------------------------------------
    // represents a rectangle in a 2d coordinate system (integer coordinates)
    //--------------------------------------------------------------------------

    export struct rectangle
    {
        rectangle()
        {
            x = y = width = height = 0;
        }

        rectangle(int _x,
            int _y,
            int _width,
            int _height)
        {
            x = _x;
            y = _y;
            width = _width;
            height = _height;
        }


        int x;
        int y;
        int width;
        int height;
    };

    //--------------------------------------------------------------------------
    // status return values from gdi+ methods
    //--------------------------------------------------------------------------

    export struct _status
    {
        enum
        {
            ok = 0,
            generic_error = 1,
            invalidparameter = 2,
            out_ofmemory = 3,
            object_busy = 4,
            insufficient_buffer = 5,
            not_implemented = 6,
            win32error = 7,
            wrong_state = 8,
            aborted = 9,
            file_not_found = 10,
            value_overflow = 11,
            access_denied = 12,
            unknown_image_format = 13,
            font_family_not_found = 14,
            font_style_not_found = 15,
            not_true_type_font = 16,
            unsupported_gdiplus_version = 17,
            gdiplus_not_initialized = 18,
            property_not_found = 19,
            property_not_supported = 20
        };
    };

    //--------------------------------------------------------------------------
    // represents a rectangle in a 2d coordinate system (floating-ipoint coordinates)
    //--------------------------------------------------------------------------

    export struct rectanglef
    {
        rectanglef()
        {
            x = y = width = height = 0.0f;
        }

        rectanglef(float _x,
            float _y,
            float _width,
            float _height)
        {
            x = _x;
            y = _y;
            width = _width;
            height = _height;
        }

        float x;
        float y;
        float width;
        float height;
    };

    export struct path_data
    {
        path_data()
        {
            count = 0;
            points = 0;
            types = 0;
        }

        ~path_data()
        {
            if (points != 0)
            {
                delete points;
            }

            if (types != 0)
            {
                delete types;
            }
        }

        int count;
        pointf* points;
        byte* types;
    };

    export struct character_range
    {
        character_range(int first, int length) : first(first), length(length) {}

        character_range() : first(0), length(0) {}

        character_range& operator = (character_range& copy)
        {
            first = copy.first;
            length = copy.length;
            return *this;
        }

        int first;
        int length;
    };

    export struct logical_font_ascii
    {
        int height;
        int width;
        int escapement;
        int orientation;
        int weight;
        byte italic;
        byte underline;
        byte strikeout;
        byte character_set;
        byte output_precision;
        byte clip_precision;
        byte quality;
        byte pitch_and_family;
        char face_name[face_size];
    };

    export struct logical_font_wide
    {
        int height;
        int width;
        int escapement;
        int orientation;
        int weight;
        byte italic;
        byte underline;
        byte strikeout;
        byte character_set;
        byte output_precision;
        byte clip_precision;
        byte quality;
        byte pitch_and_family;
        wchar_t face_name[face_size];
    };



    //---------------------------------------------------------------------------
    // forward references
    //---------------------------------------------------------------------------

    export struct graphics;
    export struct pen;
    export struct brush;
    //export struct matrix;
    export struct bitmap;
    export struct metafile;
    export struct path;
    export struct path_iterator;
    export struct region;
    export struct image;
    export struct texture_brush;
    export struct hatch_brush;
    export struct solid_brush;
    export struct linear_gradient_brush;
    export struct path_gradient_brush;
    export struct font;
    export struct font_family;
    export struct font_collection;
    export struct installed_font_collection;
    export struct private_font_collection;
    export struct image_attributes;
    export struct cached_bitmap;

    //---------------------------------------------------------------------------
    // private classes
    //---------------------------------------------------------------------------

    export struct _space {};
    export struct _brush {};
    export struct _texture : public _brush {};
    export struct _solid_fill : public _brush {};
    export struct _line_gradient : public _brush {};
    export struct _path_gradient : public _brush {};
    export struct _hatch : public _brush {};
    export struct _pen {};
    export struct _custom_line_cap {};
    export struct _adjustable_arrow_cap : public _custom_line_cap {};
    export struct _image {};
    export struct _bitmap : public _image {};
    export struct _metafile : public _image {};
    export struct _image_attributes {};
    export struct _path {};
    export struct _region {};
    export struct _path_iterator {};
    export struct _font_family {};
    export struct _font {};
    export struct _string_format {};
    export struct _font_collection {};
    export struct _installed_font_collection : public _font_collection {};
    export struct _private_font_collection : public _font_collection {};
    export struct _cached_bitmap {};
    export struct _matrix {};

    //----------------------------------------------------------------------------
    // color matrix
    //----------------------------------------------------------------------------

    export struct color_matrix
    {
        float m[5][5];
    };

    //----------------------------------------------------------------------------
    // color matrix flags
    //----------------------------------------------------------------------------

    export struct color_matrix_flag
    {
        enum
        {
            _default = 0,
            skip_grays = 1,
            alt_gray = 2
        };
    };

    //----------------------------------------------------------------------------
    // color adjust type
    //----------------------------------------------------------------------------

    export struct color_adjust_type
    {
        enum
        {
            _default,
            bitmap,
            brush,
            pen,
            text,
            count,
            any
        };
    };

    //----------------------------------------------------------------------------
    // color map
    //----------------------------------------------------------------------------

    export struct _color_map
    {
        uint old_color;
        uint new_color;
    };

    //----------------------------------------------------------------------------
    // color mode
    //----------------------------------------------------------------------------

    export struct color_mode
    {
        enum
        {
            red_green_blue32 = 0,
            red_green_blue64 = 1
        };
    };

    //----------------------------------------------------------------------------
    // color channel flags
    //----------------------------------------------------------------------------

    export struct color_channel_flag
    {
        enum
        {
            c = 0,
            m,
            y,
            k,
            last
        };
    };

    //----------------------------------------------------------------------------
    // color
    //----------------------------------------------------------------------------

    export struct color
    {
        color()
        {
            argb = (uint)color::black;
        }

        color(byte r,
            byte g,
            byte b)
        {
            argb = make_red_green_blue(255, r, g, b);
        }

        color(byte a,
            byte r,
            byte g,
            byte b)
        {
            argb = make_red_green_blue(a, r, g, b);
        }

        color(uint argb)
        {
            argb = argb;
        }


        uint get_value() const
        {
            return argb;
        }

        void set_value(uint argb)
        {
            argb = argb;
        }

        // common color constants

        enum
        {
            alice_blue = 0xfff0f8ff,
            antique_white = 0xfffaebd7,
            aqua = 0xff00ffff,
            aquamarine = 0xff7fffd4,
            azure = 0xfff0ffff,
            beige = 0xfff5f5dc,
            bisque = 0xffffe4c4,
            black = 0xff000000,
            blanched_almond = 0xffffebcd,
            blue = 0xff0000ff,
            blue_violet = 0xff8a2be2,
            brown = 0xffa52a2a,
            burly_wood = 0xffdeb887,
            cadet_blue = 0xff5f9ea0,
            chartreuse = 0xff7fff00,
            chocolate = 0xffd2691e,
            coral = 0xffff7f50,
            corn_flower_blue = 0xff6495ed,
            corn_silk = 0xfffff8dc,
            crimson = 0xffdc143c,
            cyan = 0xff00ffff,
            dark_blue = 0xff00008b,
            dark_cyan = 0xff008b8b,
            dark_golden_rod = 0xffb8860b,
            dark_gray = 0xffa9a9a9,
            dark_green = 0xff006400,
            dark_khaki = 0xffbdb76b,
            dark_magenta = 0xff8b008b,
            dark_olive_green = 0xff556b2f,
            dark_orange = 0xffff8c00,
            dark_orchid = 0xff9932cc,
            dark_red = 0xff8b0000,
            dark_salmon = 0xffe9967a,
            dark_seagreen = 0xff8fbc8b,
            dark_slate_blue = 0xff483d8b,
            dark_slate_gray = 0xff2f4f4f,
            dark_turquoise = 0xff00ced1,
            dark_violet = 0xff9400d3,
            deep_pink = 0xffff1493,
            deep_sky_blue = 0xff00bfff,
            dim_gray = 0xff696969,
            dodger_blue = 0xff1e90ff,
            firebrick = 0xffb22222,
            floral_white = 0xfffffaf0,
            forest_green = 0xff228b22,
            fuchsia = 0xffff00ff,
            gainsboro = 0xffdcdcdc,
            ghost_white = 0xfff8f8ff,
            gold = 0xffffd700,
            goldenrod = 0xffdaa520,
            gray = 0xff808080,
            green = 0xff008000,
            green_yellow = 0xffadff2f,
            honeydew = 0xfff0fff0,
            hot_pink = 0xffff69b4,
            indian_red = 0xffcd5c5c,
            indigo = 0xff4b0082,
            ivory = 0xfffffff0,
            khaki = 0xfff0e68c,
            lavender = 0xffe6e6fa,
            lavender_blush = 0xfffff0f5,
            lawn_green = 0xff7cfc00,
            lemon_chiffon = 0xfffffacd,
            light_blue = 0xffadd8e6,
            light_coral = 0xfff08080,
            light_cyan = 0xffe0ffff,
            light_golden_rod_yellow = 0xfffafad2,
            light_gray = 0xffd3d3d3,
            light_green = 0xff90ee90,
            light_pink = 0xffffb6c1,
            light_salmon = 0xffffa07a,
            light_sea_green = 0xff20b2aa,
            light_sky_blue = 0xff87cefa,
            light_slate_gray = 0xff778899,
            light_steel_blue = 0xffb0c4de,
            light_yellow = 0xffffffe0,
            lime = 0xff00ff00,
            lime_green = 0xff32cd32,
            linen = 0xfffaf0e6,
            magenta = 0xffff00ff,
            maroon = 0xff800000,
            medium_aquamarine = 0xff66cdaa,
            medium_blue = 0xff0000cd,
            medium_orchid = 0xffba55d3,
            medium_purple = 0xff9370db,
            medium_sea_green = 0xff3cb371,
            medium_slate_blue = 0xff7b68ee,
            medium_spring_green = 0xff00fa9a,
            medium_turquoise = 0xff48d1cc,
            medium_violet_red = 0xffc71585,
            midnight_blue = 0xff191970,
            mint_cream = 0xfff5fffa,
            misty_rose = 0xffffe4e1,
            moccasin = 0xffffe4b5,
            navajo_white = 0xffffdead,
            navy = 0xff000080,
            old_lace = 0xfffdf5e6,
            olive = 0xff808000,
            olive_drab = 0xff6b8e23,
            orange = 0xffffa500,
            orange_red = 0xffff4500,
            orchid = 0xffda70d6,
            pale_golden_rod = 0xffeee8aa,
            pale_green = 0xff98fb98,
            pale_turquoise = 0xffafeeee,
            pale_violet_red = 0xffdb7093,
            papaya_whip = 0xffffefd5,
            peach_puff = 0xffffdab9,
            peru = 0xffcd853f,
            pink = 0xffffc0cb,
            plum = 0xffdda0dd,
            powder_blue = 0xffb0e0e6,
            purple = 0xff800080,
            red = 0xffff0000,
            rosy_brown = 0xffbc8f8f,
            royal_blue = 0xff4169e1,
            saddle_brown = 0xff8b4513,
            salmon = 0xfffa8072,
            sandy_brown = 0xfff4a460,
            sea_green = 0xff2e8b57,
            sea_shell = 0xfffff5ee,
            sienna = 0xffa0522d,
            silver = 0xffc0c0c0,
            sky_blue = 0xff87ceeb,
            slate_blue = 0xff6a5acd,
            slate_gray = 0xff708090,
            snow = 0xfffffafa,
            spring_green = 0xff00ff7f,
            steel_blue = 0xff4682b4,
            tan = 0xffd2b48c,
            teal = 0xff008080,
            thistle = 0xffd8bfd8,
            tomato = 0xffff6347,
            transparent = 0x00ffffff,
            turquoise = 0xff40e0d0,
            violet = 0xffee82ee,
            wheat = 0xfff5deb3,
            white = 0xffffffff,
            white_smoke = 0xfff5f5f5,
            yellow = 0xffffff00,
            yellow_green = 0xff9acd32
        };

        // shift count and bit mask for a, r, g, b components

        enum
        {
            shift_alpha = 24,
            shift_red = 16,
            shift_green = 8,
            shift_blue = 0
        };

        enum
        {
            mask_alpha = 0xff000000,
            mask_red = 0x00ff0000,
            mask_green = 0x0000ff00,
            mask_blue = 0x000000ff
        };

        // assemble a, r, g, b values into a 32-bit integer

        static uint make_red_green_blue(byte a,
            byte r,
            byte g,
            byte b)
        {
            return (((uint)(b) << shift_blue) |
                ((uint)(g) << shift_green) |
                ((uint)(r) << shift_red) |
                ((uint)(a) << shift_alpha));
        }

        uint argb;
    };

    //--------------------------------------------------------------------------
    // graphics and container state cookies
    //--------------------------------------------------------------------------

    export  typedef uint _state;
    export  typedef uint _container;

    //--------------------------------------------------------------------------
    // fill mode constants
    //--------------------------------------------------------------------------

    export struct _fill_mode
    {
        enum
        {
            alternate,
            winding
        };
    };

    //--------------------------------------------------------------------------
    // quality mode constants
    //--------------------------------------------------------------------------

    export struct quality_mode
    {
        enum
        {
            invalid = -1,
            _default = 0,
            low = 1,
            high = 2
        };
    };

    //--------------------------------------------------------------------------
    // alpha compositing mode constants
    //--------------------------------------------------------------------------

    export struct compositing_mode
    {
        enum
        {
            source_over,
            source_copy
        };
    };

    //--------------------------------------------------------------------------
    // alpha compositing quality constants
    //--------------------------------------------------------------------------

    export struct compositing_quality
    {
        enum
        {
            invalid = quality_mode::invalid,
            _default = quality_mode::_default,
            high_speed = quality_mode::low,
            high_quality = quality_mode::high,
            gamma_corrected,
            assume_linear
        };
    };

    //--------------------------------------------------------------------------
    // _unit constants
    //--------------------------------------------------------------------------

    export struct _unit
    {
        enum
        {
            world,      // 0 -- world coordinate (non-physical unit)
            display,    // 1 -- variable -- for page_transform only
            pixel,      // 2 -- each unit is one device pixel.
            ipoint,      // 3 -- each unit is a printer's ipoint, or 1/72 inch.
            inch,       // 4 -- each unit is 1 inch.
            document,   // 5 -- each unit is 1/300 inch.
            millimeter  // 6 -- each unit is 1 millimeter.
        };
    };

    export struct metafile_frame_unit
    {
        enum
        {
            pixel = _unit::pixel,
            ipoint = _unit::ipoint,
            inch = _unit::inch,
            document = _unit::document,
            millimeter = _unit::millimeter,
            gdi
        };
    };

    //--------------------------------------------------------------------------
    // coordinate space identifiers
    //--------------------------------------------------------------------------

    export struct coordinate_space
    {
        enum
        {
            world,
            page,
            device
        };
    };

    //--------------------------------------------------------------------------
    // various wrap modes for brushes
    //--------------------------------------------------------------------------

    export struct wrap_mode
    {
        enum
        {
            tile,
            tile_flip_x,
            tile_flip_y,
            tile_flip_xy,
            clamp
        };
    };

    //--------------------------------------------------------------------------
    // various hatch styles
    //--------------------------------------------------------------------------

    export struct _hatch_style
    {
        enum
        {
            horizontal,                     // 0
            vertical,                       // 1
            forwarddiagonal,                // 2
            backwarddiagonal,               // 3
            cross,                          // 4
            diagonal_cross,                 // 5
            percent05,                      // 6
            percent10,                      // 7
            percent20,                      // 8
            percent25,                      // 9
            percent30,                      // 10
            percent40,                      // 11
            percent50,                      // 12
            percent60,                      // 13
            percent70,                      // 14
            percent75,                      // 15
            percent80,                      // 16
            percent90,                      // 17
            light_downward_diagonal,        // 18
            light_upward_diagonal,          // 19
            dark_downward_diagonal,         // 20
            dark_upward_diagonal,           // 21
            wide_downward_diagonal,         // 22
            wide_upward_diagonal,           // 23
            light_vertical,                 // 24
            light_horizontal,               // 25
            narrow_vertical,                // 26
            narrow_horizontal,              // 27
            dark_vertical,                  // 28
            dark_horizontal,                // 29
            dashed_downward_diagonal,       // 30
            dashed_upward_diagonal,         // 31
            dashed_horizontal,              // 32
            dashed_vertical,                // 33
            small_confetti,                 // 34
            large_confetti,                 // 35
            zig_zag,                        // 36
            wave,                           // 37
            diagonal_brick,                 // 38
            horizontal_brick,               // 39
            weave,                          // 40
            plaid,                          // 41
            divot,                          // 42
            dotted_grid,                    // 43
            dotted_diamond,                 // 44
            shingle,                        // 45
            trellis,                        // 46
            sphere,                         // 47
            small_grid,                     // 48
            small_checker_board,            // 49
            large_checker_board,            // 50
            outlined_diamond,               // 51
            solid_diamond,                  // 52

            total,
            large_grid = cross,  // 4

            min = horizontal,
            max = total - 1,
        };
    };

    //--------------------------------------------------------------------------
    // dash style constants
    //--------------------------------------------------------------------------

    export struct dash_style
    {
        enum
        {
            solid,          // 0
            dash,           // 1
            dot,            // 2
            dash_dot,       // 3
            dash_dot_dot,   // 4
            custom          // 5
        };
    };

    //--------------------------------------------------------------------------
    // dash cap constants
    //--------------------------------------------------------------------------

    export struct dash_cap
    {
        enum
        {
            flat = 0,
            round = 2,
            triangle = 3
        };
    };

    //--------------------------------------------------------------------------
    // line cap constants (only the lowest 8 bits are used).
    //--------------------------------------------------------------------------

    export struct line_cap
    {
        enum
        {
            flat = 0,
            square = 1,
            round = 2,
            triangle = 3,
            no_anchor = 0x10, // corresponds to flat cap
            square_anchor = 0x11, // corresponds to square cap
            round_anchor = 0x12, // corresponds to round cap
            diamond_anchor = 0x13, // corresponds to triangle cap
            arrow_anchor = 0x14, // no correspondence
            custom = 0xff, // custom cap
            anchor_mask = 0xf0  // mask to check for anchor or not.
        };
    };

    //--------------------------------------------------------------------------
    // custom line cap type constants
    //--------------------------------------------------------------------------

    export struct custom_line_cap_type
    {
        enum
        {
            _default = 0,
            adjustable_arrow = 1
        };
    };

    //--------------------------------------------------------------------------
    // line join constants
    //--------------------------------------------------------------------------

    export struct line_join
    {
        enum
        {
            mitre = 0,
            bevel = 1,
            round = 2,
            mitre_clipped = 3
        };
    };

    export struct path_point_type
    {
        enum
        {
            start = 0,    // move
            line = 1,    // line
            bezier = 3,    // default bezier (= cubic bezier)
            path_type_mask = 0x07, // type mask (lowest 3 bits).
            dash_mode = 0x10, // currently in dash mode.
            path_marker = 0x20, // a marker for the path.
            close_subpath = 0x80, // closed flag
            bezier3 = 3,    // cubic bezier
        };
    };

    //--------------------------------------------------------------------------
    // warp_mode constants
    //--------------------------------------------------------------------------

    export struct warp_mode
    {
        enum
        {
            perspective,    // 0
            bilinear        // 1
        };
    };

    //--------------------------------------------------------------------------
    // line_gradient mode
    //--------------------------------------------------------------------------

    export struct linear_gradient_mode
    {
        enum
        {
            horizontal,
            vertical,
            forward_diagonal,
            backward_diagonal
        };
    };

    //--------------------------------------------------------------------------
    // region comine modes
    //--------------------------------------------------------------------------

    export struct combine_mode
    {
        enum
        {
            replace,     // 0
            intersect,   // 1
            _union,       // 2
            _xor,         // 3
            exclude,     // 4
            complement   // 5 (exclude from)
        };
    };

    //--------------------------------------------------------------------------
     // image types
    //--------------------------------------------------------------------------

    export struct _image_type
    {
        enum
        {
            unknown,
            bitmap,
            metafile
        };
    };

    //--------------------------------------------------------------------------
    // interpolation modes
    //--------------------------------------------------------------------------

    export struct interpolation_mode
    {
        enum
        {
            invalid = quality_mode::invalid,
            _default = quality_mode::_default,
            low_quality = quality_mode::low,
            high_quality = quality_mode::high,
            bilinear,
            bicubic,
            nearest_neighbor,
            high_quality_bilinear,
            high_quality_bicubic
        };
    };

    //--------------------------------------------------------------------------
    // pen types
    //--------------------------------------------------------------------------

    export struct pen_alignment
    {
        enum
        {
            center = 0,
            inset = 1
        };
    };

    //--------------------------------------------------------------------------
    // brush types
    //--------------------------------------------------------------------------

    export struct brush_type
    {
        enum
        {
            solid_color = 0,
            hatch_fill = 1,
            texture_fill = 2,
            path_gradient = 3,
            linear_gradient = 4
        };
    };

    //--------------------------------------------------------------------------
    // pen's fill types
    //--------------------------------------------------------------------------

    export struct pen_type
    {
        enum
        {
            solid_color = brush_type::solid_color,
            hatch_fill = brush_type::hatch_fill,
            texture_fill = brush_type::texture_fill,
            path_gradient = brush_type::path_gradient,
            linear_gradient = brush_type::linear_gradient,
            unknown = -1
        };
    };

    //--------------------------------------------------------------------------
    // matrix order
    //--------------------------------------------------------------------------

    export struct matrix_order
    {
        enum
        {
            prepend = 0,
            append = 1
        };
    };

    //--------------------------------------------------------------------------
    // generic font families
    //--------------------------------------------------------------------------

    export struct generic_font_family
    {
        enum
        {
            serif,
            sans_serif,
            monospace
        };
    };

    //--------------------------------------------------------------------------
    // font_style: face types and common styles
    //--------------------------------------------------------------------------

    export struct font_style
    {
        enum
        {
            regular = 0,
            bold = 1,
            italic = 2,
            bold_italic = 3,
            underline = 4,
            strikeout = 8
        };
    };

    //---------------------------------------------------------------------------
    // smoothing mode
    //---------------------------------------------------------------------------

    export struct smoothing_mode
    {
        enum
        {
            invalid = quality_mode::invalid,
            _default = quality_mode::_default,
            high_speed = quality_mode::low,
            high_quality = quality_mode::high,
            none,
            anti_alias
        };
    };

    //---------------------------------------------------------------------------
    // pixel format mode
    //---------------------------------------------------------------------------

    export struct pixel_offset_mode
    {
        enum
        {
            invalid = quality_mode::invalid,
            _default = quality_mode::_default,
            high_speed = quality_mode::low,
            high_quality = quality_mode::high,
            none,
            half
        };
    };

    //---------------------------------------------------------------------------
    // text rendering hint
    //---------------------------------------------------------------------------

    export struct text_rendering_hint
    {
        enum
        {
            system_default = 0,            // glyph with system default rendering hint
            single_bit_per_pixel_grid_fit,     // glyph bitmap with hinting
            single_bit_per_pixel,            // glyph bitmap without hinting
            anti_alias_grid_fit,             // glyph anti-alias bitmap with hinting
            hint_anti_alias,                // glyph anti-alias bitmap without hinting
            clear_type_grid_fit              // glyph c_t bitmap with hinting
        };
    };

    //---------------------------------------------------------------------------
    // metafile types
    //---------------------------------------------------------------------------

    export struct metafile_type
    {
        enum
        {
            invalid,            // invalid metafile
            wmf,                // standard w_m_f
            wmf_placeable,       // placeable w_m_f
            emf,                // e_m_f (not e_m_f+)
            emf_plus_only,        // e_m_f+ without dual, down-level records
            emf_plus_dual         // e_m_f+ with dual, down-level records
        };
    };

    //---------------------------------------------------------------------------
    // specifies the type of e_m_f to record
    //---------------------------------------------------------------------------

    export struct enhanced_metafile_type
    {
        enum
        {
            only = metafile_type::emf,          // no e_m_f+, only e_m_f
            plus_only = metafile_type::emf_plus_only,  // no e_m_f, only e_m_f+
            plus_dual = metafile_type::emf_plus_dual   // both e_m_f+ and e_m_f
        };
    };

    //---------------------------------------------------------------------------
    // e_m_f+ persistent object types
    //---------------------------------------------------------------------------

    export struct object_type
    {
        enum
        {
            invalid,
            brush,
            pen,
            path,
            region,
            image,
            font,
            string_format,
            image_attributes,
            custom_line_cap,

            max = object_type::custom_line_cap,
            min = object_type::brush
        };
    };

    export extern "C" bool is_valid_object_type(uint type)
    {
        return ((type >= object_type::min) && (type <= object_type::max));
    }

    export  enum enhanced_plus_record_type
    {
        emfrecord_type_max = 122,
        emfrecord_type_min = 1,
    };

    export struct string_format_flags
    {
        enum
        {
            direction_right_to_left = 0x00000001,
            direction_vertical = 0x00000002,
            no_fit_black_box = 0x00000004,
            display_format_control = 0x00000020,
            no_font_fallback = 0x00000400,
            measure_trailing_spaces = 0x00000800,
            no_wrap = 0x00001000,
            line_limit = 0x00002000,
            no_clip = 0x00004000
        };
    };

    //---------------------------------------------------------------------------
    // string_trimming
    //---------------------------------------------------------------------------

    export struct string_trimming
    {
        enum
        {
            none = 0,
            character = 1,
            word = 2,
            ellipsis_character = 3,
            ellipsis_word = 4,
            ellipsis_path = 5
        };
    };

    //---------------------------------------------------------------------------
    // national language digit substitution
    //---------------------------------------------------------------------------

    export struct string_digit_substitute
    {
        enum
        {
            user = 0,  // as n_l_s setting
            none = 1,
            national = 2,
            traditional = 3
        };
    };

    //---------------------------------------------------------------------------
    // hotkey prefix interpretation
    //---------------------------------------------------------------------------

    export struct hotkey_prefix
    {
        enum
        {
            none = 0,
            show = 1,
            hide = 2
        };
    };

    //---------------------------------------------------------------------------
    // string alignment flags
    //---------------------------------------------------------------------------

    export struct string_alignment
    {
        enum
        {
            near = 0,
            center = 1,
            far = 2
        };
    };

    //---------------------------------------------------------------------------
    // driver_string_options
    //---------------------------------------------------------------------------

    export struct driver_string_options
    {
        enum
        {
            cmap_lookup = 1,
            vertical = 2,
            realized_advance = 4,
            limit_subpixel = 8
        };
    };

    //---------------------------------------------------------------------------
    // flush intention flags
    //---------------------------------------------------------------------------

    export struct flush_intention
    {
        enum
        {
            flush = 0,
            sync = 1
        };
    };

    //---------------------------------------------------------------------------
    // image encoder parameter related types
    //---------------------------------------------------------------------------

    export struct encoder_parameter_value_type
    {
        enum
        {
            byte = 1,
            ascii = 2,
            _short = 3,
            _long = 4,
            rational = 5,
            long_range = 6,
            undefined = 7,
            rational_range = 8
        };
    };

    //---------------------------------------------------------------------------
    // image encoder value types
    //---------------------------------------------------------------------------

    export struct encoder_value
    {
        enum
        {
            color_type_cmyk,
            color_type_ycck,
            compression_lzw,
            compression_ccitt3,
            compression_ccitt4,
            compression_rle,
            compression_none,
            scan_method_interlaced,
            scan_method_non_interlaced,
            version_gif87,
            version_gif89,
            render_progressive,
            render_non_progressive,
            transform_rotate90,
            transform_rotate180,
            transform_rotate270,
            transform_flip_horizontal,
            transform_flip_vertical,
            multi_frame,
            last_frame,
            flush,
            frame_dimension_time,
            frame_dimension_resolution,
            frame_dimension_page
        };
    };

    //---------------------------------------------------------------------------
    // conversion of emf to w_m_f bits flags
    //---------------------------------------------------------------------------

    export struct enhanced_to_windows_bits_flags
    {
        enum
        {
            _default = 0x00000000,
            embed_emf = 0x00000001,
            include_placeable = 0x00000002,
            no_xor_clip = 0x00000004
        };
    };

    //---------------------------------------------------------------------------
    // test control flags
    //---------------------------------------------------------------------------

    export struct test_control_enum
    {
        enum
        {
            force_bilinear = 0,
            no_icm = 1,
            get_build_number = 2
        };
    };

    export struct debug_event_level
    {
        enum
        {
            fatal,
            warning
        };
    };

    export struct  _startup_input
    {
        uint _version;           // must be 1
        void* debug_event_callback;          // ignored on free builds
        bool suppress_background_thread;     // false unless you're prepared to call 
                                             // the hook/unhook functions properly
        bool suppress_external_codecs;       // false unless you want g_d_i+ only to use
                                             // its internal image codecs.

        _startup_input(
            void* debug_event_callback = 0,
            bool suppress_background_thread = false,
            bool suppress_external_codecs = false)
        {
            _version = 1;
            debug_event_callback = debug_event_callback;
            suppress_background_thread = suppress_background_thread;
            suppress_external_codecs = suppress_external_codecs;
        }
    };

    // output structure for _startup()

    export struct _startup_output
    {
        void* notification_hook;
        void* notification_unhook;
    };

    extern "C"
    {
        export extern "C" unsigned __stdcall _startup(void** token,
            const void* input,
            void* output);

        export extern "C" void __stdcall _shutdown(void* token);

        export extern "C" unsigned __stdcall _create_path(uint brush_mode,
            _path * *path);

        export extern "C" uint __stdcall _create_path2(const pointf*,
            const byte*,
            int,
            uint,
            _path * *path);

        export extern "C" uint __stdcall _create_path2_integer(const ipoint*,
            const byte*,
            int,
            uint,
            _path * *path);

        export extern "C" uint __stdcall _clone_path(_path * path,
            _path * *clone_path);

        export extern "C" uint __stdcall _delete_path(_path * path);

        export extern "C" uint __stdcall _reset_path(_path * path);

        export extern "C" uint __stdcall _get_point_count(_path * path,
            int* count);

        export extern "C" uint __stdcall _get_path_types(_path * path,
            byte * types,
            int count);

        export extern "C" uint __stdcall _get_path_points(_path*,
            pointf * points,
            int count);

        export extern "C" uint __stdcall _get_path_points_integer(_path*,
            ipoint * points,
            int count);

        export extern "C" uint __stdcall _get_path_fill_mode(_path * path,
            uint * fillmode);

        export extern "C" uint __stdcall _set_path_fill_mode(_path * path,
            uint fillmode);

        export extern "C" uint __stdcall _get_path_data(_path * path,
            path_data * path_data);

        export extern "C" uint __stdcall _start_path_figure(_path * path);

        export extern "C" uint __stdcall _close_path_figure(_path * path);

        export extern "C" uint __stdcall _close_path_figures(_path * path);

        export extern "C" uint __stdcall _set_path_marker(_path * path);

        export extern "C" uint __stdcall _clear_path_markers(_path * path);

        export extern "C" uint __stdcall _reverse_path(_path * path);

        export extern "C" uint __stdcall _get_path_last_point(_path * path, pointf * lastipoint);

        export extern "C" uint __stdcall _add_path_line(_path * path,
            float x1,
            float y1,
            float x2,
            float y2);

        export extern "C" uint __stdcall _add_path_line2(_path * path,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _add_path_arc(_path * path,
            float x,
            float y,
            float width,
            float height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _add_path_spline(_path * path,
            float x1,
            float y1,
            float x2,
            float y2,
            float x3,
            float y3,
            float x4,
            float y4);

        export extern "C" uint __stdcall _add_path_splines(_path * path,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _add_path_curve(_path * path,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _add_path_curve2(_path * path,
            const pointf * points,
            int count,
            float tension);

        export extern "C" uint __stdcall _add_path_curve3(_path * path,
            const pointf * points,
            int count,
            int offset,
            int number_ofsegments,
            float tension);

        export extern "C" uint __stdcall _add_path_closed_curve(_path * path,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _add_path_closed_curve2(_path * path,
            const pointf * points,
            int count,
            float tension);

        export extern "C" uint __stdcall _add_path_rectangle(_path * path,
            float x,
            float y,
            float width,
            float height);

        export extern "C" uint __stdcall _add_path_rectangles(_path * path,
            const rectanglef * rects,
            int count);

        export extern "C" uint __stdcall _add_path_ellipse(_path * path,
            float x,
            float y,
            float width,
            float height);

        export extern "C" uint __stdcall _add_path_pie(_path * path,
            float x,
            float y,
            float width,
            float height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _add_path_polygon(_path * path,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _add_path_path(_path * path,
            const _path * adding_path,
            bool connect);

        export extern "C" uint __stdcall _add_path_string(_path * path,
            const wchar_t* string,
            int length,
            const _font_family * family,
            int style,
            float em_size,
            const rectanglef * layout_rect,
            const _string_format * format);

        export extern "C" uint __stdcall _add_path_string_integer(_path * path,
            const wchar_t* string,
            int length,
            const _font_family * family,
            int style,
            float em_size,
            const rectangle * layout_rect,
            const _string_format * format);

        export extern "C" uint __stdcall _add_path_line_integer(_path * path,
            int x1,
            int y1,
            int x2,
            int y2);

        export extern "C" uint __stdcall _add_path_line2_integer(_path * path,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _add_path_arc_integer(_path * path,
            int x,
            int y,
            int width,
            int height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _add_path_spline_integer(_path * path,
            int x1,
            int y1,
            int x2,
            int y2,
            int x3,
            int y3,
            int x4,
            int y4);

        export extern "C" uint __stdcall _add_path_splines_integer(_path * path,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _add_path_curve_integer(_path * path,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _add_path_curve2_integer(_path * path,
            const ipoint * points,
            int count,
            float tension);

        export extern "C" uint __stdcall _add_path_curve3_integer(_path * path,
            const ipoint * points,
            int count,
            int offset,
            int number_ofsegments,
            float tension);

        export extern "C" uint __stdcall _add_path_closed_curve_integer(_path * path,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _add_path_closed_curve2_integer(_path * path,
            const ipoint * points,
            int count,
            float tension);

        export extern "C" uint __stdcall _add_path_rectangle_integer(_path * path,
            int x,
            int y,
            int width,
            int height);

        export extern "C" uint __stdcall _add_path_rectangles_integer(_path * path,
            const rectangle * rects,
            int count);

        export extern "C" uint __stdcall _add_path_ellipse_integer(_path * path,
            int x,
            int y,
            int width,
            int height);

        export extern "C" uint __stdcall _add_path_pie_integer(_path * path,
            int x,
            int y,
            int width,
            int height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _add_path_polygon_integer(_path * path,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _flatten_path(_path * path,
            _matrix * matrix,
            float flatness);

        export extern "C" uint __stdcall _winding_mode_outline(_path * path,
            _matrix * matrix,
            float flatness);

        export extern "C" uint __stdcall _widen_path(_path * native_path,
            _pen * pen,
            _matrix * matrix,
            float flatness);

        export extern "C" uint __stdcall _warp_path(_path * path,
            _matrix * matrix,
            const pointf * points,
            int count,
            float source_x,
            float source_y,
            float source_width,
            float source_height,
            uint warp_mode,
            float flatness);

        export extern "C" uint __stdcall _transform_path(_path * path, _matrix * matrix);

        export extern "C" uint __stdcall _get_path_world_bounds(_path * path,
            rectanglef * bounds,
            const _matrix * matrix,
            const _pen * pen);

        export extern "C" uint __stdcall _get_path_world_bounds_integer(_path * path,
            rectangle * bounds,
            const _matrix * matrix,
            const _pen * pen);

        export extern "C" uint __stdcall _is_visible_path_point(_path * path,
            float x,
            float y,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_visible_path_point_integer(_path * path,
            int x,
            int y,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_outline_visible_path_point(_path * path,
            float x,
            float y,
            _pen * pen,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_outline_visible_path_point_integer(_path * path,
            int x,
            int y,
            _pen * pen,
            _space * graphics,
            bool* result);

        //----------------------------------------------------------------------------
        // path_iterator ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_path_iterator(_path_iterator * *iterator,
            _path * path);

        export extern "C" uint __stdcall _delete_path_iterator(_path_iterator * iterator);

        export extern "C" uint __stdcall _path_iter_next_subpath(_path_iterator * iterator,
            int* result_count,
            int* start_index,
            int* end_index,
            bool* is_closed);

        export extern "C" uint __stdcall _path_iter_next_subpath_path(_path_iterator * iterator,
            int* result_count,
            _path * path,
            bool* is_closed);

        export extern "C" uint __stdcall _path_iter_next_path_type(_path_iterator * iterator,
            int* result_count,
            byte * path_type,
            int* start_index,
            int* end_index);

        export extern "C" uint __stdcall _path_iter_next_marker(_path_iterator * iterator,
            int* result_count,
            int* start_index,
            int* end_index);

        export extern "C" uint __stdcall _path_iter_next_marker_path(_path_iterator * iterator,
            int* result_count,
            _path * path);

        export extern "C" uint __stdcall _path_iter_get_count(_path_iterator * iterator,
            int* count);

        export extern "C" uint __stdcall _path_iter_get_subpath_count(_path_iterator * iterator,
            int* count);

        export extern "C" uint __stdcall _path_iter_is_valid(_path_iterator * iterator,
            bool* valid);

        export extern "C" uint __stdcall _path_iter_has_curve(_path_iterator * iterator,
            bool* has_curve);

        export extern "C" uint __stdcall _path_iter_rewind(_path_iterator * iterator);

        export extern "C" uint __stdcall _path_iter_enumerate(_path_iterator * iterator,
            int* result_count,
            pointf * points,
            byte * types,
            int count);

        export extern "C" uint __stdcall _path_iter_copy_data(_path_iterator * iterator,
            int* result_count,
            pointf * points,
            byte * types,
            int start_index,
            int end_index);

        //----------------------------------------------------------------------------
        // _matrix ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_matrix(_matrix * *matrix);

        export extern "C" uint __stdcall _create_matrix2(float m11,
            float m12,
            float m21,
            float m22,
            float dx,
            float dy,
            _matrix * *matrix);

        export extern "C" uint __stdcall _create_matrix3(const rectanglef * rect,
            const pointf * dstplg,
            _matrix * *matrix);

        export extern "C" uint __stdcall _create_matrix3_integer(const rectangle * rect,
            const ipoint * dstplg,
            _matrix * *matrix);

        export extern "C" uint __stdcall _clone_matrix(_matrix * matrix,
            _matrix * *clone__matrix);

        export extern "C" uint __stdcall _delete_matrix(_matrix * matrix);

        export extern "C" uint __stdcall _set_matrix_elements(_matrix * matrix,
            float m11,
            float m12,
            float m21,
            float m22,
            float dx,
            float dy);

        export extern "C" uint __stdcall _multiply_matrix(_matrix * matrix,
            _matrix * matrix2,
            uint order);

        export extern "C" uint __stdcall _translate_matrix(_matrix * matrix,
            float offset_x,
            float offset_y,
            uint order);

        export extern "C" uint __stdcall _scale_matrix(_matrix * matrix,
            float scale_x,
            float scale_y,
            uint order);

        export extern "C" uint __stdcall _rotate_matrix(_matrix * matrix,
            float angle,
            uint order);

        export extern "C" uint __stdcall _shear_matrix(_matrix * matrix,
            float shear_x,
            float shear_y,
            uint order);

        export extern "C" uint __stdcall _invert_matrix(_matrix * matrix);

        export extern "C" uint __stdcall _transform_matrix_points(_matrix * matrix,
            pointf * pts,
            int count);

        export extern "C" uint __stdcall _transform_matrix_points_integer(_matrix * matrix,
            ipoint * pts,
            int count);

        export extern "C" uint __stdcall _vector_transform_matrix_points(_matrix * matrix,
            pointf * pts,
            int count);

        export extern "C" uint __stdcall _vector_transform_matrix_points_integer(_matrix * matrix,
            ipoint * pts,
            int count);

        export extern "C" uint __stdcall _get_matrix_elements(const _matrix * matrix,
            float* matrix_out);

        export extern "C" uint __stdcall _is_matrix_invertible(const _matrix * matrix,
            bool* result);

        export extern "C" uint __stdcall _is_matrix_identity(const _matrix * matrix,
            bool* result);

        export extern "C" uint __stdcall _is_matrix_equal(const _matrix * matrix,
            const _matrix * matrix2,
            bool* result);

        //----------------------------------------------------------------------------
        // region ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_region(_region * *region);

        export extern "C" uint __stdcall _create_region_rectangle(const rectanglef * rect,
            _region * *region);

        export extern "C" uint __stdcall _create_region_rectangle_integer(const rectangle * rect,
            _region * *region);

        export extern "C" uint __stdcall _create_region_path(_path * path,
            _region * *region);

        export extern "C" uint __stdcall _create_region_region_data(const byte * region_data,
            int size,
            _region * *region);

        export extern "C" uint __stdcall _create_region_handle(handle h_rgn,
            _region * *region);

        export extern "C" uint __stdcall _clone_region(_region * region,
            _region * *clone_region);

        export extern "C" uint __stdcall _delete_region(_region * region);

        export extern "C" uint __stdcall _set_infinite(_region * region);

        export extern "C" uint __stdcall _set_empty(_region * region);

        export extern "C" uint __stdcall _combine_region_rectangle(_region * region,
            const rectanglef * rect,
            uint combine_mode);

        export extern "C" uint __stdcall _combine_region_rectangle_integer(_region * region,
            const rectangle * rect,
            uint combine_mode);

        export extern "C" uint __stdcall _combine_region_path(_region * region,
            _path * path,
            uint combine_mode);

        export extern "C" uint __stdcall _combine_region_region(_region * region,
            _region * region2,
            uint combine_mode);

        export extern "C" uint __stdcall _translate_region(_region * region,
            float dx,
            float dy);

        export extern "C" uint __stdcall _translate_region_integer(_region * region,
            int dx,
            int dy);

        export extern "C" uint __stdcall _transform_region(_region * region,
            _matrix * matrix);

        export extern "C" uint __stdcall _get_region_bounds(_region * region,
            _space * graphics,
            rectanglef * rect);

        export extern "C" uint __stdcall _get_region_bounds_integer(_region * region,
            _space * graphics,
            rectangle * rect);

        export extern "C" uint __stdcall _get_region_handle(_region * region,
            _space * graphics,
            handle * h_rgn);

        export extern "C" uint __stdcall _is_empty_region(_region * region,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_infinite_region(_region * region,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_equal_region(_region * region,
            _region * region2,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _get_region_data_size(_region * region,
            uint * buffer_size);

        export extern "C" uint __stdcall _get_region_data(_region * region,
            byte * buffer,
            uint buffer_size,
            uint * sizefilled);

        export extern "C" uint __stdcall _is_visible_region_point(_region * region,
            float x,
            float y,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_visible_region_point_integer(_region * region,
            int x,
            int y,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_visible_region_rectangle(_region * region,
            float x,
            float y,
            float width,
            float height,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_visible_region_rectangle_integer(_region * region,
            int x,
            int y,
            int width,
            int height,
            _space * graphics,
            bool* result);

        export extern "C" uint __stdcall _get_region_scans_count(_region * region,
            uint * count,
            _matrix * matrix);

        export extern "C" uint __stdcall _get_region_scans(_region * region,
            rectanglef * rects,
            int* count,
            _matrix * matrix);

        export extern "C" uint __stdcall _get_region_scans_integer(_region * region,
            rectangle * rects,
            int* count,
            _matrix * matrix);

        //----------------------------------------------------------------------------
        // brush ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _clone_brush(_brush * brush,
            _brush * *clone_brush);

        export extern "C" uint __stdcall _delete_brush(_brush * brush);

        export extern "C" uint __stdcall _get_brush_type(_brush * brush,
            uint * type);

        //----------------------------------------------------------------------------
        // hatch_brush ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_hatch_brush(uint hatchstyle,
            uint forecol,
            uint backcol,
            _hatch * *brush);

        export extern "C" uint __stdcall _get_hatch_style(_hatch * brush,
            uint * hatchstyle);

        export extern "C" uint __stdcall _get_hatch_foreground_color(_hatch * brush,
            uint * forecol);

        export extern "C" uint __stdcall _get_hatch_background_color(_hatch * brush,
            uint * backcol);

        //----------------------------------------------------------------------------
        // texture_brush ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_texture(void* image,
            uint wrap_mode,
            _texture * *texture);

        export extern "C" uint __stdcall _create_texture2(void* image,
            uint wrap_mode,
            float x,
            float y,
            float width,
            float height,
            _texture * *texture);

        export extern "C" uint __stdcall _create_texture_ia(void* image,
            const _image_attributes * image_attributes,
            float x,
            float y,
            float width,
            float height,
            _texture * *texture);

        export extern "C" uint __stdcall _create_texture2_integer(void* image,
            uint wrap_mode,
            int x,
            int y,
            int width,
            int height,
            _texture * *texture);

        export extern "C" uint __stdcall _create_texture_ia_integer(void* image,
            const _image_attributes * image_attributes,
            int x,
            int y,
            int width,
            int height,
            _texture * *texture);


        export extern "C" uint __stdcall _get_texture_transform(_texture * brush,
            _matrix * matrix);

        export extern "C" uint __stdcall _set_texture_transform(_texture * brush,
            const _matrix * matrix);

        export extern "C" uint __stdcall _reset_texture_transform(_texture * brush);

        export extern "C" uint __stdcall _multiply_texture_transform(_texture * brush,
            const _matrix * matrix,
            uint order);

        export extern "C" uint __stdcall _translate_texture_transform(_texture * brush,
            float dx,
            float dy,
            uint order);

        export extern "C" uint __stdcall _scale_texture_transform(_texture * brush,
            float sx,
            float sy,
            uint order);

        export extern "C" uint __stdcall _rotate_texture_transform(_texture * brush,
            float angle,
            uint order);

        export extern "C" uint __stdcall _set_texture_wrap_mode(_texture * brush,
            uint wrap_mode);

        export extern "C" uint __stdcall _get_texture_wrap_mode(_texture * brush,
            uint * wrap_mode);

        export extern "C" uint __stdcall _get_texture_image(_texture * brush,
            void** image);

        //----------------------------------------------------------------------------
        // solid_brush ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_solid_fill(uint color,
            _solid_fill * *brush);

        export extern "C" uint __stdcall _set_solid_fill_color(_solid_fill * brush,
            uint color);

        export extern "C" uint __stdcall _get_solid_fill_color(_solid_fill * brush,
            uint * color);

        //----------------------------------------------------------------------------
        // line_brush ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_line_brush(const pointf * ipoint1,
            const pointf * point2,
            uint color1,
            uint color2,
            uint wrap_mode,
            _line_gradient * *line_gradient);

        export extern "C" uint __stdcall _create_line_brush_integer(const ipoint * ipoint1,
            const ipoint * point2,
            uint color1,
            uint color2,
            uint wrap_mode,
            _line_gradient * *line_gradient);

        export extern "C" uint __stdcall _create_line_brush_from_rectangle(const rectanglef * rect,
            uint color1,
            uint color2,
            uint mode,
            uint wrap_mode,
            _line_gradient * *line_gradient);

        export extern "C" uint __stdcall _create_line_brush_from_rectangle_integer(const rectangle * rect,
            uint color1,
            uint color2,
            uint mode,
            uint wrap_mode,
            _line_gradient * *line_gradient);

        export extern "C" uint __stdcall _create_line_brush_from_rectangle_with_angle(const rectanglef * rect,
            uint color1,
            uint color2,
            float angle,
            bool is_angle_scalable,
            uint wrap_mode,
            _line_gradient * *line_gradient);

        export extern "C" uint __stdcall _create_line_brush_from_rectangle_with_angle_integer(const rectangle * rect,
            uint color1,
            uint color2,
            float angle,
            bool is_angle_scalable,
            uint wrap_mode,
            _line_gradient * *line_gradient);

        export extern "C" uint __stdcall _set_line_colors(_line_gradient * brush,
            uint color1,
            uint color2);

        export extern "C" uint __stdcall _get_line_colors(_line_gradient * brush,
            uint * colors);

        export extern "C" uint __stdcall _get_line_rectangle(_line_gradient * brush,
            rectanglef * rect);

        export extern "C" uint __stdcall _get_line_rectangle_i(_line_gradient * brush,
            rectangle * rect);

        export extern "C" uint __stdcall _set_line_gamma_correction(_line_gradient * brush,
            bool use_gamma_correction);

        export extern "C" uint __stdcall _get_line_gamma_correction(_line_gradient * brush,
            bool* use_gamma_correction);

        export extern "C" uint __stdcall _get_line_blend_count(_line_gradient * brush,
            int* count);

        export extern "C" uint __stdcall _get_line_blend(_line_gradient * brush,
            float* blend,
            float* positions,
            int count);

        export extern "C" uint __stdcall _set_line_blend(_line_gradient * brush,
            const float* blend,
            const float* positions,
            int count);

        export extern "C" uint __stdcall _get_line_preset_blend_count(_line_gradient * brush,
            int* count);

        export extern "C" uint __stdcall _get_line_preset_blend(_line_gradient * brush,
            uint * blend,
            float* positions,
            int count);

        export extern "C" uint __stdcall _set_line_preset_blend(_line_gradient * brush,
            const uint * blend,
            const float* positions,
            int count);

        export extern "C" uint __stdcall _set_line_sigma_blend(_line_gradient * brush,
            float focus,
            float scale);

        export extern "C" uint __stdcall _set_line_linear_blend(_line_gradient * brush,
            float focus,
            float scale);

        export extern "C" uint __stdcall _set_line_wrap_mode(_line_gradient * brush,
            uint wrap_mode);

        export extern "C" uint __stdcall _get_line_wrap_mode(_line_gradient * brush,
            uint * wrap_mode);

        export extern "C" uint __stdcall _get_line_transform(_line_gradient * brush,
            _matrix * matrix);

        export extern "C" uint __stdcall _set_line_transform(_line_gradient * brush,
            const _matrix * matrix);

        export extern "C" uint __stdcall _reset_line_transform(_line_gradient * brush);

        export extern "C" uint __stdcall _multiply_line_transform(_line_gradient * brush,
            const _matrix * matrix,
            uint order);

        export extern "C" uint __stdcall _translate_line_transform(_line_gradient * brush,
            float dx,
            float dy,
            uint order);

        export extern "C" uint __stdcall _scale_line_transform(_line_gradient * brush,
            float sx,
            float sy,
            uint order);

        export extern "C" uint __stdcall _rotate_line_transform(_line_gradient * brush,
            float angle,
            uint order);

        //----------------------------------------------------------------------------
        // path_gradient_brush ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_path_gradient(const pointf * points,
            int count,
            uint wrap_mode,
            _path_gradient * *poly_gradient);

        export extern "C" uint __stdcall _create_path_gradient_integer(const ipoint * points,
            int count,
            uint wrap_mode,
            _path_gradient * *poly_gradient);

        export extern "C" uint __stdcall _create_path_gradient_from_path(const _path * path,
            _path_gradient * *poly_gradient);

        export extern "C" uint __stdcall _get_path_gradient_center_color(_path_gradient * brush,
            uint * colors);

        export extern "C" uint __stdcall _set_path_gradient_center_color(_path_gradient * brush,
            uint colors);

        export extern "C" uint __stdcall _get_path_gradient_surround_colors_with_count(_path_gradient * brush,
            uint * color,
            int* count);

        export extern "C" uint __stdcall _set_path_gradient_surround_colors_with_count(_path_gradient * brush,
            const uint * color,
            int* count);

        export extern "C" uint __stdcall _get_path_gradient_path(_path_gradient * brush,
            _path * path);

        export extern "C" uint __stdcall _set_path_gradient_path(_path_gradient * brush,
            const _path * path);

        export extern "C" uint __stdcall _get_path_gradient_center_point(_path_gradient * brush,
            pointf * points);

        export extern "C" uint __stdcall _get_path_gradient_center_point_integer(_path_gradient * brush,
            ipoint * points);

        export extern "C" uint __stdcall _set_path_gradient_center_point(_path_gradient * brush,
            const pointf * points);

        export extern "C" uint __stdcall _set_path_gradient_center_point_integer(_path_gradient * brush,
            const ipoint * points);

        export extern "C" uint __stdcall _get_path_gradient_rectangle(_path_gradient * brush,
            rectanglef * rect);

        export extern "C" uint __stdcall _get_path_gradient_rectangle_integer(_path_gradient * brush,
            rectangle * rect);

        export extern "C" uint __stdcall _get_path_gradient_point_count(_path_gradient * brush,
            int* count);

        export extern "C" uint __stdcall _get_path_gradient_surround_color_count(_path_gradient * brush,
            int* count);

        export extern "C" uint __stdcall _set_path_gradient_gamma_correction(_path_gradient * brush,
            bool use_gamma_correction);

        export extern "C" uint __stdcall _get_path_gradient_gamma_correction(_path_gradient * brush,
            bool* use_gamma_correction);

        export extern "C" uint __stdcall _get_path_gradient_blend_count(_path_gradient * brush,
            int* count);

        export extern "C" uint __stdcall _get_path_gradient_blend(_path_gradient * brush,
            float* blend,
            float* positions,
            int count);

        export extern "C" uint __stdcall _set_path_gradient_blend(_path_gradient * brush,
            const float* blend,
            const float* positions,
            int count);

        export extern "C" uint __stdcall _get_path_gradient_preset_blend_count(_path_gradient * brush,
            int* count);

        export extern "C" uint __stdcall _get_path_gradient_preset_blend(_path_gradient * brush,
            uint * blend,
            float* positions,
            int count);

        export extern "C" uint __stdcall _set_path_gradient_preset_blend(_path_gradient * brush,
            const uint * blend,
            const float* positions,
            int count);

        export extern "C" uint __stdcall _set_path_gradient_sigma_blend(_path_gradient * brush,
            float focus,
            float scale);

        export extern "C" uint __stdcall _set_path_gradient_linear_blend(_path_gradient * brush,
            float focus,
            float scale);

        export extern "C" uint __stdcall _get_path_gradient_wrap_mode(_path_gradient * brush,
            uint * wrap_mode);

        export extern "C" uint __stdcall _set_path_gradient_wrap_mode(_path_gradient * brush,
            uint wrap_mode);

        export extern "C" uint __stdcall _get_path_gradient_transform(_path_gradient * brush,
            _matrix * matrix);

        export extern "C" uint __stdcall _set_path_gradient_transform(_path_gradient * brush,
            _matrix * matrix);

        export extern "C" uint __stdcall _reset_path_gradient_transform(_path_gradient * brush);

        export extern "C" uint __stdcall _multiply_path_gradient_transform(_path_gradient * brush,
            const _matrix * matrix,
            uint order);

        export extern "C" uint __stdcall _translate_path_gradient_transform(_path_gradient * brush,
            float dx,
            float dy,
            uint order);

        export extern "C" uint __stdcall _scale_path_gradient_transform(_path_gradient * brush,
            float sx,
            float sy,
            uint order);

        export extern "C" uint __stdcall _rotate_path_gradient_transform(_path_gradient * brush,
            float angle,
            uint order);

        export extern "C" uint __stdcall _get_path_gradient_focus_scales(_path_gradient * brush,
            float* x_scale,
            float* y_scale);

        export extern "C" uint __stdcall _set_path_gradient_focus_scales(_path_gradient * brush,
            float x_scale,
            float y_scale);

        //----------------------------------------------------------------------------
        // pen ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_pen1(uint color,
            float width,
            uint unit,
            _pen * *pen);

        export extern "C" uint __stdcall _create_pen2(_brush * brush,
            float width,
            uint unit,
            _pen * *pen);

        export extern "C" uint __stdcall _clone_pen(_pen * pen,
            _pen * *clonepen);

        export extern "C" uint __stdcall _delete_pen(_pen * pen);

        export extern "C" uint __stdcall _set_pen_width(_pen * pen,
            float width);

        export extern "C" uint __stdcall _get_pen_width(_pen * pen,
            float* width);

        export extern "C" uint __stdcall _set_pen_unit(_pen * pen,
            uint unit);

        export extern "C" uint __stdcall _get_pen_unit(_pen * pen,
            uint * unit);

        export extern "C" uint __stdcall _set_pen_line_cap(_pen * pen,
            uint start_cap,
            uint end_cap,
            uint dash_cap);

        export extern "C" uint __stdcall _set_pen_start_cap(_pen * pen,
            uint start_cap);

        export extern "C" uint __stdcall _set_pen_end_cap(_pen * pen,
            uint end_cap);

        export extern "C" uint __stdcall _set_pen_dash_cap(_pen * pen,
            uint dash_cap);

        export extern "C" uint __stdcall _get_pen_start_cap(_pen * pen,
            uint * start_cap);

        export extern "C" uint __stdcall _get_pen_end_cap(_pen * pen,
            uint * end_cap);

        export extern "C" uint __stdcall _get_pen_dash_cap(_pen * pen,
            uint * dash_cap);

        export extern "C" uint __stdcall _set_pen_line_join(_pen * pen,
            uint line_join);

        export extern "C" uint __stdcall _get_pen_line_join(_pen * pen,
            uint * line_join);

        export extern "C" uint __stdcall _set_pen_custom_start_cap(_pen * pen,
            _custom_line_cap * custom_cap);

        export extern "C" uint __stdcall _get_pen_custom_start_cap(_pen * pen,
            _custom_line_cap * *custom_cap);

        export extern "C" uint __stdcall _set_pen_custom_end_cap(_pen * pen,
            _custom_line_cap * custom_cap);

        export extern "C" uint __stdcall _get_pen_custom_end_cap(_pen * pen,
            _custom_line_cap * *custom_cap);

        export extern "C" uint __stdcall _set_pen_mitre_limit(_pen * pen,
            float miter_limit);

        export extern "C" uint __stdcall _get_pen_mitre_limit(_pen * pen,
            float* miter_limit);

        export extern "C" uint __stdcall _set_pen_mode(_pen * pen,
            uint pen_mode);

        export extern "C" uint __stdcall _get_pen_mode(_pen * pen,
            uint * pen_mode);

        export extern "C" uint __stdcall _set_pen_transform(_pen * pen,
            _matrix * matrix);

        export extern "C" uint __stdcall _get_pen_transform(_pen * pen,
            _matrix * matrix);

        export extern "C" uint __stdcall _reset_pen_transform(_pen * pen);

        export extern "C" uint __stdcall _multiply_pen_transform(_pen * pen,
            const _matrix * matrix,
            uint order);

        export extern "C" uint __stdcall _translate_pen_transform(_pen * pen,
            float dx,
            float dy,
            uint order);

        export extern "C" uint __stdcall _scale_pen_transform(_pen * pen,
            float sx,
            float sy,
            uint order);

        export extern "C" uint __stdcall _rotate_pen_transform(_pen * pen,
            float angle,
            uint order);

        export extern "C" uint __stdcall _set_pen_color(_pen * pen,
            uint argb);

        export extern "C" uint __stdcall _get_pen_color(_pen * pen,
            uint * argb);

        export extern "C" uint __stdcall _set_pen_brush_fill(_pen * pen,
            _brush * brush);

        export extern "C" uint __stdcall _get_pen_brush_fill(_pen * pen,
            _brush * *brush);

        export extern "C" uint __stdcall _get_pen_fill_type(_pen * pen,
            int* type);

        export extern "C" uint __stdcall _get_pen_dash_style(_pen * pen,
            uint * dash_style);

        export extern "C" uint __stdcall _set_pen_dash_style(_pen * pen,
            uint dash_style);

        export extern "C" uint __stdcall _get_pen_dash_offset(_pen * pen,
            float* offset);

        export extern "C" uint __stdcall _set_pen_dash_offset(_pen * pen,
            float offset);

        export extern "C" uint __stdcall _get_pen_dash_count(_pen * pen,
            int* count);

        export extern "C" uint __stdcall _set_pen_dash_array(_pen * pen,
            const float* dash,
            int count);

        export extern "C" uint __stdcall _get_pen_dash_array(_pen * pen,
            float* dash,
            int count);

        export extern "C" uint __stdcall _get_pen_compound_count(_pen * pen,
            int* count);

        export extern "C" uint __stdcall _set_pen_compound_array(_pen * pen,
            const float* dash,
            int count);

        export extern "C" uint __stdcall _get_pen_compound_array(_pen * pen,
            float* dash,
            int count);

        //----------------------------------------------------------------------------
        // custom_line_cap ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_custom_line_cap(_path * fill_path,
            _path * stroke_path,
            uint base_cap,
            float base_inset,
            _custom_line_cap * *custom_cap);

        export extern "C" uint __stdcall _delete_custom_line_cap(_custom_line_cap * custom_cap);

        export extern "C" uint __stdcall _clone_custom_line_cap(_custom_line_cap * custom_cap,
            _custom_line_cap * *clonedcap);

        export extern "C" uint __stdcall _get_custom_line_cap_type(_custom_line_cap * custom_cap,
            uint * cap_type);

        export extern "C" uint __stdcall _set_custom_line_cap_stroke_caps(_custom_line_cap * custom_cap,
            uint start_cap,
            uint end_cap);

        export extern "C" uint __stdcall _get_custom_line_cap_stroke_caps(_custom_line_cap * custom_cap,
            uint * start_cap,
            uint * end_cap);

        export extern "C" uint __stdcall _set_custom_line_cap_stroke_join(_custom_line_cap * custom_cap,
            uint line_join);

        export extern "C" uint __stdcall _get_custom_line_cap_stroke_join(_custom_line_cap * custom_cap,
            uint * line_join);

        export extern "C" uint __stdcall _set_custom_line_cap_base_cap(_custom_line_cap * custom_cap,
            uint base_cap);

        export extern "C" uint __stdcall _get_custom_line_cap_base_cap(_custom_line_cap * custom_cap,
            uint * base_cap);

        export extern "C" uint __stdcall _set_custom_line_cap_base_inset(_custom_line_cap * custom_cap,
            float inset);

        export extern "C" uint __stdcall _get_custom_line_cap_base_inset(_custom_line_cap * custom_cap,
            float* inset);

        export extern "C" uint __stdcall _set_custom_line_cap_width_scale(_custom_line_cap * custom_cap,
            float width_scale);

        export extern "C" uint __stdcall _get_custom_line_cap_width_scale(_custom_line_cap * custom_cap,
            float* width_scale);

        //----------------------------------------------------------------------------
        // adjustable_arrow_cap ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_adjustable_arrow_cap(float height,
            float width,
            bool is_filled,
            _adjustable_arrow_cap * *cap);

        export extern "C" uint __stdcall _set_adjustable_arrow_cap_height(_adjustable_arrow_cap * cap,
            float height);

        export extern "C" uint __stdcall _get_adjustable_arrow_cap_height(_adjustable_arrow_cap * cap,
            float* height);

        export extern "C" uint __stdcall _set_adjustable_arrow_cap_width(_adjustable_arrow_cap * cap,
            float width);

        export extern "C" uint __stdcall _get_adjustable_arrow_cap_width(_adjustable_arrow_cap * cap,
            float* width);

        export extern "C" uint __stdcall _set_adjustable_arrow_cap_middle_inset(_adjustable_arrow_cap * cap,
            float middle_inset);

        export extern "C" uint __stdcall _get_adjustable_arrow_cap_middle_inset(_adjustable_arrow_cap * cap,
            float* middle_inset);

        export extern "C" uint __stdcall _set_adjustable_arrow_cap_fill_state(_adjustable_arrow_cap * cap,
            bool fill_state);

        export extern "C" uint __stdcall _get_adjustable_arrow_cap_fill_state(_adjustable_arrow_cap * cap,
            bool* fill_state);

        //----------------------------------------------------------------------------
        // image ap_is
        //----------------------------------------------------------------------------

        //export extern "C" uint __stdcall _load_image_from_stream(istream* stream,
        //                                                  void* *image);

        export extern "C" uint __stdcall _load_image_from_file(const wchar_t* file_name,
            void** image);

        //export extern "C" uint __stdcall _load_image_from_stream_image_color_management(istream* stream,
        //                                                                        void* *image);

        export extern "C" uint __stdcall _load_image_from_file_image_color_management(const wchar_t* file_name,
            void** image);

        export extern "C" uint __stdcall _clone_image(void* image,
            void** clone_image);

        export extern "C" uint __stdcall _dispose_image(void* image);

        export extern "C" uint __stdcall _save_image_to_file(void* image,
            const wchar_t* file_name,
            const global * clsid_encoder,
            const void* encoder_params);

        //export extern "C" uint __stdcall _save_image_to_stream(void* image,
        //                                                istream* stream,
        //                                                const uint* clsid_encoder, 
        //                                                const void* encoder_params);

        export extern "C" uint __stdcall _save_add(void* image,
            const void* encoder_params);

        export extern "C" uint __stdcall _save_add_image(void* image,
            _image * new_image,
            const void* encoder_params);

        export extern "C" uint __stdcall _get_image__context(void* image,
            _space * *graphics);

        export extern "C" uint __stdcall _get_image_bounds(void* image,
            rectanglef * source_rect,
            uint * source_unit);

        export extern "C" uint __stdcall _get_image_dimension(void* image,
            float* width,
            float* height);

        export extern "C" uint __stdcall _get_image_type(void* image,
            uint * type);

        export extern "C" uint __stdcall _get_image_width(void* image,
            uint * width);

        export extern "C" uint __stdcall _get_image_height(void* image,
            uint * height);

        export extern "C" uint __stdcall _get_image_horizontal_resolution(void* image,
            float* resolution);

        export extern "C" uint __stdcall _get_image_vertical_resolution(void* image,
            float* resolution);

        export extern "C" uint __stdcall _get_image_flags(void* image,
            uint * flags);

        export extern "C" uint __stdcall _get_image_raw_format(void* image,
            global * format);

        export extern "C" uint __stdcall _get_image_pixel_format(void* image,
            pixel_format * format);

        export extern "C" uint __stdcall _get_image_thumb_nail(void* image,
            uint thumb_width,
            uint thumb_height,
            void** thumb_image,
            void* callback,
            void* callback_data);

        export extern "C" uint __stdcall _get_encoder_parameter_list_size(void* image,
            const uint * clsid_encoder,
            uint * size);

        export extern "C" uint __stdcall _get_encoder_parameter_list(void* image,
            const uint * clsid_encoder,
            uint size,
            void* buffer);

        export extern "C" uint __stdcall _image_get_frame_dimensions_count(_image * image,
            uint * count);

        export extern "C" uint __stdcall _image_get_frame_dimensions_list(_image * image,
            global * dimension_identities,
            uint count);

        export extern "C" uint __stdcall _image_get_frame_count(void* image,
            const global * dimension_identity,
            uint * count);

        export extern "C" uint __stdcall _image_select_active_frame(void* image,
            const global * dimension_identity,
            uint frame_index);

        export extern "C" uint __stdcall _image_rotate_flip(void* image,
            uint rotate_flip_type);

        export extern "C" uint __stdcall _get_image_palette(void* image,
            color_palette * palette,
            int size);

        export extern "C" uint __stdcall _set_image_palette(void* image,
            const color_palette * palette);

        export extern "C" uint __stdcall _get_image_palette_size(void* image,
            int* size);

        export extern "C" uint __stdcall _get_property_count(void* image,
            uint * number_of_properties);

        export extern "C" uint __stdcall _get_property_id_list(void* image,
            uint number_of_properties,
            uint * list);

        export extern "C" uint __stdcall _get_property_item_size(void* image,
            uint property_identity,
            uint * size);

        export extern "C" uint __stdcall _get_property_item(void* image,
            uint property_identity,
            uint property_size,
            void* buffer);

        export extern "C" uint __stdcall _get_property_size(void* image,
            uint * total_buffer_size,
            uint * number_of_properties);

        export extern "C" uint __stdcall _get_all_property_items(void* image,
            uint total_buffer_size,
            uint number_of_properties,
            void* all_items);

        export extern "C" uint __stdcall _remove_property_item(void* image,
            uint property_identity);

        export extern "C" uint __stdcall _set_property_item(void* image,
            const void* item);

        export extern "C" uint __stdcall _image_force_validation(void* image);

        //----------------------------------------------------------------------------
        // bitmap ap_is
        //----------------------------------------------------------------------------

        //export extern "C" uint __stdcall _create_bitmap_from_stream(istream* stream,
        //                                                     _bitmap** bitmap);

        export extern "C" uint __stdcall _create_bitmap_from_file(const wchar_t* file_name,
            _bitmap * *bitmap);

        //export extern "C" uint __stdcall _create_bitmap_from_stream_image_color_management(istream* stream,
        //                                                                            _bitmap** bitmap);

        export extern "C" uint __stdcall _create_bitmap_from_file_image_color_management(const wchar_t* file_name,
            _bitmap * *bitmap);

        export extern "C" uint __stdcall _create_bitmap_from_scan0(int width,
            int height,
            int stride,
            pixel_format format,
            byte * scan0,
            _bitmap * *bitmap);

        export extern "C" uint __stdcall _create_bitmap_from_graphics(int width,
            int height,
            _space * target,
            _bitmap * *bitmap);

        export extern "C" uint __stdcall _create_bitmap_from_gdi_dib(const bitmap_information * gdi_bitmap_info,
            void* gdi_bitmap_data,
            _bitmap * *bitmap);

        export extern "C" uint __stdcall _create_bitmap_from_bitmap_handle(handle hbitmap,
            handle hpalette,
            _bitmap * *bitmap);

        export extern "C" uint __stdcall _create_bitmap_handle_from_bitmap(_bitmap * bitmap,
            handle * hbitmap_return,
            uint background);

        export extern "C" uint __stdcall _create_bitmap_from_icon_handle(handle hicon,
            _bitmap * *bitmap);

        export extern "C" uint __stdcall _create_icon_handle_from_bitmap(_bitmap * bitmap,
            handle * hbitmap_return);

        export extern "C" uint __stdcall _create_bitmap_from_resource(handle h_instance,
            const wchar_t* bitmap_name,
            _bitmap * *bitmap);

        export extern "C" uint __stdcall _clone_bitmap_area(float x,
            float y,
            float width,
            float height,
            pixel_format format,
            _bitmap * source_bitmap,
            _bitmap * *destination_bitmap);

        export extern "C" uint __stdcall _clone_bitmap_area_integer(int x,
            int y,
            int width,
            int height,
            pixel_format format,
            _bitmap * source_bitmap,
            _bitmap * *destination_bitmap);

        export extern "C" uint __stdcall _bitmap_lock_bits(_bitmap * bitmap,
            const rectangle * rect,
            uint flags,
            pixel_format format,
            void* locked_bitmap_data);

        export extern "C" uint __stdcall _bitmap_unlock_bits(_bitmap * bitmap,
            void* locked_bitmap_data);

        export extern "C" uint __stdcall _bitmap_get_pixel(_bitmap * bitmap,
            int x,
            int y,
            uint * color);

        export extern "C" uint __stdcall _bitmap_set_pixel(_bitmap * bitmap,
            int x,
            int y,
            uint color);

        export extern "C" uint __stdcall _bitmap_set_resolution(_bitmap * bitmap,
            float x_dots_per_inch,
            float y_dots_per_inch);

        //----------------------------------------------------------------------------
        // image_attributes ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_image_attributes(_image_attributes * *image_attributes);

        export extern "C" uint __stdcall _clone_image_attributes(const _image_attributes * image_attributes,
            _image_attributes * *clone_image_attributes);

        export extern "C" uint __stdcall _dispose_image_attributes(_image_attributes * image_attributes);

        export extern "C" uint __stdcall _set_image_attributes_to_identity(_image_attributes * image_attributes,
            uint type);

        export extern "C" uint __stdcall _reset_image_attributes(_image_attributes * image_attributes,
            uint type);

        export extern "C" uint __stdcall _set_image_attributes_color_matrix(_image_attributes * image_attributes,
            uint type,
            bool enable_flag,
            const color_matrix * color__matrix,
            const color_matrix * gray__matrix,
            uint flags);

        export extern "C" uint __stdcall _set_image_attributes_threshold(_image_attributes * image_attributes,
            uint type,
            bool enable_flag,
            float threshold);

        export extern "C" uint __stdcall _set_image_attributes_gamma(_image_attributes * image_attributes,
            uint type,
            bool enable_flag,
            float gamma);

        export extern "C" uint __stdcall _set_image_attributes_no_op(_image_attributes * image_attributes,
            uint type,
            bool enable_flag);

        export extern "C" uint __stdcall _set_image_attributes_color_keys(_image_attributes * image_attributes,
            uint type,
            bool enable_flag,
            uint color_low,
            uint color_high);

        export extern "C" uint __stdcall _set_image_attributes_output_channel(_image_attributes * image_attributes,
            uint type,
            bool enable_flag,
            uint channel_flags);

        export extern "C" uint __stdcall _set_image_attributes_output_channel_color_profile(_image_attributes * image_attributes,
            uint type,
            bool enable_flag,
            const wchar_t* color_profile_file_name);

        //export extern "C" uint __stdcall _set_image_attributes_remap_table(_image_attributes* image_attributes,
        //    uint type,
        //    bool enable_flag,
        //    uint map_size,
        //    const _color gc, map* map);

        export extern "C" uint __stdcall _set_image_attributes_wrap_mode(_image_attributes * image_attr,
            uint wrap,
            uint argb,
            bool clamp);

        export extern "C" uint __stdcall _set_image_attributes_image_color_management_mode(_image_attributes * image_attr,
            bool on);

        export extern "C" uint __stdcall _get_image_attributes_adjusted_palette(_image_attributes * image_attr,
            color_palette * color_palette,
            uint color_adjust_type);

        //----------------------------------------------------------------------------
        // graphics apis
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _flush(_space * graphics,
            uint intention);

        export extern "C" uint __stdcall _create_from_device_context_handle(handle device_context_handle,
            _space * *graphics);

        export extern "C" uint __stdcall _create_from_device_context_handle2(handle device_context_handle,
            handle device_handle,
            _space * *graphics);

        export extern "C" uint __stdcall _create_from_window_handle(handle window_handle,
            _space * *graphics);

        export extern "C" uint __stdcall _create_from_window_handle_image_color_management(handle window_handle,
            _space * *graphics);

        export extern "C" uint __stdcall _delete_graphics(_space * graphics);

        export extern "C" uint __stdcall _get_device_context(_space * graphics,
            handle * device_context_handle);

        export extern "C" uint __stdcall _release_device_context(_space * graphics,
            handle device_context_handle);

        export extern "C" uint __stdcall _set_compositing_mode(_space * graphics,
            uint compositing_mode);

        export extern "C" uint __stdcall _get_compositing_mode(_space * graphics,
            uint * compositing_mode);

        export extern "C" uint __stdcall _set_rendering_origin(_space * graphics,
            int x,
            int y);

        export extern "C" uint __stdcall _get_rendering_origin(_space * graphics,
            int* x,
            int* y);

        export extern "C" uint __stdcall _set_compositing_quality(_space * graphics,
            uint compositing_quality);

        export extern "C" uint __stdcall _get_compositing_quality(_space * graphics,
            uint * compositing_quality);

        export extern "C" uint __stdcall _set_smoothing_mode(_space * graphics,
            uint smoothing_mode);

        export extern "C" uint __stdcall _get_smoothing_mode(_space * graphics,
            uint * smoothing_mode);

        export extern "C" uint __stdcall _set_pixel_offset_mode(_space * graphics,
            uint pixel_offset_mode);

        export extern "C" uint __stdcall _get_pixel_offset_mode(_space * graphics,
            uint * pixel_offset_mode);

        export extern "C" uint __stdcall _set_text_rendering_hint(_space * graphics,
            uint mode);

        export extern "C" uint __stdcall _get_text_rendering_hint(_space * graphics,
            uint * mode);

        export extern "C" uint __stdcall _set_text_contrast(_space * graphics,
            uint contrast);

        export extern "C" uint __stdcall _get_text_contrast(_space * graphics,
            uint * contrast);

        export extern "C" uint __stdcall _set_interpolation_mode(_space * graphics,
            uint interpolation_mode);

        export extern "C" uint __stdcall _get_interpolation_mode(_space * graphics,
            uint * interpolation_mode);

        export extern "C" uint __stdcall _set_world_transform(_space * graphics,
            _matrix * matrix);

        export extern "C" uint __stdcall _reset_world_transform(_space * graphics);

        export extern "C" uint __stdcall _multiply_world_transform(_space * graphics,
            const _matrix * matrix,
            uint order);

        export extern "C" uint __stdcall _translate_world_transform(_space * graphics,
            float dx,
            float dy,
            uint order);

        export extern "C" uint __stdcall _scale_world_transform(_space * graphics,
            float sx,
            float sy,
            uint order);

        export extern "C" uint __stdcall _rotate_world_transform(_space * graphics,
            float angle,
            uint order);

        export extern "C" uint __stdcall _get_world_transform(_space * graphics,
            _matrix * matrix);

        export extern "C" uint __stdcall _reset_page_transform(_space * graphics);

        export extern "C" uint __stdcall _get_page_unit(_space * graphics,
            uint * unit);

        export extern "C" uint __stdcall _get_page_scale(_space * graphics,
            float* scale);

        export extern "C" uint __stdcall _set_page_unit(_space * graphics,
            uint unit);

        export extern "C" uint __stdcall _set_page_scale(_space * graphics,
            float scale);

        export extern "C" uint __stdcall _get_dots_per_inch_x(_space * graphics,
            float* dots_per_inch);

        export extern "C" uint __stdcall _get_dots_per_inch_y(_space * graphics,
            float* dots_per_inch);

        export extern "C" uint __stdcall _transform_points(_space * graphics,
            uint dest_space,
            uint source_space,
            pointf * points,
            int count);

        export extern "C" uint __stdcall _transform_points_integer(_space * graphics,
            uint destination_space,
            uint source_space,
            ipoint * points,
            int count);

        export extern "C" uint __stdcall _get_nearest_color(_space * graphics,
            uint * argb);

        export extern "C" handle __stdcall _create_half_tone_palette();

        export extern "C" uint __stdcall _draw_line(_space * graphics,
            _pen * pen,
            float x1,
            float y1,
            float x2,
            float y2);

        export extern "C" uint __stdcall _draw_line_integer(_space * graphics,
            _pen * pen,
            int x1,
            int y1,
            int x2,
            int y2);

        export extern "C" uint __stdcall _draw_lines(_space * graphics,
            _pen * pen,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _draw_lines_integer(_space * graphics,
            _pen * pen,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _draw_arc(_space * graphics,
            _pen * pen,
            float x,
            float y,
            float width,
            float height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _draw_arc_integer(_space * graphics,
            _pen * pen,
            int x,
            int y,
            int width,
            int height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _draw_spline(_space * graphics,
            _pen * pen,
            float x1,
            float y1,
            float x2,
            float y2,
            float x3,
            float y3,
            float x4,
            float y4);

        export extern "C" uint __stdcall _draw_spline_integer(_space * graphics,
            _pen * pen,
            int x1,
            int y1,
            int x2,
            int y2,
            int x3,
            int y3,
            int x4,
            int y4);

        export extern "C" uint __stdcall _draw_splines(_space * graphics,
            _pen * pen,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _draw_splines_integer(_space * graphics,
            _pen * pen,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _draw_rectangle(_space * graphics,
            _pen * pen,
            float x,
            float y,
            float width,
            float height);

        export extern "C" uint __stdcall _draw_rectangle_integer(_space * graphics,
            _pen * pen,
            int x,
            int y,
            int width,
            int height);

        export extern "C" uint __stdcall _draw_rectangles(_space * graphics,
            _pen * pen,
            const rectanglef * rects,
            int count);

        export extern "C" uint __stdcall _draw_rectangles_integer(_space * graphics,
            _pen * pen,
            const rectangle * rects,
            int count);

        export extern "C" uint __stdcall _draw_ellipse(_space * graphics,
            _pen * pen,
            float x,
            float y,
            float width,
            float height);

        export extern "C" uint __stdcall _draw_ellipse_integer(_space * graphics,
            _pen * pen,
            int x,
            int y,
            int width,
            int height);

        export extern "C" uint __stdcall _draw_pie(_space * graphics,
            _pen * pen,
            float x,
            float y,
            float width,
            float height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _draw_pie_integer(_space * graphics,
            _pen * pen,
            int x,
            int y,
            int width,
            int height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _draw_polygon(_space * graphics,
            _pen * pen,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _draw_polygon_integer(_space * graphics,
            _pen * pen,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _draw_path(_space * graphics,
            _pen * pen,
            _path * path);

        export extern "C" uint __stdcall _draw_curve(_space * graphics,
            _pen * pen,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _draw_curve_integer(_space * graphics,
            _pen * pen,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _draw_curve2(_space * graphics,
            _pen * pen,
            const pointf * points,
            int count,
            float tension);

        export extern "C" uint __stdcall _draw_curve2_integer(_space * graphics,
            _pen * pen,
            const ipoint * points,
            int count,
            float tension);

        export extern "C" uint __stdcall _draw_curve3(_space * graphics,
            _pen * pen,
            const pointf * points,
            int count,
            int offset,
            int number_of_segments,
            float tension);

        export extern "C" uint __stdcall _draw_curve3_integer(_space * graphics,
            _pen * pen,
            const ipoint * points,
            int count,
            int offset,
            int number_of_segments,
            float tension);

        export extern "C" uint __stdcall _draw_closed_curve(_space * graphics,
            _pen * pen,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _draw_closed_curve_integer(_space * graphics,
            _pen * pen,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _draw_closed_curve2(_space * graphics,
            _pen * pen,
            const pointf * points,
            int count,
            float tension);

        export extern "C" uint __stdcall _draw_closed_curve2_integer(_space * graphics,
            _pen * pen,
            const ipoint * points,
            int count,
            float tension);

        export extern "C" uint __stdcall __clear(_space * graphics,
            uint color);

        export extern "C" uint __stdcall _fill_rectangle(_space * graphics,
            _brush * brush,
            float x,
            float y,
            float width,
            float height);

        export extern "C" uint __stdcall _fill_rectangle_integer(_space * graphics,
            _brush * brush,
            int x,
            int y,
            int width,
            int height);

        export extern "C" uint __stdcall _fill_rectangles(_space * graphics,
            _brush * brush,
            const rectanglef * rects,
            int count);

        export extern "C" uint __stdcall _fill_rectangles_integer(_space * graphics,
            _brush * brush,
            const rectangle * rects,
            int count);

        export extern "C" uint __stdcall _fill_polygon(_space * graphics,
            _brush * brush,
            const pointf * points,
            int count,
            uint fill_mode);

        export extern "C" uint __stdcall _fill_polygon_integer(_space * graphics,
            _brush * brush,
            const ipoint * points,
            int count,
            uint fill_mode);

        export extern "C" uint __stdcall _fill_polygon2(_space * graphics,
            _brush * brush,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _fill_polygon2_integer(_space * graphics,
            _brush * brush,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _fill_ellipse(_space * graphics,
            _brush * brush,
            float x,
            float y,
            float width,
            float height);

        export extern "C" uint __stdcall _fill_ellipse_integer(_space * graphics,
            _brush * brush,
            int x,
            int y,
            int width,
            int height);

        export extern "C" uint __stdcall _fill_pie(_space * graphics,
            _brush * brush,
            float x,
            float y,
            float width,
            float height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _fill_pie_integer(_space * graphics,
            _brush * brush,
            int x,
            int y,
            int width,
            int height,
            float start_angle,
            float sweep_angle);

        export extern "C" uint __stdcall _fill_path(_space * graphics,
            _brush * brush,
            _path * path);

        export extern "C" uint __stdcall _fill_closed_curve(_space * graphics,
            _brush * brush,
            const pointf * points,
            int count);

        export extern "C" uint __stdcall _fill_closed_curve_integer(_space * graphics,
            _brush * brush,
            const ipoint * points,
            int count);

        export extern "C" uint __stdcall _fill_closed_curve2(_space * graphics,
            _brush * brush,
            const pointf * points,
            int count,
            float tension,
            uint fill_mode);

        export extern "C" uint __stdcall _fill_closed_curve2_integer(_space * graphics,
            _brush * brush,
            const ipoint * points,
            int count,
            float tension,
            uint fill_mode);

        export extern "C" uint __stdcall _fill_region(_space * graphics,
            _brush * brush,
            _region * region);

        export extern "C" uint __stdcall _draw_image(_space * graphics,
            void* image,
            float x,
            float y);

        export extern "C" uint __stdcall _draw_image_integer(_space * graphics,
            void* image,
            int x,
            int y);

        export extern "C" uint __stdcall _draw_image_rectangle(_space * graphics,
            void* image,
            float x,
            float y,
            float width,
            float height);

        export extern "C" uint __stdcall _draw_image_rectangle_integer(_space * graphics,
            void* image,
            int x,
            int y,
            int width,
            int height);

        export extern "C" uint __stdcall _draw_image_points(_space * graphics,
            void* image,
            const pointf * dstpoints,
            int count);

        export extern "C" uint __stdcall _draw_image_points_integer(_space * graphics,
            void* image,
            const ipoint * dstpoints,
            int count);

        export extern "C" uint __stdcall _draw_image_point_rectangle(_space * graphics,
            void* image,
            float x,
            float y,
            float source_x,
            float source_y,
            float source_width,
            float source_height,
            uint source_unit);

        export extern "C" uint __stdcall _draw_image_point_rectangle_integer(_space * graphics,
            void* image,
            int x,
            int y,
            int source_x,
            int source_y,
            int source_width,
            int source_height,
            uint source_unit);

        export extern "C" uint __stdcall _draw_image_rectangle_rectangle(_space * graphics,
            void* image,
            float destination_x,
            float destination_y,
            float destination_width,
            float destination_height,
            float source_x,
            float source_y,
            float source_width,
            float source_height,
            uint source_unit,
            const _image_attributes * image_attributes,
            void* callback,
            void* callback_data);

        export extern "C" uint __stdcall _draw_image_rectangle_rectangle_integer(_space * graphics,
            void* image,
            int destination_x,
            int destination_y,
            int destination_width,
            int destination_height,
            int source_x,
            int source_y,
            int source_width,
            int source_height,
            uint source_unit,
            const _image_attributes * image_attributes,
            void* callback,
            void* callback_data);

        export extern "C" uint __stdcall _draw_image_points_rectangle(_space * graphics,
            void* image,
            const pointf * points,
            int count,
            float source_x,
            float source_y,
            float source_width,
            float source_height,
            uint source_unit,
            const _image_attributes * image_attributes,
            void* callback,
            void* callback_data);

        export extern "C" uint __stdcall _draw_image_points_rectangle_integer(_space * graphics,
            void* image,
            const ipoint * points,
            int count,
            int source_x,
            int source_y,
            int source_width,
            int source_height,
            uint source_unit,
            const _image_attributes * image_attributes,
            void* callback,
            void* callback_data);

        export extern "C" uint __stdcall _enumerate_metafile_destination_point(_space * graphics,
            const _metafile * metafile,
            const pointf & destination_point,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_destination_point_integer(_space * graphics,
            const _metafile * metafile,
            const ipoint & destination_point,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_destination_rectangle(_space * graphics,
            const _metafile * metafile,
            const rectanglef & destination_rectangle,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_destination_rectangle_integer(_space * graphics,
            const _metafile * metafile,
            const rectangle & destination_rectangle,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_destination_points(_space * graphics,
            const _metafile * metafile,
            const pointf * destination_points,
            int count,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_destination_points_integer(_space * graphics,
            const _metafile * metafile,
            const ipoint * destination_points,
            int count,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_source_rectangle_destination_point(_space * graphics,
            const _metafile * metafile,
            const pointf & destination_point,
            const rectanglef & source_rect,
            uint source_unit,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_source_rectangle_destination_point_integer(_space * graphics,
            const _metafile * metafile,
            const ipoint & destination_point,
            const rectangle & source_rect,
            uint source_unit,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_source_rectangle_destination_rectangle(_space * graphics,
            const _metafile * metafile,
            const rectanglef & destination_rectangle,
            const rectanglef & source_rect,
            uint source_unit,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall  _enumerate_metafile_source_rectangle_destination_rectangle_integer(_space * graphics,
            const _metafile * metafile,
            const rectangle & destination_rectangle,
            const rectangle & source_rect,
            uint source_unit,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_source_rectangle_destination_points(_space * graphics,
            const _metafile * metafile,
            const pointf * destination_points,
            int count,
            const rectanglef & source_rect,
            uint source_unit,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        export extern "C" uint __stdcall _enumerate_metafile_source_rectangle_destination_points_integer(_space * graphics,
            const _metafile * metafile,
            const ipoint * destination_points,
            int count,
            const rectangle & source_rect,
            uint source_unit,
            void* callback,
            void* callback_data,
            const _image_attributes * image_attributes);

        //export extern "C" uint __stdcall _play_metafile_record(const _metafile* metafile,
        //    enhanced_plus_record_type record_type,
        //    uint flags,
        //    uint data_size,
        //    const byte* data);

        export extern "C" uint __stdcall _set_clip_graphics(_space * graphics,
            _space * source_graphics,
            uint combine_mode);

        export extern "C" uint __stdcall _set_clip_rectangle(_space * graphics,
            float x,
            float y,
            float width,
            float height,
            uint combine_mode);

        export extern "C" uint __stdcall _set_clip_rectangle_integer(_space * graphics,
            int x,
            int y,
            int width,
            int height,
            uint combine_mode);

        export extern "C" uint __stdcall _set_clip_path(_space * graphics,
            _path * path,
            uint combine_mode);

        export extern "C" uint __stdcall _set_clip_region(_space * graphics,
            _region * region,
            uint combine_mode);

        export extern "C" uint __stdcall _set_clip_region_handle(_space * graphics,
            handle h_rgn,
            uint combine_mode);

        export extern "C" uint __stdcall _reset_clip(_space * graphics);

        export extern "C" uint __stdcall _translate_clip(_space * graphics,
            float dx,
            float dy);

        export extern "C" uint __stdcall _translate_clip_integer(_space * graphics,
            int dx,
            int dy);

        export extern "C" uint __stdcall _get_clip(_space * graphics,
            _region * region);

        export extern "C" uint __stdcall _get_clip_bounds(_space * graphics,
            rectanglef * rect);

        export extern "C" uint __stdcall _get_clip_bounds_integer(_space * graphics,
            rectangle * rect);

        export extern "C" uint __stdcall _is_clip_empty(_space * graphics,
            bool* result);

        export extern "C" uint __stdcall _get_visible_clip_bounds(_space * graphics,
            rectanglef * rect);

        export extern "C" uint __stdcall _get_visible_clip_bounds_integer(_space * graphics,
            rectangle * rect);

        export extern "C" uint __stdcall _is_visible_clip_empty(_space * graphics,
            bool* result);

        export extern "C" uint __stdcall _is_visible_point(_space * graphics,
            float x,
            float y,
            bool* result);

        export extern "C" uint __stdcall _is_visible_point_integer(_space * graphics,
            int x,
            int y,
            bool* result);

        export extern "C" uint __stdcall _is_visible_rectangle(_space * graphics,
            float x,
            float y,
            float width,
            float height,
            bool* result);

        export extern "C" uint __stdcall _is_visible_rectangle_integer(_space * graphics,
            int x,
            int y,
            int width,
            int height,
            bool* result);

        export extern "C" uint __stdcall _save_graphics(_space * graphics,
            _state * state);

        export extern "C" uint __stdcall _restore_graphics(_space * graphics,
            _state state);

        export extern "C" uint __stdcall _begin_container(_space * graphics,
            const rectanglef * destination_rectangle,
            const rectanglef * source_rectangle,
            uint unit,
            _container * state);

        export extern "C" uint __stdcall _begin_container_integer(_space * graphics,
            const rectangle * destination_rectangle,
            const rectangle * source_rectangle,
            uint unit,
            _container * state);

        export extern "C" uint __stdcall _begin_container2(_space * graphics,
            _container * state);

        export extern "C" uint __stdcall _end_container(_space * graphics,
            _container state);

        export extern "C" uint __stdcall _file_header_from_windows_metafile(handle h_wmf,
            const void* wmf_placeable_file_header,
            void* header);

        export extern "C" uint __stdcall _get_metafile_header_from_enhanced_metafile(handle metafile,
            void* header);

        export extern "C" uint __stdcall _get_metafile_header_from_file(const wchar_t* file_name,
            void* header);

        //export extern "C" uint __stdcall _get_metafile_header_from_stream(istream* stream,
        //                                                           void*  header);

        export extern "C" uint __stdcall _get_metafile_header_from_metafile(_metafile * metafile,
            void* header);

        export extern "C" uint __stdcall _get_hemf_from_metafile(_metafile * metafile,
            handle * h_emf);

        //export extern "C" uint __stdcall _create_stream_on_file(const wchar_t* file_name,
        //                                                 uint access, 
        //                                                 istream** stream);

        export extern "C" uint __stdcall _create_metafile_from_windows_metafile(handle h_wmf,
            bool delete_wmf,
            const void* wmf_placeable_file_header,
            _metafile * *metafile);

        export extern "C" uint __stdcall _create_metafile_from_enhanced_metafile(handle h_emf,
            bool delete_emf,
            _metafile * *metafile);

        export extern "C" uint __stdcall _create_metafile_from_file(const wchar_t* file,
            _metafile * *metafile);

        export extern "C" uint __stdcall _create_metafile_from_windows_metafile_file(const wchar_t* file,
            const void* wmf_placeable_file_header,
            _metafile * *metafile);

        //export extern "C" uint __stdcall _create_metafile_from_stream(istream* stream,
        //                                                       _metafile** metafile);

        export extern "C" uint __stdcall _record_metafile(handle reference_device_context,
            uint type,
            const rectanglef * frame_rectangle,
            uint frame_unit,
            const wchar_t* description,
            _metafile * *metafile);

        export extern "C" uint __stdcall _record_metafile_integer(handle reference_device_context,
            uint type,
            const rectangle * frame_rectangle,
            uint frame_unit,
            const wchar_t* description,
            _metafile * *metafile);

        export extern "C" uint __stdcall _record_metafile_file_name(const wchar_t* file_name,
            handle reference_device_context,
            uint type,
            const rectanglef * frame_rectangle,
            uint frame_unit,
            const wchar_t* description,
            _metafile * *metafile);

        export extern "C" uint __stdcall _record_metafile_file_name_integer(const wchar_t* file_name,
            handle reference_device_context,
            uint type,
            const rectangle * frame_rectangle,
            uint frame_unit,
            const wchar_t* description,
            _metafile * *metafile);

        //export extern "C" uint __stdcall _record_metafile_stream(istream* stream,
        //                                                  handle reference_device_context,
        //                                                  uint type,
        //                                                  const rectanglef* frame_rectangle,
        //                                                  uint frame_unit,
        //                                                  const wchar_t * description,
        //                                                  _metafile** metafile);

        //export extern "C" uint __stdcall _record_metafile_stream_integer(i_stream* stream,
        //                                                          handle  reference_device_context,
        //                                                          uint type,
        //                                                          const rectangle* frame_rectangle,
        //                                                          uint frame_unit,
        //                                                          const wchar_t* description,
        //                                                          _metafile** metafile);

        export extern "C" uint __stdcall _set_metafile_down_level_rasterization_limit(_metafile * metafile,
            uint metafile_rasterization_limit_dpi);

        export extern "C" uint __stdcall _get_metafile_down_level_rasterization_limit(const _metafile * metafile,
            uint * metafile_rasterization_limit_dpi);

        export extern "C" uint __stdcall _get_image_decoders_size(uint * number_of_decoders,
            uint * size);

        export extern "C" uint __stdcall _get_image_decoders(uint number_of_decoders,
            uint size,
            void* decoders);

        export extern "C" uint __stdcall _get_image_encoders_size(uint * number_of_encoders,
            uint * size);

        export extern "C" uint __stdcall _get_image_encoders(uint number_of_encoders,
            uint size,
            void* encoders);

        export extern "C" uint __stdcall _comment(_space * graphics,
            uint size_data,
            const byte * data);

        //----------------------------------------------------------------------------
        // font_family ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_font_family_from_name(const wchar_t* name,
            _font_collection * font_collection,
            _font_family * *font_family);

        export extern "C" uint __stdcall _delete_font_family(_font_family * font_family);

        export extern "C" uint __stdcall _clone_font_family(_font_family * font_family,
            _font_family * *cloned_font_family);

        export extern "C" uint __stdcall _get_generic_font_family_sans_serif(_font_family * *native_family);

        export extern "C" uint __stdcall _get_generic_font_family_serif(_font_family * *native_family);

        export extern "C" uint __stdcall _get_generic_font_family_monospace(_font_family * *native_family);

        export extern "C" uint __stdcall _get_family_name(const _font_family * family,
            wchar_t name[32],
            uint language);

        export extern "C" uint __stdcall _is_style_available(const _font_family * family,
            int style,
            bool* is_style_available);

        export extern "C" uint __stdcall _font_collection_enumerable(_font_collection * font_collection,
            _space * graphics,
            int* num_found);

        export extern "C" uint __stdcall _font_collection_enumerate(_font_collection * font_collection,
            int num_sought,
            _font_family * gpfamilies[],
            int* num_found,
            _space * graphics);

        export extern "C" uint __stdcall _get_em_height(const _font_family * family,
            int style,
            ushort * em_height);

        export extern "C" uint __stdcall _get_cell_ascent(const _font_family * family,
            int style,
            ushort * cell_ascent);

        export extern "C" uint __stdcall _get_cell_descent(const _font_family * family,
            int style,
            ushort * cell_descent);

        export extern "C" uint __stdcall _get_line_spacing(const _font_family * family,
            int style,
            ushort * line_spacing);

        //----------------------------------------------------------------------------
        // font ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_font_from_device_context(handle hdc,
            _font * *font);

        export extern "C" uint __stdcall _create_font_from_logical_font_ascii(handle hdc,
            const logical_font_ascii * logical_font,
            _font * *font);

        export extern "C" uint __stdcall _create_font_from_logical_font_wide(handle hdc,
            const logical_font_wide * logical_font,
            _font * *font);

        export extern "C" uint __stdcall _create_font(const _font_family * font_family,
            float em_size,
            int style,
            uint unit,
            _font * *font);

        export extern "C" uint __stdcall _clone_font(_font * font,
            _font * *clone_font);

        export extern "C" uint __stdcall _delete_font(_font * font);

        export extern "C" uint __stdcall _get_family(_font * font,
            _font_family * *family);

        export extern "C" uint __stdcall _get_font_style(_font * font,
            int* style);

        export extern "C" uint __stdcall _get_font_size(_font * font,
            float* size);

        export extern "C" uint __stdcall _get_font_unit(_font * font,
            uint * unit);

        export extern "C" uint __stdcall _get_font_height(const _font * font,
            const _space * graphics,
            float* height);

        export extern "C" uint __stdcall _get_font_height_given_dots_per_inch(const _font * font,
            float dpi,
            float* height);

        export extern "C" uint __stdcall _get_logical_font_ascii(_font * font,
            _space * graphics,
            logical_font_ascii * logical_font_a);

        export extern "C" uint __stdcall _get_logical_font_wide(_font * font,
            _space * graphics,
            logical_font_wide * logical_font_w);

        export extern "C" uint __stdcall _new_installed_font_collection(_font_collection * *font_collection);

        export extern "C" uint __stdcall _new_private_font_collection(_font_collection * *font_collection);

        export extern "C" uint __stdcall _delete_private_font_collection(_font_collection * font_collection);

        export extern "C" uint __stdcall _get_font_collection_family_count(_font_collection * font_collection,
            int* number_found);

        export extern "C" uint __stdcall _get_font_collection_family_list(_font_collection * font_collection,
            int number_sought,
            _font_family * gpfamilies[],
            int* number_found);

        export extern "C" uint __stdcall _private_add_font_file(_font_collection * font_collection,
            const wchar_t* file_name);

        export extern "C" uint __stdcall _private_add_memory_font(_font_collection * font_collection,
            const void* memory,
            int length);

        //----------------------------------------------------------------------------
        // text ap_is
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _draw_string(_space * graphics,
            const wchar_t* string,
            int length,
            const _font * font,
            const rectanglef * layout_rect,
            const _string_format * string_format,
            const _brush * brush);

        export extern "C" uint __stdcall _measure_string(_space * graphics,
            const wchar_t* string,
            int length,
            const _font * font,
            const rectanglef * layout_rect,
            const _string_format * string_format,
            rectanglef * bounding_box,
            int* codepoints_fitted,
            int* lines_filled);

        export extern "C" uint __stdcall _measure_character_ranges(_space * graphics,
            const wchar_t* string,
            int length,
            const _font * font,
            const rectanglef & layout_rect,
            const _string_format * string_format,
            int region_count,
            _region * *regions);

        export extern "C" uint __stdcall _draw_driver_string(_space * graphics,
            const wchar_t* text,
            int length,
            const _font * font,
            const _brush * brush,
            const pointf * positions,
            int flags,
            const _matrix * matrix);

        export extern "C" uint __stdcall _measure_driver_string(_space * graphics,
            const wchar_t* text,
            int length,
            const _font * font,
            const pointf * positions,
            int flags,
            const _matrix * matrix,
            rectanglef * bounding_box);

        //----------------------------------------------------------------------------
        // string format apis
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_string_format(int format_attributes,
            uint language,
            _string_format * *format);

        export extern "C" uint __stdcall _string_format_get_generic_default(_string_format * *format);

        export extern "C" uint __stdcall _string_format_get_generic_typographic(_string_format * *format);

        export extern "C" uint __stdcall _delete_string_format(_string_format * format);

        export extern "C" uint __stdcall _clone_string_format(const _string_format * format,
            _string_format * *new_format);

        export extern "C" uint __stdcall _set_string_format_flags(_string_format * format,
            int flags);

        export extern "C" uint __stdcall _get_string_format_flags(const _string_format * format,
            int* flags);

        export extern "C" uint __stdcall _set_string_format_align(_string_format * format,
            uint align);

        export extern "C" uint __stdcall _get_string_format_align(const _string_format * format,
            uint * align);

        export extern "C" uint __stdcall _set_string_format_line_align(_string_format * format,
            uint align);

        export extern "C" uint __stdcall _get_string_format_line_align(const _string_format * format,
            uint * align);

        export extern "C" uint __stdcall _set_string_format_trimming(_string_format * format,
            uint  trimming);

        export extern "C" uint __stdcall _get_string_format_trimming(const _string_format * format,
            uint * trimming);

        export extern "C" uint __stdcall _set_string_format_hotkey_prefix(_string_format * format,
            int hotkey_prefix);

        export extern "C" uint __stdcall _get_string_format_hotkey_prefix(const _string_format * format,
            int* hotkey_prefix);

        export extern "C" uint __stdcall _set_string_format_tab_stops(_string_format * format,
            float first_tab_offset,
            int count,
            const float* tab_stops);

        export extern "C" uint __stdcall _get_string_format_tab_stops(const _string_format * format,
            int count,
            float* first_tab_offset,
            float* tab_stops);

        export extern "C" uint __stdcall _get_string_format_tab_stop_count(const _string_format * format,
            int* count);

        export extern "C" uint __stdcall _set_string_format_digit_substitution(_string_format * format,
            uint language,
            uint substitute);

        export extern "C" uint __stdcall _get_string_format_digit_substitution(const _string_format * format,
            uint * language,
            uint * substitute);

        export extern "C" uint __stdcall _get_string_format_measurable_character_range_count(const _string_format * format,
            int* count);

        export extern "C" uint __stdcall _set_string_format_measurable_character_ranges(_string_format * format,
            int range_count,
            character_range * ranges);

        //----------------------------------------------------------------------------
        // cached bitmap apis
        //----------------------------------------------------------------------------

        export extern "C" uint __stdcall _create_cached_bitmap(_bitmap * bitmap,
            _space * graphics,
            _cached_bitmap * *cached_bitmap);

        export extern "C" uint __stdcall _delete_cached_bitmap(_cached_bitmap * cached_bitmap);

        export extern "C" uint __stdcall _draw_cached_bitmap(_space * graphics,
            _cached_bitmap * cached_bitmap,
            int x,
            int y);

        export extern "C" uint __stdcall _enhanced_metafile_to_windows_metafile_bits(handle hemf,
            uint cb_data16,
            byte * p_data16,
            int i_map_mode,
            int e_flags);

        export extern "C" uint __stdcall _set_image_attributes_cached_background(_image_attributes * image_attributes,
            bool enable_flag);

        export extern "C" uint __stdcall _test_control(uint control,
            void* param);

        export extern "C" uint cdecl _notification_hook(void** token);

        export extern "C" void cdecl _notification_unhook(void* token);
    }

    export template<class character>
        void reverse(character* toreverse)
    {
        if (toreverse)
        {
            character* start = toreverse;
            character* end = start + string_length(toreverse) - 1;

            while (end - start > 0)
            {
                character save_character(*start);
                *start = *end;
                *end = save_character;
                start++; end--;
            }
        }
    }

    export extern "C" atom register_window_class(const character * class_name,
        procedure procedure_to_register,
        uint style,
        int window_extra = sizeof(void*),
        handle module_handle = nullptr)
    {
        if (!module_handle) module_handle = get_module_handle<character>();

        window_class<character> class_register;

        class_register.name = class_name;
        class_register.style = style;
        class_register.procedure = procedure_to_register;
        class_register.window = window_extra;
        class_register.module = module_handle;
        class_register.icon = load_icon((handle)null, (const character*)icon_identity::application);
        class_register.cursor = load_cursor((handle)null, (const character*)cursor_identity::arrow);
        class_register.brush = (handle)get_standard_object(standard_brush::white);

        return register_class(&class_register);
    }

    //**********************************************
    //************* print api **********************
    //**********************************************

    export extern "C" bool __stdcall delete_form_a(handle printer,
        const char* name);

    export extern "C" bool __stdcall delete_form_w(handle printer,
        const wchar_t* name);

    export template <class character>
        inline int delete_form(handle printer,
            const character* name)
    {
        if (sizeof(character) == 1)
            return delete_form_a(printer,
                (const char*)name);
        else
            return delete_form_w(printer,
                (const wchar_t*)name);
    }

    export extern "C" handle __stdcall add_printer_a(const char* name,
        unsigned level,
        byte * printer);

    export extern "C" handle __stdcall add_printer_w(const wchar_t* name,
        unsigned level,
        byte * printer);

    export template <class character>
        inline handle add_printer(const character* name,
            unsigned level,
            byte* printer)
    {
        if (sizeof(character) == 1)
            return add_printer_a((const char*)name,
                level,
                printer);
        else
            return add_printer_w((const wchar_t*)name,
                level,
                printer);
    }

    export extern "C" bool __stdcall add_printer_connection_a(const char* name);

    export extern "C" bool __stdcall add_printer_connection_w(const wchar_t* name);

    export template <class character>
        inline handle add_printer_connection(const character* name)
    {
        if (sizeof(character) == 1)
            return add_printer_connection_a((const char*)name);
        else
            return add_printer_connection_w((const wchar_t*)name);

    }

    export extern "C" bool __stdcall enumerate_printers_a(unsigned flags,
        const char* name,
        unsigned level,
        byte * buffer,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool __stdcall enumerate_printers_w(unsigned flags,
        const wchar_t* name,
        unsigned level,
        byte * buffer,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export template <class character>
        inline bool enumerate_printers(unsigned flags,
            const wchar_t* name,
            unsigned level,
            byte* buffer,
            unsigned size,
            unsigned* required,
            unsigned* returned)
    {
        if (sizeof(character) == 1)
            return enumerate_printers_a(flags,
                (const char*)name,
                level,
                buffer,
                size,
                required,
                returned);
        else
            return enumerate_printers_w(flags,
                (const wchar_t*)name,
                level,
                buffer,
                size,
                required,
                returned);
    }

    export extern "C" bool __stdcall add_printer_driver_a(const char* server,
        unsigned level,
        byte * driver_information);

    export extern "C" bool __stdcall add_printer_driver_w(const wchar_t* server,
        unsigned level,
        byte * driver_information);

    export template <class character>
        inline bool add_printer_driver(const character* server,
            unsigned level,
            byte* driver_information)
    {
        if (sizeof(character) == 1)
            return add_printer_driver_a((const char*)server,
                level,
                driver_information);
        else
            return add_printer_driver_w((const wchar_t*)server,
                level,
                driver_information);

    }

    export extern "C" bool __stdcall add_printer_driver_extended_a(const char* name,
        unsigned level,
        byte * driver_information,
        unsigned flags);

    export extern "C" bool __stdcall add_printer_driver_extended_w(const wchar_t* name,
        unsigned level,
        byte * driver_information,
        unsigned flags);

    export template <class character>
        inline bool add_printer_driver_extended(const character* server,
            unsigned level,
            byte* driver_information,
            unsigned flags)
    {
        if (sizeof(character) == 1)
            return add_printer_driver_extended_a((const char*)server,
                level,
                driver_information,
                flags);
        else
            return add_printer_driver_extended_w((const wchar_t*)server,
                level,
                driver_information,
                flags);

    }

    export extern "C" bool __stdcall add_print_processor_a(const char* server,
        const char* environment,
        const char* path_name,
        const char* print_processor_name);

    export extern "C" bool __stdcall add_print_processor_w(const wchar_t* server,
        const wchar_t* environment,
        const wchar_t* path_name,
        const wchar_t* print_processor_name);

    export template <class character>
        inline bool add_print_processor(const character* server,
            const character* environment,
            const character* path_name,
            const character* print_processor_name)
    {
        if (sizeof(character) == 1)
            return add_print_processor_a((const char*)server,
                (const char*)environment,
                (const char*)path_name,
                (const char*)print_processor_name);
        else
            return add_print_processor_w((const wchar_t*)server,
                (const wchar_t*)environment,
                (const wchar_t*)path_name,
                (const wchar_t*)print_processor_name);

    }

    export extern "C" bool __stdcall get_print_processor_directory_a(const char* server,
        const char* environment,
        unsigned level,
        byte * information,
        unsigned size,
        unsigned* required);

    export extern "C" bool __stdcall get_print_processor_directory_w(const wchar_t* server,
        const wchar_t* environment,
        unsigned level,
        byte * information,
        unsigned size,
        unsigned* required);

    export template <class character>
        inline bool get_print_processor_directory(const character* server,
            const character* environment,
            unsigned level,
            byte* information,
            unsigned size,
            unsigned* required)
    {
        if (sizeof(character) == 1)
            return get_print_processor_directory_a((const char*)server,
                (const char*)environment,
                level,
                information,
                size,
                required);
        else
            return get_print_processor_directory_w((const wchar_t*)server,
                (const wchar_t*)environment,
                level,
                information,
                size,
                required);

    }

    export extern "C" bool __stdcall enumerate_print_processors_a(const char* server,
        const char* environment,
        unsigned level,
        byte * information,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool __stdcall enumerate_print_processors_w(const wchar_t* server,
        const wchar_t* environment,
        unsigned level,
        byte * information,
        unsigned size,
        unsigned* required,
        unsigned* returned);


    export template <class character>
        inline bool enumerate_print_processors(const character* server,
            const character* environment,
            unsigned level,
            byte* information,
            unsigned size,
            unsigned* required,
            unsigned* returned)
    {
        if (sizeof(character) == 1)
            return enumerate_print_processors_a((const char*)server,
                (const char*)environment,
                level,
                information,
                size,
                required,
                returned);
        else
            return enumerate_print_processors_w((const wchar_t*)server,
                (const wchar_t*)environment,
                level,
                information,
                size,
                required,
                returned);

    }

    export extern "C" bool __stdcall add_print_providor_a(const char* name,
        unsigned level,
        byte * providor_information);

    export extern "C" bool __stdcall add_print_providor_w(const wchar_t* name,
        unsigned level,
        byte * providor_information);

    export template <class character>
        inline bool add_print_providor(const character* name,
            unsigned level,
            byte* providor_information)
    {
        if (sizeof(character) == 1)
            return add_print_providor_a((const char*)name,
                level,
                providor_information);
        else
            return add_print_providor_w((const wchar_t*)name,
                level,
                providor_information);

    }

    export extern "C" bool __stdcall open_printer_a(const char* printer_name,
        handle * printer,
        printer_defaults<char>*printer_defaults_open);


    export extern "C" bool __stdcall open_printer_w(const wchar_t* printer_name,
        handle * printer,
        printer_defaults<wchar_t>*printer_defaults_open);

    export template <class character>
        inline bool _open_printer(const character* printer_name,
            handle* printer,
            printer_defaults<character>* printer_defaults_open)
    {
        if (sizeof(character) == 1)
            return open_printer_a((const char*)printer_name,
                printer,
                printer_defaults_open);
        else
            return open_printer_w((const wchar_t*)printer_name,
                printer,
                printer_defaults_open);
    }

    export extern "C" bool __stdcall reset_printer_a(handle printer,
        printer_defaults<char> *defaults);

    export extern "C" bool __stdcall reset_printer_w(handle printer,
        printer_defaults<wchar_t>*defaults);

    export template <class character>
        inline bool reset_printer(handle printer,
            printer_defaults<character>* defaults)
    {
        if (sizeof(character) == 1)
            return reset_printer_a(printer,
                defaults);
        else
            return reset_printer_w(printer,
                defaults);
    }

    export extern "C" bool __stdcall set_job_a(handle Printer,
        unsigned identity,
        unsigned level,
        char* job,
        unsigned command);

    export extern "C" bool __stdcall set_job_w(handle Printer,
        unsigned identity,
        unsigned level,
        wchar_t* job,
        unsigned command);

    export template <class character>
        inline bool set_job(handle printer,
            unsigned identity,
            unsigned level,
            character* job,
            unsigned command)
    {
        if (sizeof(character) == 1)
            return set_job_a(printer,
                identity,
                level,
                job,
                command);
        else
            return set_job_w(printer,
                identity,
                level,
                job,
                command);

    }

    export extern "C" bool __stdcall get_job_a(handle printer,
        unsigned Identity,
        unsigned Level,
        byte * job,
        unsigned Size,
        unsigned* Required);

    export extern "C" bool __stdcall get_job_w(handle printer,
        unsigned identity,
        unsigned level,
        byte * job,
        unsigned Size,
        unsigned* required);

    export extern "C" bool get_job(handle printer,
        unsigned identity,
        unsigned level,
        byte * job,
        unsigned size,
        unsigned* required)
    {
        return get_job_w(printer,
            identity,
            level,
            job,
            size,
            required);
    }

    export extern "C" bool __stdcall enumerate_jobs_a(handle printer,
        unsigned first_job,
        unsigned jobs,
        unsigned level,
        byte * job,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool __stdcall enumerate_jobs_w(handle printer,
        unsigned first_job,
        unsigned jobs,
        unsigned level,
        byte * job,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool enumerate_jobs(handle printer,
        unsigned first_job,
        unsigned jobs,
        unsigned level,
        byte * job,
        unsigned size,
        unsigned* required,
        unsigned* returned)
    {
        return enumerate_jobs_w(printer,
            first_job,
            jobs,
            level,
            job,
            size,
            required,
            returned);

    }

    export extern "C" bool __stdcall delete_printer(handle Printer);

    export extern "C" bool __stdcall set_printer_a(handle printer,
        unsigned level,
        byte * status,
        unsigned command);

    export extern "C" bool __stdcall set_printer_w(handle printer,
        unsigned level,
        byte * status,
        unsigned command);

    export extern "C" bool set_printer(handle printer,
        unsigned level,
        byte * status,
        unsigned command)
    {
        return set_printer_w(printer,
            level,
            status,
            command);
    }

    export extern "C" bool __stdcall get_printer_a(handle printer,
        unsigned level,
        byte * status,
        unsigned size,
        unsigned* required);


    export extern "C" bool __stdcall get_printer_w(handle printer,
        unsigned level,
        byte * status,
        unsigned size,
        unsigned* required);

    export extern "C" bool get_printer(handle printer,
        unsigned level,
        byte * status,
        unsigned size,
        unsigned* required)
    {
        return get_printer_w(printer,
            level,
            status,
            size,
            required);
    }

    export extern "C" bool __stdcall get_printer_driver_a(handle printer,
        const char* environment,
        unsigned level,
        byte * driver_information,
        unsigned size,
        unsigned* required);

    export extern "C" bool __stdcall get_printer_driver_w(handle printer,
        const wchar_t* environment,
        unsigned level,
        byte * driver_information,
        unsigned size,
        unsigned* required);

    export template <class character>
        inline bool get_printer_driver(handle printer,
            const character* environment,
            unsigned level,
            byte* driver_information,
            unsigned size,
            unsigned* required)
    {
        if (sizeof(character) == 1)
            return get_printer_driver_a(printer,
                (const char*)environment,
                level,
                (char*)driver_information,
                size,
                required);
        else
            return get_printer_driver_w(printer,
                (const wchar_t*)environment,
                level,
                (wchar_t*)driver_information,
                size,
                required);
    }

    export extern "C" bool __stdcall enumerate_printer_drivers_a(const char* server,
        const char* environment,
        unsigned level,
        byte * driver_information,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool __stdcall enumerate_printer_drivers_w(const wchar_t* server,
        const wchar_t* environment,
        unsigned level,
        byte * driver_information,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export template <class character>
        inline bool enumerate_printer_drivers(const character* server,
            const character* environment,
            unsigned level,
            byte* driver_information,
            unsigned size,
            unsigned* required,
            unsigned* returned)
    {
        if (sizeof(character) == 1)
            return enumerate_printer_drivers_a((const char*)server,
                (const char*)environment,
                level,
                driver_information,
                size,
                required,
                returned);
        else
            return enumerate_printer_drivers_w((const wchar_t*)server,
                (const wchar_t*)environment,
                level,
                (wchar_t*)driver_information,
                size,
                required,
                returned);
    }

    export extern "C" bool __stdcall get_printer_driver_directory_a(const char* name,
        const char* environment,
        unsigned level,
        char* driver_directory,
        unsigned size,
        unsigned* required);

    export extern "C" bool __stdcall get_printer_driver_directory_w(const wchar_t* name,
        const wchar_t* environment,
        unsigned level,
        wchar_t* driver_directory,
        unsigned size,
        unsigned* required);

    export template <class character>
        inline bool get_printer_driver_directory(const character* name,
            const character* environment,
            unsigned level,
            character* driver_directory,
            unsigned size,
            unsigned* required)
    {
        if (sizeof(character) == 1)
            return get_printer_driver_directory_a((const char*)name,
                (const char*)environment,
                level,
                (char*)driver_directory,
                size,
                required);
        else
            return get_printer_driver_directory_w((const wchar_t*)name,
                (const wchar_t*)environment,
                level,
                (wchar_t*)driver_directory,
                size,
                required);

    }

    export extern "C" bool __stdcall delete_printer_driver_a(const char* server,
        const char* environment,
        const char* driver_name);

    export extern "C" bool __stdcall delete_printer_driver_w(const wchar_t* server,
        const wchar_t* environment,
        const wchar_t* driver_name);

    export template <class character>
        inline bool delete_printer_driver(const character* server,
            const character* environment,
            const character* driver_name)
    {
        if (sizeof(character) == 1)
            return delete_printer_driver_a((const char*)server,
                (const char*)environment,
                (const char*)driver_name);
        else
            return delete_printer_driver_w((const wchar_t*)server,
                (const wchar_t*)environment,
                (const wchar_t*)driver_name);

    }

    export extern "C" bool __stdcall delete_printer_driver_extended_a(const char* server,
        const char* environment,
        const char* driver_name,
        unsigned flags,
        unsigned version);

    export extern "C" bool __stdcall delete_printer_driver_extended_w(const wchar_t* server,
        const wchar_t* environment,
        const wchar_t* driver_name,
        unsigned flags,
        unsigned version);

    export template <class character>
        inline bool delete_printer_driver_extended(const character* server,
            const character* environment,
            const character* driver_name,
            unsigned flags,
            unsigned version)
    {
        if (sizeof(character) == 1)
            return delete_printer_driver_extended_a((const char*)server,
                (const char*)environment,
                (const char*)driver_name,
                flags,
                version);
        else
            return delete_printer_driver_extended_w((const wchar_t*)server,
                (const wchar_t*)environment,
                (const wchar_t*)driver_name,
                flags,
                version);

    }

    export extern "C" bool __stdcall enumerate_print_processor_data_types_a(const char* server,
        const char* print_processor_name,
        unsigned level,
        byte * data_types,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool __stdcall enumerate_print_processor_data_types_w(const wchar_t* server,
        const wchar_t* print_processor_name,
        unsigned level,
        byte * data_types,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export template <class character>
        inline bool enumerate_print_processor_data_types(const character* server,
            const character* print_processor_name,
            unsigned level,
            byte* data_types,
            unsigned size,
            unsigned* required,
            unsigned* returned)
    {
        if (sizeof(character) == 1)
            return enumerate_print_processor_data_types_a((const char*)server,
                (const char*)print_processor_name,
                level,
                data_types,
                size,
                required,
                returned);
        else
            return enumerate_print_processor_data_types_w((const wchar_t*)server,
                (const wchar_t*)print_processor_name,
                level,
                data_types,
                size,
                required,
                returned);

    }

    export extern "C" bool __stdcall delete_print_processor_a(const char* server,
        const char* environment,
        const char* print_processor_name);

    export extern "C" bool __stdcall delete_print_processor_w(const wchar_t* server,
        const wchar_t* environment,
        const wchar_t* print_processor_name);

    export template <class character>
        inline bool delete_print_processor(const character* server,
            const character* environment,
            const character* print_processor_name)
    {
        if (sizeof(character) == 1)
            return delete_print_processor_a((const char*)server,
                (const char*)environment,
                (const char*)print_processor_name);
        else
            return delete_print_processor_w((const wchar_t*)server,
                (const wchar_t*)environment,
                (const wchar_t*)print_processor_name);

    }

    //export extern "C" bool __stdcall cancel_printer(handle printer);

    export extern "C" unsigned __stdcall start_document_printer_a(handle printer,
        unsigned level,
        byte * document_information);

    export extern "C" unsigned __stdcall start_document_printer_w(handle printer,
        unsigned level,
        byte * document_information);

    export extern "C" inline unsigned start_document_printer(handle printer,
        unsigned level,
        byte * document_information)
    {
        return start_document_printer_w(printer,
            level,
            document_information);

    }

    export extern "C" bool __stdcall end_document_printer(handle printer);

    export extern "C" bool __stdcall start_page_printer(handle printer);

    export extern "C" bool __stdcall end_page_printer(handle printer);

    export extern "C" bool __stdcall read_printer(handle printer,
        void* buffer,
        unsigned size,
        unsigned* bytes_read);

    export extern "C" bool __stdcall write_printer(handle printer,
        const void* buffer,
        unsigned size,
        unsigned* bytes_written);

    export extern "C" bool __stdcall add_job_a(handle printer,
        unsigned level,
        byte * data,
        unsigned size,
        unsigned* required);

    export extern "C" bool __stdcall add_job_w(handle printer,
        unsigned level,
        byte * data,
        unsigned size,
        unsigned* required);

    export extern "C" inline bool add_job(handle printer,
        unsigned level,
        byte * data,
        unsigned size,
        unsigned* required)
    {
        return add_job_w(printer,
            level,
            data,
            size,
            required);
    }

    export extern "C" bool __stdcall schedule_job(handle printer,
        unsigned identity);

    export extern "C" bool __stdcall printer_properties(handle window,
        handle printer);

    export extern "C" int __stdcall document_properties_a(handle window,
        handle printer,
        const char* device_mame,
        device_mode<char>*device_mode_output,
        const device_mode<char>*device_mode_input,
        unsigned mode);

    export extern "C" int __stdcall document_properties_w(handle window,
        handle printer,
        const wchar_t* device_mame,
        device_mode<wchar_t>*device_mode_output,
        const device_mode<wchar_t>*device_mode_input,
        unsigned mode);

    export template <class character>
        inline int document_properties(handle window,
            handle printer,
            const character* device_mame,
            device_mode<character>* device_mode_output,
            const device_mode<character>* device_mode_input,
            unsigned mode)
    {
        if (sizeof(character) == 1)
            return document_properties_a(window,
                printer,
                (const char*)device_mame,
                (device_mode<char>*) device_mode_output,
                (const device_mode<char>*) device_mode_input,
                mode);
        else
            return document_properties_w(window,
                printer,
                (const wchar_t*)device_mame,
                (device_mode<wchar_t>*) device_mode_output,
                (const device_mode<wchar_t>*) device_mode_input,
                mode);
    }

    export extern "C" int __stdcall advanced_document_properties_a(handle window,
        handle printer,
        const char* device_name,
        device_mode<char>*device_mode_output,
        const device_mode<char>*device_mode_input);

    export extern "C" int __stdcall advanced_document_properties_w(handle window,
        handle printer,
        const wchar_t* device_name,
        device_mode<wchar_t>*device_mode_output,
        const device_mode<wchar_t>*device_mode_input);

    export template <class character>
        inline int advanced_document_properties(handle window,
            handle printer,
            const char* device_name,
            device_mode<char>* device_mode_output,
            const device_mode<char>* device_mode_input)
    {
        if (sizeof(character) == 1)
            return advanced_document_properties_a(window,
                printer,
                (const char*)device_name,
                (device_mode<char>*) device_mode_output,
                (const device_mode<char>*) device_mode_input);
        else
            return advanced_document_properties_w(window,
                printer,
                (const wchar_t*)device_name,
                (device_mode<wchar_t>*) device_mode_output,
                (const device_mode<wchar_t>*) device_mode_input);
    }

    export extern "C" unsigned __stdcall get_printer_data_a(handle printer,
        const char* name,
        unsigned* type,
        byte * data,
        unsigned size,
        unsigned* required);

    export extern "C" unsigned __stdcall get_printer_data_w(handle printer,
        const wchar_t* name,
        unsigned* type,
        byte * data,
        unsigned size,
        unsigned* required);

    export template <class character>
        inline unsigned get_printer_data(handle printer,
            const char* name,
            unsigned* type,
            byte* data,
            unsigned size,
            unsigned* required)
    {
        if (sizeof(character) == 1)
            return get_printer_data_a(printer,
                (const char*)name,
                type,
                data,
                size,
                required);
        else
            return get_printer_data_w(printer,
                (const wchar_t*)name,
                type,
                data,
                size,
                required);

    }

    export extern "C" unsigned __stdcall get_printer_data_extended_a(handle printer,
        const char* key_name,
        const char* value_name,
        unsigned* type,
        byte * data,
        unsigned size,
        unsigned* required);

    export extern "C" unsigned __stdcall get_printer_data_extended_w(handle printer,
        const wchar_t* key_name,
        const wchar_t* value_name,
        unsigned* type,
        byte * data,
        unsigned size,
        unsigned* required);

    export template <class character>
        inline unsigned get_printer_data_extended(handle printer,
            const character* key_name,
            const character* value_name,
            unsigned* type,
            byte* data,
            unsigned size,
            unsigned* required)
    {
        if (sizeof(character) == 1)
            return get_printer_data_extended_a(printer,
                (const char*)key_name,
                (const char*)value_name,
                type,
                data,
                size,
                required);
        else
            return get_printer_data_extended_w(printer,
                (const wchar_t*)key_name,
                (const wchar_t*)value_name,
                type,
                data,
                size,
                required);
    }

    export extern "C" unsigned __stdcall set_printer_data_a(handle printer,
        const char* name,
        unsigned type,
        const byte * data,
        unsigned size);

    export extern "C" unsigned __stdcall set_printer_data_w(handle printer,
        const wchar_t* name,
        unsigned type,
        const byte * data,
        unsigned size);

    export template <class character>
        inline unsigned set_printer_data(handle printer,
            const char* name,
            unsigned type,
            const byte* data,
            unsigned size)
    {
        if (sizeof(character) == 1)
            return set_printer_data_a(printer,
                (const char*)name,
                type,
                data,
                size);
        else
            return set_printer_data_w(printer,
                (const wchar_t*)name,
                type,
                data,
                size);
    }

    export extern "C" unsigned __stdcall set_printer_data_extended_a(handle printer,
        const char* key_name,
        const char* value_name,
        unsigned type,
        const byte * data,
        unsigned size);

    export extern "C" unsigned __stdcall set_printer_data_extended_w(handle printer,
        const wchar_t* key_name,
        const wchar_t* value_name,
        unsigned type,
        const byte * data,
        unsigned size);

    export template <class character>
        inline unsigned set_printer_data_extended(handle printer,
            const character* key_name,
            const character* value_name,
            unsigned type,
            const byte* data,
            unsigned size)
    {
        if (sizeof(character) == 1)
            return set_printer_data_extended_a(printer,
                (const char*)key_name,
                (const char*)value_name,
                type,
                data,
                size);
        else
            return set_printer_data_extended_w(printer,
                (const wchar_t*)key_name,
                (const wchar_t*)value_name,
                type,
                data,
                size);

    }

    export extern "C" unsigned __stdcall delete_printer_data_a(handle printer,
        const char* name);

    export extern "C" unsigned __stdcall delete_printer_data_w(handle printer,
        const wchar_t* name);

    export template <class character>
        inline unsigned delete_printer_data(handle printer,
            const character* name)
    {
        if (sizeof(character) == 1)
            return delete_printer_data_a(printer,
                (const char*)name);
        else
            return delete_printer_data_w(printer,
                (const wchar_t*)name);

    }

    export extern "C" unsigned __stdcall delete_printer_data_extended_a(handle printer,
        const char* key,
        const char* value);

    export extern "C" unsigned __stdcall delete_printer_data_extended_w(handle printer,
        const wchar_t* key,
        const wchar_t* value);

    export template <class character>
        inline unsigned delete_printer_data_extended(handle printer,
            const character* key,
            const character* value)
    {
        if (sizeof(character) == 1)
            return delete_printer_data_extended_a(printer,
                (const char*)key,
                (const char*)value);
        else
            return delete_printer_data_extended_w(printer,
                (const wchar_t*)key,
                (const wchar_t*)value);

    }

    export extern "C" unsigned __stdcall delete_printer_key_a(handle printer,
        const char* key_name);

    export extern "C" unsigned __stdcall delete_printer_key_w(handle printer,
        const wchar_t* key_name);

    export template <class character>
        inline unsigned delete_printer_key(handle printer,
            const character* key_name)
    {
        if (sizeof(character) == 1)
            return delete_printer_key_a(printer,
                (const char*)key_name);
        else
            return delete_printer_key_w(printer,
                (const wchar_t*)key_name);

    }

    export extern "C" unsigned __stdcall enumerate_printer_data_a(handle printer,
        unsigned index,
        char* name,
        unsigned length,
        unsigned* name_length_required,
        unsigned* type,
        byte * data,
        unsigned data_length,
        unsigned* data_length_required);

    export extern "C" unsigned __stdcall enumerate_printer_data_w(handle printer,
        unsigned index,
        wchar_t* name,
        unsigned length,
        unsigned* name_length_required,
        unsigned* type,
        byte * data,
        unsigned data_length,
        unsigned* data_length_required);

    export template <class character>
        inline unsigned enumerate_printer_data(handle printer,
            unsigned index,
            character* name,
            unsigned length,
            unsigned* name_length_required,
            unsigned* type,
            byte* data,
            unsigned data_length,
            unsigned* data_length_required)
    {
        if (sizeof(character) == 1)
            return enumerate_printer_data_a(printer,
                index,
                (char*)name,
                length,
                name_length_required,
                type,
                data,
                data_length,
                data_length_required);
        else
            return enumerate_printer_data_w(printer,
                index,
                (wchar_t*)name,
                length,
                name_length_required,
                type,
                data,
                data_length,
                data_length_required);
    }

    export extern "C" unsigned __stdcall enumerate_printer_data_extended_a(handle printer,
        const char* key_name,
        byte * enumeration_values,
        unsigned size,
        unsigned* retrieved_size,
        unsigned* value_count);

    export extern "C" unsigned __stdcall enumerate_printer_data_extended_w(handle printer,
        const wchar_t* key_name,
        byte * enumeration_values,
        unsigned size,
        unsigned* retrieved_size,
        unsigned* value_count);

    export template <class character>
        inline unsigned enumerate_printer_data_extended(handle printer,
            const character* key_name,
            byte* enumeration_values,
            unsigned size,
            unsigned* retrieved_size,
            unsigned* value_count)
    {
        if (sizeof(character) == 1)
            return enumerate_printer_data_extended_a(printer,
                (const char*)key_name,
                enumeration_values,
                size,
                retrieved_size,
                value_count);
        else
            return enumerate_printer_data_extended_w(printer,
                (const wchar_t*)key_name,
                enumeration_values,
                size,
                retrieved_size,
                value_count);
    }

    export extern "C" unsigned __stdcall enumerate_printer_key_a(handle printer,
        const char* key_name,
        char* subkey_buffer,
        unsigned size,
        unsigned* transferred);

    export extern "C" unsigned __stdcall enumerate_printer_key_w(handle printer,
        const wchar_t* key_name,
        wchar_t* subkey_buffer,
        unsigned size,
        unsigned* transferred);

    export template <class character>
        inline unsigned enumerate_printer_key(handle printer,
            const character* key_name,
            character* subkey_buffer,
            unsigned size,
            unsigned* transferred)
    {
        if (sizeof(character) == 1)
            return enumerate_printer_key_a(printer,
                (const char*)key_name,
                (char*)subkey_buffer,
                size,
                transferred);
        else
            return enumerate_printer_key_w(printer,
                (const wchar_t*)key_name,
                (wchar_t*)subkey_buffer,
                size,
                transferred);
    }

    export extern "C" handle __stdcall find_first_printer_change_notification(handle printer,
        unsigned flags,
        unsigned options,
        void* pointer);

    export extern "C" bool __stdcall find_next_printer_change_notification(handle change,
        unsigned* flags,
        void* reserved,
        void** notification_information);

    export extern "C" bool __stdcall find_close_printer_change_notification(handle change);

    export extern "C" bool __stdcall free_printer_notify_information(printer_notify_information * notify_information);

    export extern "C" unsigned __stdcall printer_message_box_a(handle printer,
        unsigned error,
        handle window,
        const char* text,
        const char* caption,
        unsigned type);

    export extern "C" unsigned __stdcall printer_message_box_w(handle printer,
        unsigned error,
        handle window,
        const wchar_t* text,
        const wchar_t* caption,
        unsigned type);

    export template <class character>
        inline unsigned printer_message_box(handle printer,
            unsigned error,
            handle window,
            const character* text,
            const character* caption,
            unsigned type)
    {
        if (sizeof(character) == 1)
            return printer_message_box_a(printer,
                error,
                window,
                (const char*)text,
                (const char*)caption,
                type);
        else
            return printer_message_box_w(printer,
                error,
                window,
                (const wchar_t*)text,
                (const wchar_t*)caption,
                type);

    }

    export extern "C" bool __stdcall close_printer(handle printer);

    export extern "C" bool __stdcall add_form_a(handle printer,
        unsigned level,
        byte * form);

    export extern "C" bool __stdcall add_form_w(handle printer,
        unsigned level,
        byte * form);

    export extern "C" inline bool add_form(handle printer,
        unsigned level,
        byte * form)
    {
        return add_form_w(printer,
            level,
            form);
    }

    export extern "C" bool __stdcall delete_form_a(handle printer,
        const char* form_name);

    export extern "C" bool __stdcall delete_form_w(handle printer,
        const wchar_t* form_name);

    export template <class character>
        inline bool delete_form(handle printer,
            const character* form_name)
    {
        if (sizeof(character) == 1)
            return delete_form_a(printer,
                (const char*)form_name);
        else
            return delete_form_w(printer,
                (const wchar_t*)form_name);

    }

    export extern "C" bool __stdcall get_form_a(handle printer,
        const char* form_name,
        unsigned level,
        byte * form,
        unsigned size,
        unsigned* required);

    export extern "C" bool __stdcall get_form_w(handle printer,
        const wchar_t* form_name,
        unsigned level,
        byte * form,
        unsigned size,
        unsigned* required);

    export template <class character>
        inline bool get_form(handle printer,
            const character* form_name,
            unsigned level,
            byte* form,
            unsigned size,
            unsigned* required)
    {
        if (sizeof(character) == 1)
            return get_form_a(printer,
                (const char*)form_name,
                level,
                form,
                size,
                required);
        else
            return get_form_w(printer,
                (const wchar_t*)form_name,
                level,
                form,
                size,
                required);
    }


    export extern "C" bool __stdcall set_form_a(handle printer,
        const char* form_name,
        unsigned level,
        byte * form);

    export extern "C" bool __stdcall set_form_w(handle printer,
        const wchar_t* form_name,
        unsigned level,
        byte * form);

    export template <class character>
        inline bool set_form(handle printer,
            const character* form_name,
            unsigned level,
            byte* form)
    {
        if (sizeof(character) == 1)
            return set_form_a(printer,
                (const char*)form_name,
                level,
                form);
        else
            return set_form_w(printer,
                (const wchar_t*)form_name,
                level,
                form);

    }

    export extern "C" bool __stdcall enumerate_forms_a(handle printer,
        unsigned level,
        byte * form,
        unsigned buffer,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool __stdcall enumerate_forms_w(handle printer,
        unsigned level,
        byte * form,
        unsigned buffer,
        unsigned* required,
        unsigned* returned);

    inline bool enumerate_forms(handle printer,
        unsigned level,
        byte* form,
        unsigned buffer,
        unsigned* required,
        unsigned* returned)
    {
        return enumerate_forms_w(printer,
            level,
            form,
            buffer,
            required,
            returned);
    }

    export extern "C" bool __stdcall enumerate_monitors_a(const char* server,
        unsigned level,
        byte * monitors,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool __stdcall enumerate_monitors_w(const wchar_t* server,
        unsigned level,
        byte * monitors,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export template <class character>
        inline bool enumerate_monitors(const character* server,
            unsigned level,
            byte* monitors,
            unsigned size,
            unsigned* required,
            unsigned* returned)
    {
        if (sizeof(character) == 1)
            return enumerate_monitors_a((const char*)server,
                level,
                monitors,
                size,
                required,
                returned);
        else
            return enumerate_monitors_w((const wchar_t*)server,
                level,
                monitors,
                size,
                required,
                returned);

    }

    export extern "C" bool __stdcall add_monitor_a(const char* server,
        unsigned level,
        byte * monitors);

    export extern "C" bool __stdcall add_monitor_w(const wchar_t* server,
        unsigned level,
        byte * monitors);

    export template <class character>
        inline bool add_monitor(const character* server,
            unsigned level,
            byte* monitors)
    {
        if (sizeof(character) == 1)
            return add_monitor_a((const char*)server,
                level,
                monitors);
        else
            return add_monitor_w((const wchar_t*)server,
                level,
                monitors);
    }

    export extern "C" bool _stdcall delete_monitor_a(const char* server,
        const char* environment,
        const char* monitor_name);

    export extern "C" bool _stdcall delete_monitor_w(const wchar_t* server,
        const wchar_t* environment,
        const wchar_t* monitor_name);

    export template <class character>
        inline bool delete_monitor(const character* server,
            const character* environment,
            const character* monitor_name)
    {
        if (sizeof(character) == 1)
            return delete_monitor_a((const char*)server,
                (const char*)environment,
                (const char*)monitor_name);
        else
            return delete_monitor_w((const wchar_t*)server,
                (const wchar_t*)environment,
                (const wchar_t*)monitor_name);
    }

    export extern "C" bool __stdcall enumerate_ports_a(const char* name,
        unsigned level,
        byte * ports,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export extern "C" bool __stdcall enumerate_ports_w(const wchar_t* name,
        unsigned level,
        byte * ports,
        unsigned size,
        unsigned* required,
        unsigned* returned);

    export template <class character>
        inline bool enumerate_ports(const character* name,
            unsigned level,
            byte* ports,
            unsigned size,
            unsigned* required,
            unsigned* returned)
    {
        if (sizeof(character) == 1)
            return enumerate_ports_a((const char*)name,
                level,
                ports,
                size,
                required,
                returned);
        else
            return enumerate_ports_w((const wchar_t*)name,
                level,
                ports,
                size,
                required,
                returned);
    }


    export extern "C" bool __stdcall add_port_a(const char* name,
        handle window,
        const char* monitor_name);

    export extern "C" bool __stdcall add_port_w(const wchar_t* name,
        handle window,
        const wchar_t* monitorn_name);

    export template <class character>
        inline bool add_port(const character* name,
            handle window,
            const character* monitor_name)
    {
        if (sizeof(character) == 1)
            return add_port_a((const char*)name,
                window,
                (const char*)monitor_name);
        else
            return add_port_w((const wchar_t*)name,
                window,
                (const wchar_t*)monitor_name);

    }

    export extern "C" bool __stdcall configure_port_a(const char* server,
        handle window,
        const char* port_name);

    export extern "C" bool __stdcall configure_port_w(const wchar_t* server,
        handle window,
        const wchar_t* port_name);

    export template <class character>
        inline bool configure_port(const character* server,
            handle window,
            const character* port_name)
    {
        if (sizeof(character) == 1)
            return configure_port_a((const char*)server,
                window,
                (const char*)port_name);
        else
            return configure_port_w((const wchar_t*)server,
                window,
                (const wchar_t*)port_name);
    }

    export extern "C" bool __stdcall delete_port_a(const char* server,
        handle window,
        const char* port_name);

    export extern "C" bool __stdcall delete_port_w(const wchar_t* server,
        handle window,
        const wchar_t* port_name);

    export template <class character>
        inline bool delete_port(const character* server,
            handle window,
            const character* port_name)
    {
        if (sizeof(character) == 1)
            return delete_port_a((const char*)server,
                window,
                (const char*)port_name);
        else
            return delete_port_w((const wchar_t*)server,
                window,
                (const wchar_t*)port_name);


    }

    export extern "C" bool __stdcall add_printer_connection_a(const char* name);

    export extern "C" bool __stdcall add_printer_connection_w(const wchar_t* name);

    export template <class character>
        inline bool add_printer_connection(const character* name)
    {
        if (sizeof(character) == 1)
            return add_printer_connection_a((const char*)name);
        else
            return add_printer_connection_w((const wchar_t*)name);
    }

    export extern "C" bool __stdcall delete_printer_connection_a(const char* name);

    export extern "C" bool __stdcall delete_printer_connection_w(const wchar_t* name);

    export template <class character>
        inline bool delete_printer_connection(const character* name)
    {
        if (sizeof(character) == 1)
            return delete_printer_connection_a((const char*)name);
        else
            return delete_printer_connection_w((const wchar_t*)name);
    }

    export extern "C" handle __stdcall connect_to_printer_dialog(handle window,
        unsigned flags);

    export extern "C" bool __stdcall delete_print_providor_a(const char* server,
        const char* environment,
        const char* name);

    export extern "C" bool __stdcall delete_print_providor_w(const wchar_t* server,
        const wchar_t* environment,
        const wchar_t* name);

    export template <class character>
        inline bool delete_print_providor(const character* server,
            const character* environment,
            const character* name)
    {
        if (sizeof(character) == 1)
            return delete_print_providor_a((const char*)server,
                (const char*)environment,
                (const char*)name);
        else
            return delete_print_providor_w((const wchar_t*)server,
                (const wchar_t*)environment,
                (const wchar_t*)name);

    }

 
    export struct resource_string : public string
    {
        resource_string(unsigned resource,
            handle resource_module = 0)
        {
            handle load_handle = resource_module ? resource_module : get_module_handle<character>();
            character buffer[256];
            load_string(load_handle,
                resource,
                buffer,
                sizeof(buffer));
            unsigned size = string_length(buffer);
            s = (character*)allocate_from_heap(sizeof(character) * (size + 1));
            copy_string(s, buffer);
        }
    };

    time::time(const date& date_copy)
        : hour(0),
        minute(0),
        second(0),
        millisecond(0),
        year(date_copy.get_year()),
        month(date_copy.get_month()),
        day(date_copy.get_day()),
        day_of_week(date_copy.get_day_of_week()) {}

    time::time(unsigned year_set,
        unsigned month_set,
        unsigned day_of_week_set,
        unsigned day_set,
        unsigned hour_set,
        unsigned minute_set,
        unsigned second_set,
        unsigned millisecond_set)
        : year(year_set),
        month(month_set),
        day_of_week(day_of_week_set),
        day(day_set),
        hour(hour_set),
        minute(minute_set),
        second(second_set),
        millisecond(millisecond_set) {}

    time::time()
    {
        system_time get;
        get_local_time(&get);
        year = get.year;
        month = get.month;
        day_of_week = get.day_of_week;
        day = get.day;
        hour = get.hour;
        minute = get.minute;
        second = get.second;
        millisecond = get.millisecond;
    }

 export difference operator-(const time& time_first,
    const time& time_second)
{
    time_compare time_compare_result = (time_first == time_second);

    if (time_compare_result == time_equal)
        return difference();

    else if (time_compare_result == time_less)
        return time_second - time_first;

    else
    {
        difference difference_return;

        time time_a(time_first);
        time time_b(time_second);

        int millisecond_carry = (time_a.millisecond < time_b.millisecond) ? 1 : 0;

        difference_return.millisecond = 1000 * millisecond_carry +
            time_a.millisecond -
            time_b.millisecond;

        int second_carry = ((time_a.second < (time_b.second + millisecond_carry)) ? 1 : 0);

        difference_return.second = 60 * second_carry +
            time_a.second -
            time_b.second -
            millisecond_carry;

        int minute_carry = ((time_a.minute < (time_b.minute + second_carry)) ? 1 : 0);

        difference_return.minute = 60 * minute_carry +
            time_a.minute -
            time_b.minute -
            second_carry;

        int hour_carry = ((time_a.hour < (time_b.hour + minute_carry)) ? 1 : 0);

        difference_return.hour = 24 * hour_carry +
            time_a.hour -
            time_b.hour -
            minute_carry;


        date d = (date)time_first;

        int days_difference = (date)time_first - (date)time_second;

        days_difference -= hour_carry;

        difference_return.day = (unsigned)days_difference;

        return difference_return;
    }
  }
}

using namespace core;

namespace database
{
    struct node
    {
        long long left;
        long long right;
        long long parent;
        long long balance;
        long long key;

        node()
        {
            left = 0;
            right = 0;
            parent = 0;
            balance = core::state::header;
            key = 0;
        }

        node(long long p)
        {
            left = 0;
            right = 0;
            parent = p;
            balance = core::state::balanced;
            key = 0;
        }

        bool is_header() { return balance == core::state::header; }
    };

    export struct file_exception
    {
        string description;

        file_exception(const string& s)
            : description(s) {}
    };

    struct handle_less
    {
        bool operator()(const handle& ha, const handle& hb) const
        {
            return ha < hb;
        }
    };

    export inline string get_last_error_string()
    {
        unsigned error = get_last_error();

        character* messageBuffer = nullptr;

        size_t size = format_message(format_message_flag::allocate_buffer |
            format_message_flag::from_system |
            format_message_flag::ignore_inserts,
            0,
            error,
            make_language(_language::neutral, sublanguage::_default),
            (character*)&messageBuffer,
            0,
            0);

        string message(messageBuffer);

        free_local_memory(messageBuffer);

        return message;
    }

    core::dictionary<void*, long long> file_reference;

    export struct file
    {
        void* hfile;
        string file_name;

        file() : hfile(0), file_name(L"none")
        {
            try
            {
                long long count = file_reference[hfile];
                count++;
                file_reference[hfile] = count;
            }
            catch (entry_not_found_exception)
            {
                file_reference[hfile] = 1;
            }
        }

        file(const string& file_name_set,
            unsigned access,
            unsigned share_nnode,
            const security_attributes* security = 0,
            unsigned disposition = file_action::open_existing,
            unsigned flags_and_attributes = 0,
            handle template_file = 0)
            : file_name(file_name_set)
        {
            hfile = create_file((const wchar_t*)file_name,
                access,
                share_nnode,
                security,
                disposition,
                flags_and_attributes,
                template_file);

            if (hfile == (void*)-1)
            {
                string estring = string(L"error opening file: ") + file_name + string(L" error: ") + get_last_error_string();
                throw file_exception(estring);
            }

            file_reference[hfile] = 1;
        }

        file(const file& p)
        {
            hfile = p.hfile;
            file_name = p.file_name;
            long long count = file_reference[hfile];
            count++;
            file_reference[hfile] = count;
        }

        ~file() { destroy(); }

        file& operator=(const file& p)
        {
            destroy();

            hfile = p.hfile;
            file_name = p.file_name;

            long long count = file_reference[hfile];
            count++;
            file_reference[hfile] = count;
            return *this;
        }

        void destroy()
        {
            long long count = file_reference[hfile];
            count--;
            if (count == 0)
            {
                if (hfile != 0)
                {
                    bool success = close_handle(hfile);

                    if (!success)
                    {
                        string estring = string(L"error closeing handle: ") + file_name + string(L"  error: ") + get_last_error_string();
                        throw file_exception(estring);
                    }
                }
                file_reference >> hfile;
            }
            else
            {
                file_reference[hfile] = count;
            }
        }

        unsigned write(const void* buffer,
            unsigned count)
        {
            unsigned written;

            bool success = write_file(hfile,
                (void*)buffer,
                count,
                &written,
                0);

            if (!success)
            {
                string estring = string(L"error writing to file: ") + file_name + string(L"  error: ") + get_last_error_string();
                throw file_exception(estring);
            }


            return written;
        }

        unsigned read(void* buffer,
            unsigned count) const
        {
            unsigned read;

            bool success = read_file(hfile,
                buffer,
                count,
                &read,
                0);

            if (!success)
            {
                string estring = string(L"error reading file: ") + file_name + string(L"  error: ") + get_last_error_string();
                throw file_exception(estring);
            }

            return read;
        }

        long long size() const
        {
            return get_file_length(hfile);
        }

        void end_of_file()
        {
            bool success = set_end_of_file(hfile);

            if (!success)
            {
                string estring = string(L"error setting end of file: ") + file_name + string(L"  error: ") + get_last_error_string();
                throw file_exception(estring);
            }
        }

        long long set_pointer(long long offset, unsigned method)
        {
            return set_file_ptr(hfile, offset, method);
        }

        void flush()
        {
            bool success = flush_file_buffers(hfile);
            if (!success)
            {
                string estring = string(L"error flushing file: ") + file_name + string(L"  error: ") + get_last_error_string();
                throw file_exception(estring);
            }

        }

    };

    struct heap_entry
    {
        long long address;
        long long size;

        heap_entry(long long slot_size,
            long long slot_address)
        {
            size = slot_size;
            address = slot_address;
        }
    };

    struct node_stack
    {
        file _node_stack;

        node_stack() {}

        node_stack(string name, bool f_create)
        {
            if (f_create)
            {
                _node_stack = file(name,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (const security_attributes*)0,
                    file_action::create_new,
                    file_flag::random_file,
                    (handle)0);
                long long zero = 0;
                _node_stack.set_pointer(0, file_position::at_beginning);
                _node_stack.write(&zero, 8);
            }
            else
                _node_stack = file(name,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (const security_attributes*)0,
                    file_action::open_existing,
                    file_flag::random_file,
                    (handle)0);
        }

        void reset()
        {
            long long count = 0;
            _node_stack.set_pointer(0, file_position::at_beginning);
            _node_stack.write(&count, 8);
            _node_stack.end_of_file();
            _node_stack.flush();
        }

        long long get()
        {
            long long slot_address = 0;
            long long heap_count = 0;
            _node_stack.set_pointer(0, file_position::at_beginning);
            _node_stack.read(&heap_count, 8);
            if (heap_count != 0)
            {
                _node_stack.set_pointer((long long)(8 * heap_count), file_position::at_beginning);
                _node_stack.read(&slot_address, 8);
                _node_stack.set_pointer((long long)(8 * heap_count), file_position::at_beginning);
                _node_stack.end_of_file();
                heap_count--;
                _node_stack.set_pointer(0, file_position::at_beginning);
                _node_stack.write(&heap_count, 8);
                return slot_address;
            }

            return invalid();
        }

        void add(long long slot_address)
        {
            long long heap_count = 0;
            _node_stack.set_pointer(0, file_position::at_beginning);
            _node_stack.read(&heap_count, 8);
            _node_stack.set_pointer((long long)(8 * (1 + heap_count)), file_position::at_beginning);
            _node_stack.write(&slot_address, 8);
            heap_count++;
            _node_stack.set_pointer(0, file_position::at_beginning);
            _node_stack.write(&heap_count, 8);
        }

        long long invalid()
        {
            return -1;
        }

        void check_point()
        {
            _node_stack.flush();
        }
    };

    struct heap_node
    {
        long long left;
        long long right;
        long long parent;
        long long balance;
        long long key;
        long long address;

        heap_node()
        {
            left = 0;
            right = 0;
            parent = 0;
            balance = core::state::header;
            key = 0;
            address = 0;
        }

        heap_node(long long p, long long size, long long address_to_ad)
        {
            left = 0;
            right = 0;
            parent = p;
            balance = core::state::balanced;
            key = size;
            address = address_to_ad;
        }

        bool is_header() { return balance == core::state::header; }
    };

    core::dictionary<file*, long long> heap_references;

    struct heap
    {
        string node_filename;
        string heap_heapname;

        file* node_file;
        node_stack* _node_stack;


        heap(const string& name,
            const string& directory)
        {
            node_filename = directory + string(L"\\") + name + string(L".a");
            heap_heapname = directory + string(L"\\") + name + string(L".b");

            if (!exists())
            {
                _node_stack = new node_stack(heap_heapname, true);

                node_file = new file(node_filename,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (const security_attributes*)0,
                    file_action::create_new,
                    file_flag::random_file,
                    (handle)0);

                reset();
            }
            heap_references[node_file] = 1;
        }

        ~heap()
        {
            long long count = heap_references[node_file];
            count--;
            if (count == 0)
            {
                if (node_file)
                {
                    delete node_file;
                    delete _node_stack;
                }
                heap_references.erase(node_file);
            }
            else
                heap_references[node_file] = count;
        }

        void destroy()
        {
            long long count = heap_references[node_file];
            count--;
            if (count == 0)
            {
                if (node_file)
                {
                    delete node_file;
                    delete _node_stack;
                }
                heap_references >> node_file;
            }
            else
                heap_references[node_file] = count;
        }


        heap(const heap& copee)
            : node_file(copee.node_file),
            _node_stack(copee._node_stack),
            node_filename(copee.node_filename),
            heap_heapname(copee.heap_heapname)
        {
            long long count = heap_references[node_file];
            count++;
            heap_references[node_file] = count;
        }

        heap& operator=(const heap& copee)
        {
            destroy();
            node_file = copee.node_file;
            _node_stack = copee._node_stack;
            node_filename = copee.node_filename;
            heap_heapname = copee.heap_heapname;
            long long count = heap_references[node_file];
            count++;
            heap_references[node_file] = count;
            return *this;
        }

        bool exists()
        {
            try
            {
                node_file = new file(node_filename,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (const security_attributes*)0,
                    file_action::open_existing,
                    file_flag::random_file,
                    (handle)0);
            }
            catch (file_exception)
            {
                return false;
            }

            _node_stack = new node_stack(heap_heapname, false);

            return true;
        }

        void reset()
        {
            node_file->set_pointer(0, file_position::at_beginning);
            node_file->end_of_file();
            add(heap_node());
            _node_stack->reset();
        }

        long long add(heap_node data)
        {
            long long slot_address = _node_stack->get();
            if (slot_address == invalid())
            {
                long long file_size = node_file->size();
                node_file->set_pointer(file_size, file_position::at_beginning);
                node_file->write(&data, sizeof(heap_node));
                return file_size;
            }
            else
            {
                node_file->set_pointer(slot_address, file_position::at_beginning);
                node_file->write(&data, sizeof(heap_node));
                return slot_address;
            }
        }

        void update(long long node_address, heap_node data)
        {
            node_file->set_pointer(node_address, file_position::at_beginning);
            node_file->write(&data, sizeof(heap_node));
        }

        heap_node get(long long node_address)
        {
            heap_node node_get;
            node_file->set_pointer(node_address, file_position::at_beginning);
            node_file->read(&node_get, sizeof(heap_node));
            return node_get;
        }

        void dispose(long long slot_address)
        {
            _node_stack->add(slot_address);
        }

        long long invalid()
        {
            return -1;
        }

        void check_point()
        {
            node_file->flush();
            _node_stack->check_point();
        }
    };

    long long rotate_left(heap& _heap, long long _node)
    {
        heap_node _heap_node = _heap.get(_node);
        long long parent = _heap_node.parent;
        long long x = _heap_node.right;
        heap_node _x = _heap.get(x);
        _heap_node.parent = x;
        _x.parent = parent;
        if (_x.left != 0)
        {
            heap_node x_left = _heap.get(_x.left);
            x_left.parent = _node;
            _heap.update(_x.left, x_left);
        }
        _heap_node.right = _x.left;
        _x.left = _node;
        _heap.update(_node, _heap_node);
        _heap.update(x, _x);
        return x;
    }

    long long rotate_right(heap& _heap, long long _node)
    {
        heap_node _heap_node = _heap.get(_node);
        long long parent = _heap_node.parent;
        long long x = _heap_node.left;
        heap_node _x = _heap.get(x);
        _heap_node.parent = x;
        _x.parent = parent;
        if (_x.right != 0)
        {
            heap_node x_right = _heap.get(_x.right);
            x_right.parent = _node;
            _heap.update(_x.right, x_right);
        }
        _heap_node.left = _x.right;
        _x.right = _node;
        _heap.update(_node, _heap_node);
        _heap.update(x, _x);
        return x;
    }

    long long balance_left(heap& _heap, long long _node)
    {
        long long new_heap_node = 0;

        heap_node _heap_node = _heap.get(_node);

        long long left = _heap_node.left;
        heap_node _left = _heap.get(left);

        switch (_left.balance)
        {
        case core::state::left_high:
            _heap_node.balance = core::state::balanced;
            _left.balance = core::state::balanced;
            _heap.update(_node, _heap_node);
            _heap.update(left, _left);
            new_heap_node = rotate_right(_heap, _node);
            break;

        case core::state::right_high:
        {
            long long sub_right = _left.right;
            heap_node _sub_right = _heap.get(sub_right);

            switch (_sub_right.balance)
            {
            case core::state::balanced:
                _heap_node.balance = core::state::balanced;
                _left.balance = core::state::balanced;
                _heap.update(_node, _heap_node);
                _heap.update(left, _left);
                break;

            case core::state::right_high:
                _heap_node.balance = core::state::balanced;
                _left.balance = core::state::left_high;
                _heap.update(_node, _heap_node);
                _heap.update(left, _left);
                break;

            case core::state::left_high:
                _heap_node.balance = core::state::right_high;
                _left.balance = core::state::balanced;
                _heap.update(_node, _heap_node);
                _heap.update(left, _left);
                break;
            }
            _sub_right.balance = core::state::balanced;
            _heap.update(sub_right, _sub_right);
            _heap_node.left = rotate_left(_heap, left);
            _heap.update(_node, _heap_node);
            new_heap_node = rotate_right(_heap, _node);
        }
        break;

        case core::state::balanced:
            _heap_node.balance = core::state::left_high;
            _left.balance = core::state::right_high;
            _heap.update(_node, _heap_node);
            _heap.update(left, _left);
            new_heap_node = rotate_right(_heap, _node);
            break;
        }

        return new_heap_node;
    }

    long long balance_right(heap& _heap, long long _node)
    {
        long long new_heap_node = 0;

        heap_node _heap_node = _heap.get(_node);

        long long right = _heap_node.right;
        heap_node _right = _heap.get(right);

        switch (_right.balance)
        {
        case core::state::right_high:
            _heap_node.balance = core::state::balanced;
            _right.balance = core::state::balanced;
            _heap.update(_node, _heap_node);
            _heap.update(right, _right);
            new_heap_node = rotate_left(_heap, _node);
            break;

        case core::state::left_high:
        {
            long long sub_left = _right.left;
            heap_node _sub_left = _heap.get(sub_left);

            switch (_sub_left.balance)
            {
            case core::state::balanced:
                _heap_node.balance = core::state::balanced;
                _right.balance = core::state::balanced;
                _heap.update(_node, _heap_node);
                _heap.update(right, _right);
                break;

            case core::state::left_high:
                _heap_node.balance = core::state::balanced;
                _right.balance = core::state::right_high;
                _heap.update(_node, _heap_node);
                _heap.update(right, _right);
                break;

            case core::state::right_high:
                _heap_node.balance = core::state::left_high;
                _right.balance = core::state::balanced;
                _heap.update(_node, _heap_node);
                _heap.update(right, _right);
                break;
            }
            _sub_left.balance = core::state::balanced;
            _heap.update(sub_left, _sub_left);
            _heap_node.right = rotate_right(_heap, right);
            _heap.update(_node, _heap_node);
            new_heap_node = rotate_left(_heap, _node);
        }
        break;

        case core::state::balanced:
            _heap_node.balance = core::state::right_high;
            _right.balance = core::state::left_high;
            _heap.update(_node, _heap_node);
            _heap.update(right, _right);
            new_heap_node = rotate_left(_heap, _node);
            break;
        }

        return new_heap_node;
    }

    void balance_tree(heap& _heap, long long _node, long long from)
    {
        bool taller = true;

        while (taller)
        {
            heap_node _heap_node = _heap.get(_node);

            long long parent = _heap_node.parent;
            heap_node _parent = _heap.get(parent);

            long long next_from = (_parent.left == _node) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (_heap_node.balance)
                {
                case core::state::left_high:
                    if (_parent.is_header())
                        _parent.parent = balance_left(_heap, _node);
                    else if (_parent.left == _node)
                        _parent.left = balance_left(_heap, _node);
                    else
                        _parent.right = balance_left(_heap, _node);
                    _heap.update(parent, _parent);
                    taller = false;
                    break;

                case core::state::balanced:
                    _heap_node.balance = core::state::left_high;
                    _heap.update(_node, _heap_node);
                    taller = true;
                    break;

                case core::state::right_high:
                    _heap_node.balance = core::state::balanced;
                    _heap.update(_node, _heap_node);
                    taller = false;
                    break;
                }
            }
            else
            {
                switch (_heap_node.balance)
                {
                case core::state::left_high:
                    _heap_node.balance = core::state::balanced;
                    _heap.update(_node, _heap_node);
                    taller = false;
                    break;

                case core::state::balanced:
                    _heap_node.balance = core::state::right_high;
                    _heap.update(_node, _heap_node);
                    taller = true;
                    break;

                case core::state::right_high:
                    if (_parent.is_header())
                        _parent.parent = balance_right(_heap, _node);
                    else if (_parent.left == _node)
                        _parent.left = balance_right(_heap, _node);
                    else
                        _parent.right = balance_right(_heap, _node);
                    _heap.update(parent, _parent);
                    taller = false;
                    break;
                }
            }

            if (taller) // skip up a level
            {
                if (_parent.is_header())
                    return;
                else
                {
                    _node = parent;
                    from = next_from;
                }
            }
        }
    }

    void balance_tree_remove(heap& _heap, long long _node, long long from)
    {
        bool shorter = true;

        while (shorter)
        {
            heap_node _heap_node = _heap.get(_node);

            long long parent = _heap_node.parent;
            heap_node _parent = _heap.get(parent);

            long long next_from = (_parent.left == _node) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (_heap_node.balance)
                {
                case core::state::left_high:
                    _heap_node.balance = core::state::balanced;
                    _heap.update(_node, _heap_node);
                    shorter = true;
                    break;

                case core::state::balanced:
                    _heap_node.balance = core::state::right_high;
                    _heap.update(_node, _heap_node);
                    shorter = false;
                    break;

                case core::state::right_high:
                {
                    heap_node right = _heap.get(_heap_node.right);

                    if (right.balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;

                    if (_parent.is_header())
                        _parent.parent = balance_right(_heap, _node);
                    else if (_parent.left == _node)
                        _parent.left = balance_right(_heap, _node);
                    else
                        _parent.right = balance_right(_heap, _node);

                    _heap.update(parent, _parent);
                }
                break;
                }
            }
            else
            {
                switch (_heap_node.balance)
                {
                case core::state::right_high:
                    _heap_node.balance = core::state::balanced;
                    _heap.update(_node, _heap_node);
                    shorter = true;
                    break;

                case core::state::balanced:
                    _heap_node.balance = core::state::left_high;
                    _heap.update(_node, _heap_node);
                    shorter = false;
                    break;

                case core::state::left_high:
                {
                    heap_node left = _heap.get(_heap_node.left);

                    if (left.balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;

                    if (_parent.is_header())
                        _parent.parent = balance_left(_heap, _node);
                    else if (_parent.left == _node)
                        _parent.left = balance_left(_heap, _node);
                    else
                        _parent.right = balance_left(_heap, _node);

                    _heap.update(parent, _parent);
                }
                break;
                }
            }

            if (shorter)
            {
                if (_parent.is_header())
                    return;
                else
                {
                    from = next_from;
                    _node = parent;
                }
            }
        }
    }

    void swap_long(long long* phurst, long long* second)
    {
        long long temporary = *phurst; *phurst = *second; *second = temporary;
    }

    void swap_heap_nodes(heap& heap, long long a, long long b)
    {
        heap_node _a = heap.get(a);
        heap_node _b = heap.get(b);
        swap_long(&_a.key, &_b.key);
        swap_long(&_a.address, &_b.address);
        heap.update(a, _a);
        heap.update(b, _b);
    }

    long long previous_slot(heap& heap, long long slot)
    {
        heap_node _slot = heap.get(slot);

        if (slot == 0)
            return _slot.right;
        else
        {
            if (_slot.left != 0)
            {
                slot = _slot.left;
                _slot = heap.get(slot);

                while (_slot.right != 0)
                {
                    slot = _slot.right;
                    _slot = heap.get(slot);
                }
            }
            else
            {
                long long y = _slot.parent;

                if (y == 0)
                    return 0;
                else
                {
                    heap_node _y = heap.get(y);

                    while (slot == _y.left)
                    {
                        slot = y;
                        y = _y.parent;
                        if (y == 0) break;
                        _y = heap.get(y);
                    }

                    slot = y;
                }
            }

            return slot;
        }
    }

    long long next_slot(heap heap, long long slot)
    {
        heap_node _slot = heap.get(slot);

        if (slot == 0)
            return _slot.left;
        else
        {
            if (_slot.right != 0)
            {
                slot = _slot.right;
                _slot = heap.get(slot);

                while (_slot.left != 0)
                {
                    slot = _slot.left;
                    _slot = heap.get(slot);
                }
            }
            else
            {
                long long y = _slot.parent;

                if (y == 0)
                    return y;
                else
                {
                    heap_node _y = heap.get(y);

                    while (slot == _y.right)
                    {
                        slot = y;
                        y = _y.parent;
                        if (y == 0) break;
                        _y = heap.get(y);
                    }

                    slot = y;
                }
            }

            return slot;
        }
    }

    core::dictionary<heap*, long long> heap_reference_counter;

    struct heap_multiset
    {
        heap_node header;
        heap* _heap;


        heap_multiset(string name,
            string directory)
        {
            _heap = new heap(name, directory);
            heap_reference_counter[_heap] = 1;
        }

        heap_multiset(const heap_multiset& hb)
            : header(hb.header),
            _heap(hb._heap)
        {
            long long count = heap_reference_counter[_heap];
            count++;
            heap_reference_counter[_heap] = count;
        }

        ~heap_multiset()
        {
            long long count = heap_reference_counter[_heap];
            count--;
            if (count == 0)
            {
                if (_heap) delete _heap;
                heap_reference_counter.erase(_heap);
            }
            else
                heap_reference_counter[_heap] = count;
        }

        void destroy()
        {
            long long count = heap_reference_counter[_heap];
            count--;
            if (count == 0)
            {
                delete _heap;
                heap_reference_counter.erase(_heap);
            }
            else
                heap_reference_counter[_heap] = count;
        }

        heap_multiset& operator=(const heap_multiset& hb)
        {
            destroy();

            header = hb.header;
            _heap = hb._heap;

            try
            {
                long long count = heap_reference_counter[_heap];
                count++;
                heap_reference_counter[_heap] = count;
            }
            catch (...)
            {
                heap_reference_counter[_heap] = 1;
            }
            return *this;
        }

        void check_point()
        {
            _heap->check_point();
        }

        void reset()
        {
            _heap->reset();
        }

        long long get(long long size)
        {
            get_header();

            if (header.parent == 0)
                throw entry_not_found_exception();

            else
            {
                long long search = header.parent;

                heap_node _search = _heap->get(search);

                do
                {

                    if (size < _search.key)
                    {
                        search = _search.left;
                        if (search != 0) _search = _heap->get(search);
                    }

                    else if (size > _search.key)
                    {
                        search = _search.right;
                        if (search != 0) _search = _heap->get(search);
                    }

                    else break;

                } while (search != 0);

                if (search == 0)
                    throw entry_not_found_exception();
                else
                {
                    long long l_return = _search.address;
                    remove(search);
                    return l_return;
                }

            }
        }

        void add(long long l_size, long long l_address)
        {
            get_header();

            long long node = header.parent;

            if (node == 0)
            {
                header.parent = _heap->add(heap_node(0, l_size, l_address));
                header.left = header.parent;
                header.right = header.parent;
                put_header();
            }
            else
            {
                for (; ; )
                {
                    heap_node _node = _heap->get(node);

                    if (l_size < _node.key)
                    {
                        if (_node.left != 0)
                            node = _node.left;
                        else
                        {
                            long long new_node = _heap->add(heap_node(node, l_size, l_address));
                            _node.left = new_node;
                            _heap->update(node, _node);
                            if (header.left == node)
                            {
                                header.left = new_node;
                                put_header();
                            }
                            balance_tree(*_heap, node, direction::from_left);
                            return;
                        }
                    }

                    else
                    {
                        if (_node.right != 0)
                            node = _node.right;
                        else
                        {
                            long long new_node = _heap->add(heap_node(node, l_size, l_address));
                            _node.right = new_node;
                            _heap->update(node, _node);
                            if (header.right == node)
                            {
                                header.right = new_node;
                                put_header();
                            }
                            balance_tree(*_heap, node, direction::from_right);
                            return;
                        }
                    }
                }
            }
        }

        void get_header()
        {
            header = _heap->get(0);
        }

        void put_header()
        {
            _heap->update(0, header);
        }

        void remove(long long node_in)
        {
            long long node = node_in;

            heap_node _node = _heap->get(node);

            if (_node.left != 0 && _node.right != 0)
            {
                long long replace = _node.left;
                heap_node _replace = _heap->get(replace);

                while (_replace.right != 0)
                {
                    replace = _replace.right;
                    _replace = _heap->get(replace);
                }

                swap_heap_nodes(*_heap, node, replace);

                node = replace;
                _node = _heap->get(node);
            }

            long long parent = _node.parent;
            heap_node _parent = _heap->get(parent);

            long long from = (_parent.left == node) ? direction::from_left : direction::from_right;

            if (header.left == node)
            {
                long long n = next_slot(*_heap, node);

                if (n == 0)
                {
                    header.left = 0;
                    header.right = 0;
                }
                else
                    header.left = n;

                put_header();
            }
            else if (header.right == node)
            {
                long long p = previous_slot(*_heap, node);

                if (p == 0)
                {
                    header.left = 0;
                    header.right = 0;
                }
                else
                    header.right = p;

                put_header();
            }

            if (_node.left == 0)
            {
                if (parent == 0)
                {
                    header.parent = _node.right;
                    put_header();
                }
                else if (_parent.left == node)
                {
                    _parent.left = _node.right;
                    _heap->update(parent, _parent);
                }
                else
                {
                    _parent.right = _node.right;
                    _heap->update(parent, _parent);
                }

                if (_node.right != 0)
                {
                    heap_node right = _heap->get(_node.right);
                    right.parent = parent;
                    _heap->update(_node.right, right);
                }
            }
            else
            {
                if (parent == 0)
                {
                    header.parent = _node.left;
                    put_header();
                }
                else if (_parent.left == node)
                {
                    _parent.left = _node.left;
                    _heap->update(parent, _parent);
                }
                else
                {
                    _parent.right = _node.left;
                    _heap->update(parent, _parent);
                }

                if (_node.left != 0)
                {
                    heap_node left = _heap->get(_node.left);
                    left.parent = parent;
                    _heap->update(_node.left, left);
                }
            }

            if (parent != 0) balance_tree_remove(*_heap, parent, from);
            _heap->dispose(node);
        }
    };

    struct node_plus_address
    {
        long long address;
        node _node;

        node_plus_address() {}

        node_plus_address(long long l_address, const node& n_node) : _node(n_node), address(l_address) {}
    };

    struct log_file
    {
        file _log_file;
        file* _node_file;
        bool back_out;

        log_file(const string& name,
            file* node_file_set)
        {
            _node_file = node_file_set;

            _log_file = file(name,
                access_type::generic_read | access_type::generic_write,
                share_file::write | share_file::read,
                (const security_attributes*)0,
                file_action::always_open,
                file_flag::random_file | file_flag::write_through_file,
                (void*)0);

            recover();
        }

        bool recovered() { return back_out; }

        void write(long long address, const node& node)
        {
            node_plus_address to_right(address, node);
            long long file_size = _log_file.size();
            _log_file.set_pointer(file_size, (unsigned)file_position::at_beginning);
            _log_file.write((void*)&to_right, sizeof(node_plus_address));
        }

        void reset()
        {
            _log_file.set_pointer(0, (unsigned)file_position::at_beginning);
            _log_file.end_of_file();
        }

        void recover()
        {
            long long file_size = _log_file.size();

            if (file_size != 0)
            {
                back_out = true;

                long long l_record_offset = file_size - sizeof(node_plus_address);

                while (l_record_offset > 0)
                {
                    node_plus_address to_read;
                    _log_file.set_pointer(l_record_offset, (unsigned)file_position::at_beginning);
                    _log_file.read(&to_read, sizeof(node_plus_address));
                    _node_file->set_pointer(to_read.address, file_position::at_beginning);
                    _node_file->write((void*)&to_read._node, sizeof(node));
                    l_record_offset -= sizeof(node_plus_address);
                }

                _node_file->flush();
                reset();
            }
            else back_out = false;

        }
    };

    export class iplusplus_data_environment_variable_not_set_exception {};

    struct node_file
    {
        string node_filename;
        string node_stack_filename;
        string log_filename;

        file _node_file;
        node_stack* _node_stack;
        log_file* _log_file;

        node_file(string name)
        {
            string string_iplusplus;

            character buffer[1024];
            unsigned read = get_environment_variable(L"db", buffer, 1024);
            if (read == 0) throw iplusplus_data_environment_variable_not_set_exception();
            string_iplusplus = string(buffer);

            node_filename = string_iplusplus + L"\\" + name + L".n";
            node_stack_filename = string_iplusplus + L"\\" + name + L".m";
            log_filename = string_iplusplus + L"\\" + name + L".l";

            if (!contains())
            {
                _node_stack = new node_stack(node_stack_filename, true);

                _node_file = file(node_filename,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (security_attributes*)0,
                    file_action::create_new,
                    file_flag::random_file,
                    (handle)0);

                _log_file = new log_file(log_filename, &_node_file);
                reset();
                long long slot_count = 0;
                _node_stack->_node_stack.write(&slot_count, 8);
            }
            else
                _log_file = new log_file(log_filename, &_node_file);
        }

        node_file(string name,
            string directory)
        {
            node_filename = directory + string(L"\\") + name + L".n";
            node_stack_filename = directory + string(L"\\") + name + L".m";
            log_filename = directory + L"\\" + name + L".l";

            if (!contains())
            {
                _node_stack = new node_stack(node_stack_filename, true);

                _node_file = file(node_filename,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (security_attributes*)0,
                    file_action::create_new,
                    file_flag::random_file,
                    (handle)0);

                _log_file = new log_file(log_filename, &_node_file);
                reset();
                long long slot_count = 0;
                _node_stack->_node_stack.write(&slot_count, 8);
            }
            else
                _log_file = new log_file(log_filename, &_node_file);
        }

        ~node_file() { delete _node_stack; delete _log_file; }

        void reset()
        {
            _node_file.set_pointer(0, file_position::at_beginning);
            _node_file.end_of_file();
            add(node());
            _node_stack->reset();
            _log_file->reset();
        }

        long long add(node data)
        {
            long long slot_address = _node_stack->get();
            if (slot_address == invalid())
            {
                long long file_size = _node_file.size();
                _log_file->write(file_size, data);
                _node_file.set_pointer(file_size, file_position::at_beginning);
                _node_file.write(&data, sizeof(node));
                return file_size;
            }
            else
            {
                _node_file.set_pointer(slot_address, file_position::at_beginning);
                _log_file->write(slot_address, data);
                _node_file.write(&data, sizeof(node));
                return slot_address;
            }
        }

        void update(long long node_address, node data)
        {
            _node_file.set_pointer(node_address, file_position::at_beginning);
            _node_file.write(&data, sizeof(node));
        }

        node get(long long node_address)
        {
            node node_get;
            _node_file.set_pointer(node_address, file_position::at_beginning);
            _node_file.read(&node_get, sizeof(node));
            return node_get;
        }

        void dispose(long long slot_address)
        {
            _node_stack->add(slot_address);
        }

        bool contains()
        {
            try
            {
                _node_file = file(node_filename,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (const security_attributes*)0,
                    file_action::open_existing,
                    file_flag::random_file,
                    (handle)0);
            }
            catch (file_exception fe)
            {
                return false;
            }

            _node_stack = new node_stack(node_stack_filename, false);

            return true;
        }

        long long invalid()
        {
            return -1;
        }

        void check_point()
        {
            _node_file.flush();
            _log_file->reset();
        }
    };

    inline long long rotate_left(node_file& np, long long __node)
    {
        node _node = np.get(__node);
        long long parent = _node.parent;
        long long x = _node.right;
        node _x = np.get(x);
        _node.parent = x;
        _x.parent = parent;
        if (_x.left != 0)
        {
            node x_left = np.get(_x.left);
            x_left.parent = __node;
            np.update(_x.left, x_left);
        }
        _node.right = _x.left;
        _x.left = __node;
        np.update(__node, _node);
        np.update(x, _x);
        return x;
    }

    inline long long rotate_right(node_file& np, long long __node)
    {
        node _node = np.get(__node);
        long long parent = _node.parent;
        long long x = _node.left;
        node _x = np.get(x);
        _node.parent = x;
        _x.parent = parent;
        if (_x.right != 0)
        {
            node x_right = np.get(_x.right);
            x_right.parent = __node;
            np.update(_x.right, x_right);
        }
        _node.left = _x.right;
        _x.right = __node;
        np.update(__node, _node);
        np.update(x, _x);
        return x;
    }

    inline long long balance_left(node_file& np, long long __node)
    {
        long long new_node = 0;

        node _node = np.get(__node);

        long long left = _node.left;
        node _left = np.get(left);

        switch (_left.balance)
        {
        case core::state::left_high:
            _node.balance = core::state::balanced;
            _left.balance = core::state::balanced;
            np.update(__node, _node);
            np.update(left, _left);
            new_node = rotate_right(np, __node);
            break;

        case core::state::right_high:
        {
            long long sub_right = _left.right;
            node _sub_right = np.get(sub_right);

            switch (_sub_right.balance)
            {
            case core::state::balanced:
                _node.balance = core::state::balanced;
                _left.balance = core::state::balanced;
                np.update(__node, _node);
                np.update(left, _left);
                break;

            case core::state::right_high:
                _node.balance = core::state::balanced;
                _left.balance = core::state::left_high;
                np.update(__node, _node);
                np.update(left, _left);
                break;

            case core::state::left_high:
                _node.balance = core::state::right_high;
                _left.balance = core::state::balanced;
                np.update(__node, _node);
                np.update(left, _left);
                break;
            }
            _sub_right.balance = core::state::balanced;
            np.update(sub_right, _sub_right);
            _node.left = rotate_left(np, left);
            np.update(__node, _node);
            new_node = rotate_right(np, __node);
        }
        break;

        case core::state::balanced:
            _node.balance = core::state::left_high;
            _left.balance = core::state::right_high;
            np.update(__node, _node);
            np.update(left, _left);
            new_node = rotate_right(np, __node);
            break;
        }

        return new_node;
    }

    inline long long balance_right(node_file& np, long long __node)
    {
        long long new_node = 0;

        node _node = np.get(__node);

        long long right = _node.right;
        node _right = np.get(right);

        switch (_right.balance)
        {
        case core::state::right_high:
            _node.balance = core::state::balanced;
            _right.balance = core::state::balanced;
            np.update(__node, _node);
            np.update(right, _right);
            new_node = rotate_left(np, __node);
            break;

        case core::state::left_high:
        {
            long long sub_left = _right.left;
            node _sub_left = np.get(sub_left);

            switch (_sub_left.balance)
            {
            case core::state::balanced:
                _node.balance = core::state::balanced;
                _right.balance = core::state::balanced;
                np.update(__node, _node);
                np.update(right, _right);
                break;

            case core::state::left_high:
                _node.balance = core::state::balanced;
                _right.balance = core::state::right_high;
                np.update(__node, _node);
                np.update(right, _right);
                break;

            case core::state::right_high:
                _node.balance = core::state::left_high;
                _right.balance = core::state::balanced;
                np.update(__node, _node);
                np.update(right, _right);
                break;
            }
            _sub_left.balance = core::state::balanced;
            np.update(sub_left, _sub_left);
            _node.right = rotate_right(np, right);
            np.update(__node, _node);
            new_node = rotate_left(np, __node);
        }
        break;

        case core::state::balanced:
            _node.balance = core::state::right_high;
            _right.balance = core::state::left_high;
            np.update(__node, _node);
            np.update(right, _right);
            new_node = rotate_left(np, __node);
            break;
        }


        return new_node;
    }

    inline void balance_tree(node_file& np, long long __node, long long from)
    {
        bool taller = true;

        while (taller)
        {
            node _node = np.get(__node);

            long long parent = _node.parent;
            node _parent = np.get(parent);

            long long next_from = (_parent.left == __node) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (_node.balance)
                {
                case core::state::left_high:
                    if (_parent.is_header())
                        _parent.parent = balance_left(np, __node);
                    else if (_parent.left == __node)
                        _parent.left = balance_left(np, __node);
                    else
                        _parent.right = balance_left(np, __node);
                    np.update(parent, _parent);
                    taller = false;
                    break;

                case core::state::balanced:
                    _node.balance = core::state::left_high;
                    np.update(__node, _node);
                    taller = true;
                    break;

                case core::state::right_high:
                    _node.balance = core::state::balanced;
                    np.update(__node, _node);
                    taller = false;
                    break;
                }
            }
            else
            {
                switch (_node.balance)
                {
                case core::state::left_high:
                    _node.balance = core::state::balanced;
                    np.update(__node, _node);
                    taller = false;
                    break;

                case core::state::balanced:
                    _node.balance = core::state::right_high;
                    np.update(__node, _node);
                    taller = true;
                    break;

                case core::state::right_high:
                    if (_parent.is_header())
                        _parent.parent = balance_right(np, __node);
                    else if (_parent.left == __node)
                        _parent.left = balance_right(np, __node);
                    else
                        _parent.right = balance_right(np, __node);
                    np.update(parent, _parent);
                    taller = false;
                    break;
                }
            }

            if (taller) // skip up a level
            {
                if (_parent.is_header())
                    return;
                else
                {
                    __node = parent;
                    from = next_from;
                }
            }
        }
    }

    inline void balance_tree_remove(node_file& np, long long __node, long long from)
    {
        //if (node == 0) return;

        bool shorter = true;

        while (shorter)
        {
            node _node = np.get(__node);

            long long parent = _node.parent;
            node _parent = np.get(parent);

            long long next_from = (_parent.left == __node) ? direction::from_left : direction::from_right;

            if (from == direction::from_left)
            {
                switch (_node.balance)
                {
                case core::state::left_high:
                    _node.balance = core::state::balanced;
                    np.update(__node, _node);
                    shorter = true;
                    break;

                case core::state::balanced:
                    _node.balance = core::state::right_high;
                    np.update(__node, _node);
                    shorter = false;
                    break;

                case core::state::right_high:
                {
                    node right = np.get(_node.right);

                    if (right.balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;

                    if (_parent.is_header())
                        _parent.parent = balance_right(np, __node);
                    else if (_parent.left == __node)
                        _parent.left = balance_right(np, __node);
                    else
                        _parent.right = balance_right(np, __node);

                    np.update(parent, _parent);
                }
                break;
                }
            }
            else
            {
                switch (_node.balance)
                {
                case core::state::right_high:
                    _node.balance = core::state::balanced;
                    np.update(__node, _node);
                    shorter = true;
                    break;

                case core::state::balanced:
                    _node.balance = core::state::left_high;
                    np.update(__node, _node);
                    shorter = false;
                    break;

                case core::state::left_high:
                {
                    node left = np.get(_node.left);

                    if (left.balance == core::state::balanced)
                        shorter = false;
                    else
                        shorter = true;

                    if (_parent.is_header())
                        _parent.parent = balance_left(np, __node);
                    else if (_parent.left == __node)
                        _parent.left = balance_left(np, __node);
                    else
                        _parent.right = balance_left(np, __node);

                    np.update(parent, _parent);
                }
                break;
                }
            }

            if (shorter)
            {
                if (_parent.is_header())
                    return;
                else
                {
                    from = next_from;
                    __node = parent;
                }
            }
        }
    }

    inline long long previous_slot(node_file& np, long long slot)
    {
        node _slot = np.get(slot);

        if (slot == 0)
            return _slot.right;
        else
        {
            if (_slot.left != 0)
            {
                slot = _slot.left;
                _slot = np.get(slot);

                while (_slot.right != 0)
                {
                    slot = _slot.right;
                    _slot = np.get(slot);
                }
            }
            else
            {
                long long y = _slot.parent;

                if (y == 0)
                    return 0;
                else
                {
                    node _y = np.get(y);

                    while (slot == _y.left)
                    {
                        slot = y;
                        y = _y.parent;
                        if (y == 0) break;
                        _y = np.get(y);
                    }

                    slot = y;
                }
            }

            return slot;
        }
    }

    inline long long next_slot(node_file& np, long long slot)
    {
        node _slot = np.get(slot);

        if (slot == 0)
            return _slot.left;
        else
        {
            if (_slot.right != 0)
            {
                slot = _slot.right;
                _slot = np.get(slot);

                while (_slot.left != 0)
                {
                    slot = _slot.left;
                    _slot = np.get(slot);
                }
            }
            else
            {
                long long y = _slot.parent;

                if (y == 0)
                    return y;
                else
                {
                    node _y = np.get(y);

                    while (slot == _y.right)
                    {
                        slot = y;
                        y = _y.parent;
                        if (y == 0) break;
                        _y = np.get(y);
                    }

                    slot = y;
                }
            }

            return slot;
        }
    }

    inline void swap_nodes(node_file& np, long long a, long long b)
    {
        node _a = np.get(a);
        node _b = np.get(b);
        swap_long(&_a.key, &_b.key);
        np.update(a, _a);
        np.update(b, _b);
    }

    inline long long depth(node_file& np, long long __node)
    {
        if (__node != 0)
        {
            node n = np.get(__node);
            long long left = n.left != 0 ? depth(np, n.left) : 0;
            long long right = n.right != 0 ? depth(np, n.right) : 0;
            return left < right ? right + 1 : left + 1;
        }
        else
            return 0;
    }

    inline long long count(node_file& np, long long __node)
    {
        if (__node != 0)
        {
            node n = np.get(__node);
            long long left = n.left != 0 ? count(np, n.left) : 0;
            long long right = n.right != 0 ? count(np, n.right) : 0;
            return left + right + 1;
        }
        else
            return 0;
    }

    template <class t>
    struct slot_file
    {
        string slot_file_name;
        string heap_file_name;
        file slot_file_instance;
        heap_multiset* heap_file_instance;
        string directory;
        string name;

        void check_point()
        {
            heap_file_instance->check_point();
        }

        slot_file(const string& name_set)
        {
            name = name_set;
            string iplusplus_string;

            character buffer[4096];
            unsigned length = get_environment_variable(L"db", buffer, 4096);
            if (length == 0) throw new iplusplus_data_environment_variable_not_set_exception();

            iplusplus_string = string(buffer);

            directory = iplusplus_string;

            slot_file_name = directory + L"\\" + name + L".s";
            heap_file_name = directory + L"\\" + name + L".h";


            if (!exists())
            {
                heap_file_instance = new heap_multiset(name, directory);

                slot_file_instance = file(slot_file_name,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (security_attributes*)0,
                    file_action::create_new,
                    file_flag::random_file | file_flag::write_through_file,
                    (handle)0);
            }
        }

        slot_file(const string& name_set,
            const string& directory_set)
        {
            name = name_set;
            directory = directory_set;

            slot_file_name = directory + L"\\" + name + L".s";
            heap_file_name = directory + L"\\" + name + L".h";

            if (!exists())
            {

                heap_file_instance = new heap_multiset(name, directory);

                slot_file_instance = file(slot_file_name,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (security_attributes*)0,
                    file_action::create_new,
                    file_flag::random_file | file_flag::write_through_file,
                    (handle)0);
            }
        }

        ~slot_file() { delete heap_file_instance; }

        bool exists()
        {

            try
            {
                slot_file_instance = file(slot_file_name,
                    access_type::generic_read | access_type::generic_write,
                    share_file::write | share_file::read,
                    (security_attributes*)0,
                    file_action::open_existing,
                    file_flag::random_file | file_flag::write_through_file,
                    (handle)0);
            }
            catch (file_exception)
            {
                return false;
            }

            heap_file_instance = new heap_multiset(name, directory);

            return true;
        }

        void reset()
        {
            heap_file_instance->reset();
            slot_file_instance.set_pointer(0, file_position::at_beginning);
            slot_file_instance.end_of_file();
        }

        long long add(t data)
        {
            oarchive oa;
            oa << data;
            void* p = oa.allocate();
            long long added = add(p);
            oa.free(p);
            return added;
        }

        long long size(long long slot_address)
        {
            long long slot_size = 0;
            slot_file_instance.set_pointer(slot_address, file_position::at_beginning);
            slot_file_instance.read(&slot_size, 8);
            return slot_size;
        }

        long long add(void* buffer)
        {
            long long data_size = ((long long*)buffer)[0];
            try
            {
                long long slot_address = heap_file_instance->get(data_size);
                slot_file_instance.set_pointer(slot_address, file_position::at_beginning);
                slot_file_instance.write(buffer, data_size);
                return slot_address;
            }
            catch (entry_not_found_exception)
            {
                long long file_size = slot_file_instance.size();
                slot_file_instance.set_pointer(file_size, file_position::at_beginning);
                slot_file_instance.write(buffer, data_size);
                return file_size;
            }
        }

        t get(long long slot_address)
        {
            long long slot_size;
            slot_file_instance.set_pointer(slot_address, file_position::at_beginning);
            slot_file_instance.read(&slot_size, 8);
            char* buffer = new char[slot_size];
            slot_file_instance.set_pointer(slot_address, file_position::at_beginning);
            slot_file_instance.read(buffer, slot_size);
            iarchive ia(buffer);
            t _out;
            ia >> _out;
            delete[] buffer;
            return _out;
        }

        void dispose(long long slot_address)
        {
            heap_file_instance->add(size(slot_address), slot_address);
        }

        long long invalid()
        {
            return -1;
        }
    };

    core::dictionary<node_file*, long long> data_reference_count;

    template <class t>
    struct data_file
    {
        slot_file<t>* _slot_file;
        node_file* _node_file;

        data_file()
        {
            _slot_file = 0;
            _node_file = 0;
            try
            {
                long long count = data_reference_count[_node_file];
                count++;
                data_reference_count[_node_file] = count;
            }
            catch (...)
            {
                data_reference_count[_node_file] = 1;
            }
        }

        data_file(const string& name)
        {
            _slot_file = new slot_file<t>(name);
            _node_file = new node_file(name);

            if (_node_file->_log_file->recovered())
            {
                _slot_file->heap_file_instance->reset();
                _node_file->_node_stack->reset();
            }

            data_reference_count[_node_file] = 1;
        }

        data_file(const string& name,
            const string& directory)
        {
            _slot_file = new slot_file<t>(name, directory);
            _node_file = new node_file(name, directory);

            if (_node_file->_log_file->recovered())
            {
                _slot_file->heap_file_instance->rReset();
                _node_file->_node_stack->reset();
            }

            data_reference_count[_node_file] = 1;
        }

        ~data_file()
        {
            long long count = data_reference_count[_node_file];
            count--;
            if (count == 0)
            {
                if (_node_file)
                {
                    delete _slot_file;
                    delete _node_file;
                }
                data_reference_count.erase(_node_file);
            }
            else
                data_reference_count[_node_file] = count;
        }

        data_file(const data_file& dp)
            : _slot_file(dp._slot_file),
            _node_file(dp._node_file)
        {
            long long count = data_reference_count[_node_file];
            count++;
            data_reference_count[_node_file] = count;
        }

        data_file& operator=(const data_file& dp)
        {
            data_file::~data_file();
            _slot_file = dp._slot_file;
            _node_file = dp._node_file;
            try
            {
                long long count = data_reference_count[_node_file];
                count++;
                data_reference_count[_node_file] = count;
            }
            catch (...)
            {
                data_reference_count[_node_file] = 1;
            }
            return *this;
        }

        long long add(long long parent, t data)
        {
            node n(parent);
            n.key = _slot_file->add(data);
            long long new_node = _node_file->add(n);
            return new_node;
        }

        void update(long long previous, t data)
        {
            node n = _node_file->get(previous);
            long long old_key = n.key;
            n.key = _slot_file->add(data);
            _node_file->update(previous, n);
            _slot_file->dispose(old_key);
        }

        t get(long long address)
        {
            node n = _node_file->get(address);
            return _slot_file->get(n.key);
        }

        void reset()
        {
            _slot_file->reset();
            _node_file->reset();
        }

        void check_point()
        {
            _slot_file->check_point();
            _node_file->check_point();
        }

        void recover()
        {
            _node_file->_log_file->recover();
            if (_node_file->_log_file->recovered())
            {
                _slot_file->heap_file_instance->reset();
                _node_file->_node_stack->reset();
            }
        }
    };

    core::dictionary<handle, long long> lock_reference;

    struct lock
    {
        void* sem;
        string name;

        lock() : sem(0)
        {
            try
            {
                long long count = lock_reference[sem];
                count++;
                lock_reference[sem] = count;
            }
            catch (entry_not_found_exception)
            {
                lock_reference[sem] = 1;
            }
        }

        lock(const string& _file_name)
            : name(_file_name)
        {
            sem = create_exclusive((security_attributes*)0, false, (const wchar_t*)name);
            if (sem == (void*)0)
            {
                string estring = string(L"error opening semaphore: ") + name + string(L" error: ") + get_last_error_string();
                throw file_exception(estring);
            }

            lock_reference[sem] = 1;
        }

        ~lock()
        {
            long long count = lock_reference[sem];
            count--;
            if (count == 0)
            {
                if (sem != 0)
                {

                    bool success = close_handle(sem);

                    if (!success)
                    {
                        string estring = string(L"error closeing handle: ") + name + string(L"  error: ") + get_last_error_string();
                        throw file_exception((const character*)estring);
                    }

                }
                lock_reference >> sem;
            }
            else
            {
                lock_reference[sem] = count;
            }
        }

        void destroy()
        {
            long long count = lock_reference[sem];
            count--;
            if (count == 0)
            {
                if (sem != 0)
                {

                    bool success = close_handle(sem);

                    if (!success)
                    {
                        string estring = string(L"error closeing handle: ") + name + string(L"  error: ") + get_last_error_string();
                        throw file_exception(estring);
                    }

                }
                lock_reference >> sem;
            }
            else
            {
                lock_reference[sem] = count;
            }
        }

        lock& operator=(const lock& l)
        {
            destroy();
            sem = l.sem;
            name = l.name;
            long long count = lock_reference[sem];
            count++;
            lock_reference[sem] = count;
            return *this;
        }

        void request()
        {
            wait_for_single_object(sem, -1);
        }

        void release()
        {
            bool success = release_exclusive(sem);

            if (!success)
            {
                string estring = string(L"error releaseing semaphore: ") + name + string(L"  error: ") + get_last_error_string();
                throw file_exception(estring);
            }
        }
    };

    export template <class t>
        struct set_iterator
    {
        long long slot_number;
        data_file<t>* dp;

        set_iterator() {}

        set_iterator(data_file<t>* df_set,
            long long n)
        {
            slot_number = n;
            dp = df_set;
        }

        set_iterator(const set_iterator<t>& i) : slot_number(i.slot_number), dp(i.dp) {}

        t operator*() const
        {
            return dp->get(slot_number);
        }

        set_iterator<t>& operator++()
        {
            slot_number = next_slot(*(dp->_node_file), slot_number);
            return *this;
        }

        set_iterator<t> operator++(int)
        {
            set_iterator<t> save = *this; ++* this; return save;
        }

        set_iterator<t>& operator--()
        {
            slot_number = previous_slot(*(dp->_node_file), slot_number);
            return *this;
        }

        set_iterator<t> operator--(int)
        {
            set_iterator<t> save = *this; --* this; return save;
        }

        bool operator==(const set_iterator<t>& y) const { return slot_number == y.slot_number; }

        bool operator!=(const set_iterator<t>& y) const { return slot_number != y.slot_number; }

        bool is_header() const { return slot_number == 0; }
    };

    export  template <class t, class less = core::less<t>>
        struct set
    {
        node header;
        data_file<t>* dp;
        lock* semaphore;

        typedef database::set_iterator<t> iterator;

        set(const char* name)
        {
            semaphore = new lock(core::string(name));
            request();
            try
            {
                dp = new data_file<t>(core::string(name));
            }
            catch (...) { release(); throw; }
            release();
        }

        set(const char* name,
            const char* directory)
        {
            semaphore = new lock(core::string(name));
            request();
            try
            {
                dp = new data_file<t>(core::string(name), core::string(directory));
            }
            catch (...) { release(); throw; }
            release();
        }

        set(const wchar_t* name)
        {
            semaphore = new lock(core::string(name));
            request();
            try
            {
                dp = new data_file<t>(core::string(name));
            }
            catch (...) { release(); throw; }
            release();
        }

        set(const wchar_t* name,
            const wchar_t* directory)
        {
            semaphore = new lock(core::string(name));
            request();
            try
            {
                dp = new data_file<t>(core::string(name), core::string(directory));
            }
            catch (...) { release(); throw; }
            release();
        }

        ~set()
        {
            delete semaphore;
            delete dp;
        }

        iterator begin() const
        {
            iterator s(dp, 0);
            s++;
            return s;
        }

        iterator end() const { return iterator(dp, 0); }

        string name()
        {
            return dp->_slot_file->name;
        }

        string directory()
        {
            return dp->slot_file->directory;
        }

        void recover()
        {
            dp->recover();
            get_header();
        }

        t phurst()
        {
            t key;
            request();
            try
            {
                recover();
                if (header.parent == 0) throw entry_not_found_exception();
                key = dp->get(header.left);
            }
            catch (...) { release(); throw; }
            release();
            return key;
        }

        t last()
        {
            t key;
            request();
            try
            {
                recover();
                if (header.parent == 0) throw entry_not_found_exception();
                key = dp->get(header.right);
            }
            catch (...) { release(); throw; }
            release();
            return key;
        }

        long long depth()
        {
            long long d = 0;
            request();
            try
            {
                recover();
                d = depth(dp->_node_file, header.parent);
            }
            catch (...) { release(); throw; }
            release();
            return d;
        }

        long long length()
        {
            long long l = 0;
            request();
            try
            {
                recover();
                l = count(*dp->_node_file, header.parent);
            }
            catch (...) { release(); throw; }
            release();
            return l;
        }

        bool contains(const t& key)
        {
            request();
            try
            {
                recover();

                if (header.parent == 0)
                {
                    release();
                    return false;
                }
                else
                {
                    long long search = header.parent;

                    node _search = dp->_node_file->get(search);

                    do
                    {
                        t _key = dp->_slot_file->get(_search.key);

                        bool _less = less()(key, _key);
                        bool _greater = less()(_key, key);

                        if (_less)
                        {
                            search = _search.left;
                            if (search != 0) _search = dp->_node_file->get(search);
                        }

                        else if (_greater)
                        {
                            search = _search.right;
                            if (search != 0) _search = dp->_node_file->get(search);
                        }

                        else break;

                    } while (search != 0);

                    release();

                    return search != 0;

                }
            }
            catch (...) { release(); throw; }
        }

        void update(const t& data)
        {
            request();
            try
            {
                recover();
                long long slot = search(data);
                if (slot != 0)
                {
                    node node = dp->_node_file->get(slot);
                    t previous = dp->slot_file->get(node.key);
                    dp->update(slot, data);
                    dp->check_point();
                }
                else
                    internal_addd(data);
            }
            catch (...) { release(); throw; }
            release();
        }

        set& operator<<(const t& data)
        {
            add(data);
            return *this;
        }

        void add(const t& data)
        {
            request();
            try
            {
                recover();

                long long __node = header.parent;

                if (__node == 0)
                {
                    header.parent = dp->add(0, data);
                    header.left = header.parent;
                    header.right = header.parent;
                    put_header();
                    dp->check_point();
                    release();
                }
                else
                {
                    for (; ; )
                    {
                        node _node = dp->_node_file->get(__node);
                        t key = dp->_slot_file->get(_node.key);

                        bool _less = less()(data, key);
                        bool _greater = less()(key, data);

                        if (!_less && !_greater)
                        {
                            throw entry_already_exists_exception();
                        }

                        else if (_less)
                        {
                            if (_node.left != 0)
                                __node = _node.left;
                            else
                            {
                                long long new_node = dp->add(__node, data);
                                _node.left = new_node;
                                dp->_node_file->update(__node, _node);
                                if (header.left == __node)
                                {
                                    header.left = new_node;
                                    put_header();
                                }
                                balance_tree(*(dp->_node_file), __node, direction::from_left);
                                dp->check_point();
                                release();
                                return;
                            }
                        }

                        else
                        {
                            if (_node.right != 0)
                                __node = _node.right;
                            else
                            {
                                long long new_node = dp->add(__node, data);
                                _node.right = new_node;
                                dp->_node_file->update(__node, _node);
                                if (header.right == __node)
                                {
                                    header.right = new_node;
                                    put_header();
                                }
                                balance_tree(*(dp->_node_file), __node, direction::from_right);
                                dp->check_point();
                                release();
                                return;
                            }
                        }
                    }
                }
            }
            catch (...) { release(); throw; }
        }

        void internal_add(const t& data)
        {
            long long __node = header.parent;

            if (__node == 0)
            {
                header.parent = dp->ad(0, data);
                header.left = header.parent;
                header.right = header.parent;
                put_header();
                dp->check_point();
            }
            else
            {
                for (; ; )
                {
                    node _node = dp->_node_file->get(__node);
                    t key = dp->slot_file.get(_node.key);

                    bool _less = less()(data, key);
                    bool _greater = less()(key, data);

                    if (!_less && !_greater) throw entry_already_exists_exception();

                    else if (_less)
                    {
                        if (_node.left != 0)
                            __node = _node.left;
                        else
                        {
                            long long new_node = dp->ad(__node, data);
                            _node.left = new_node;
                            dp->_node_file->update(__node, _node);
                            if (header.left == __node)
                            {
                                header.left = new_node;
                                put_header();
                            }
                            balance_tree(dp->_node_file, __node, direction::from_left);
                            dp->check_point();
                            return;
                        }
                    }

                    else
                    {
                        if (_node.right != 0)
                            __node = _node.right;
                        else
                        {
                            long long new_node = dp->ad(__node, data);
                            _node.right = new_node;
                            dp->_node_file->update(__node, _node);
                            if (header.right == __node)
                            {
                                header.right = new_node;
                                put_header();
                            }
                            balance_tree(dp->_node_file, __node, direction::from_right);
                            dp->check_point();
                            return;
                        }
                    }
                }
            }
        }

        t find(const t& value)
        {
            t found;
            request();
            try
            {
                recover();
                long long slot_number = search(value);
                if (slot_number == 0)
                    throw entry_not_found_exception();

                found = dp->get(slot_number);
            }
            catch (...) { release(); throw; }
            release();
            return found;
        }

        void get_header()
        {
            header = dp->_node_file->get(0);
        }

        void put_header()
        {
            dp->_node_file->update(0, header);
        }

        void clear()
        {
            request();
            try
            {
                dp->reset();
            }
            catch (...) { release(); throw; }
            release();
        }

        set& operator>>(t data)
        {
            remove(data);
            return *this;
        }


        void remove(const t& data)
        {
            request();
            try
            {
                recover();

                long long __node = header.parent;

                for (; ; )
                {

                    if (__node == 0) throw entry_not_found_exception();


                    node _node = dp->_node_file->get(__node);

                    t key = dp->_slot_file->get(_node.key);

                    bool _less = less()(data, key);
                    bool _greater = less()(key, data);

                    if (_less)
                        __node = _node.left;

                    else if (_greater)
                        __node = _node.right;

                    else
                    {
                        if (_node.left != 0 && _node.right != 0)
                        {
                            long long replace = _node.left;
                            node _replace = dp->_node_file->get(replace);

                            while (_replace.right != 0)
                            {
                                replace = _replace.right;
                                _replace = dp->_node_file->get(replace);
                            }

                            swap_nodes(*(dp->_node_file), __node, replace);

                            __node = replace;
                            _node = dp->_node_file->get(__node);
                        }

                        long long parent = _node.parent;
                        node _parent = dp->_node_file->get(parent);

                        long long from = (_parent.left == __node) ? direction::from_left : direction::from_right;

                        if (header.left == __node)
                        {
                            long long n = next_slot(*(dp->_node_file), __node);

                            if (n == 0)
                            {
                                header.left = 0;
                                header.right = 0;
                            }
                            else
                                header.left = n;

                            put_header();
                        }
                        else if (header.right == __node)
                        {
                            long long p = previous_slot(*(dp->_node_file), __node);

                            if (p == 0)
                            {
                                header.left = 0;
                                header.right = 0;
                            }
                            else
                                header.right = p;

                            put_header();
                        }

                        if (_node.left == 0)
                        {
                            if (parent == 0)
                            {
                                header.parent = _node.right;
                                put_header();
                            }
                            else if (_parent.left == __node)
                            {
                                _parent.left = _node.right;
                                dp->_node_file->update(parent, _parent);
                            }
                            else
                            {
                                _parent.right = _node.right;
                                dp->_node_file->update(parent, _parent);
                            }

                            if (_node.right != 0)
                            {
                                node right = dp->_node_file->get(_node.right);
                                right.parent = parent;
                                dp->_node_file->update(_node.right, right);
                            }
                        }
                        else
                        {
                            if (parent == 0)
                            {
                                header.parent = _node.left;
                                put_header();
                            }
                            else if (_parent.left == __node)
                            {
                                _parent.left = _node.left;
                                dp->_node_file->update(parent, _parent);
                            }
                            else
                            {
                                _parent.right = _node.left;
                                dp->_node_file->update(parent, _parent);
                            }

                            if (_node.left != 0)
                            {
                                node left = dp->_node_file->get(_node.left);
                                left.parent = parent;
                                dp->_node_file->update(_node.left, left);
                            }
                        }

                        if (parent != 0) balance_tree_remove(*(dp->_node_file), parent, from);

                        dp->_node_file->dispose(__node);
                        dp->_slot_file->dispose(_node.key);

                        dp->check_point();
                        break;
                    }
                }
            }
            catch (...) { release(); throw; }
            release();
        }

        void request() { semaphore->request(); }

        void release() { semaphore->release(); }

        long long above(const t& data)
        {
            long long y = 0;
            long long x = header.parent;

            while (x != 0)
            {
                node _x = dp->_node_file->get(x);
                t key = dp->slot_file.get(_x.key);

                if (less(data, key))
                {
                    y = x;
                    x = _x.left;
                }
                else
                    x = _x.right;
            }

            return y;
        }

        long long below(const t& data)
        {
            long long y = 0;
            long long x = header.parent;

            while (x != 0)
            {
                node _x = dp->_node_file->get(x);
                t key = dp->slot_file.get(_x.key);

                if (!less(key, data))
                    x = _x.left;
                else
                {
                    y = x; x = _x.right;
                }
            }

            return y;
        }

        long long search(const t& data)
        {
            if (header.parent == 0)
                return 0;
            else
            {
                long long search = header.parent;
                node _search = dp->_node_file->get(search);

                do
                {
                    t key = dp->_slot_file->get(_search.key);

                    bool _less = less()(data, key);
                    bool _greater = less()(key, data);

                    if (_less)
                    {
                        search = _search.left;
                        _search = dp->_node_file->get(search);
                    }

                    else if (_greater)
                    {
                        search = _search.right;
                        _search = dp->_node_file->get(search);
                    }

                    else break;

                } while (search != 0);

                return search;
            }
        }
    };

    export template <class k, class t, class compare, class less = core::less<t>>
        struct tree : public set<t, less>
    {
        tree(const char* name) : set<t, less>(name) {}

        tree(const char* name, const char* directory) : set<t, less>(name, directory) {}

        tree(const wchar_t* name) : set<t, less>(name) {}

        tree(const wchar_t* name, const wchar_t* directory) : set<t, less>(name, directory) {}

        t operator[](const k& key)
        {
            return get(key);
        }

        t get(const k& key)
        {
            t find;

            set<t, less>::request();
            try
            {
                set<t, less>::recover();

                if (set<t, less>::header.parent == 0)
                    throw entry_not_found_exception();

                else
                {
                    long long search = set<t, less>::header.parent;

                    node _search = set<t, less>::dp->_node_file->get(search);

                    do
                    {
                        find = set<t, less>::dp->_slot_file->get(_search.key);

                        int c = compare()(key, find);

                        if (c < 0)
                        {
                            search = _search.left;
                            if (search != 0) _search = set<t, less>::dp->_node_file->get(search);
                        }

                        else if (c > 0)
                        {
                            search = _search.right;
                            if (search != 0) _search = set<t, less>::dp->_node_file->get(search);
                        }

                        else break;

                    } while (search != 0);

                    if (search == 0) throw entry_not_found_exception();

                    set<t, less>::release();

                    return find;
                }
            }
            catch (...) { set<t, less>::release(); throw; }
        }

        void remove(const k& data)
        {
            set<t, less>::remove(get(data));
        }

        bool contains(const k& data)
        {
            return set<t, less>::contains(get(data));
        }
    };

    export template <class c, class t>
        struct dictionary : public set<key_value<c, t>>
    {
        dictionary(const char* name)
            : set<key_value<c, t>>(name) {}

        dictionary(const char* name, const char* directory)
            : set<key_value<c, t>>(name, directory) {}

        dictionary(const wchar_t* name)
            : set<key_value<c, t>>(name) {}

        dictionary(const wchar_t* name, const wchar_t* directory)
            : set<key_value<c, t>>(name, directory) {}

        void add(c key, t value)
        {
            try { erase(key); }
            catch (...) {}
            *this << key_value<c, t>(key, value);
        }

        void erase(c key)
        {
            set<key_value<c, t>>::remove(key_value<c, t>(key));
        }

        t get(c key)
        {
            return set<key_value<c, t>>::find(key_value<c, t>(key)).value;
        }

        bool contains(c key)
        {
            try
            {
                set<key_value<c, t>>::find(key_value<c, t>(key));
                return true;
            }
            catch (...)
            {
                return false;
            }
        }

        const t& operator[](const c& key) const { return set<key_value<c, t>>::find(key).value(); }

        class reference
        {
        public:

            reference(dictionary<c, t>& dicSet, const c& keySet)
                : dic(&dicSet), key(&keySet) {}

            reference& operator=(const t& value)
            {
                dic->add(*key, value);
                return *this;
            }

            operator t () const
            {
                return dic->get(*key);
            }

            dictionary<c, t>* dic;
            const c* key;
        };

        reference operator[](const c& key) { return reference(*this, key); }

        dictionary& operator>>(const c& key) { erase(key); return *this; }
    };


    export template <class t, class less = core::less<t>>
        struct multiset
    {
        node header;
        data_file<t>* dp;
        lock* semaphore;

        typedef database::set_iterator<t> iterator;

        multiset(const char* name)
        {
            semaphore = new lock(core::string(name));
            request();
            try
            {
                dp = new data_file<t>(core::string(name));
            }
            catch (...) { release(); throw; }
            release();
        }

        multiset(const char* name,
            const char* directory)
        {
            semaphore = new lock(core::string(name));
            request();
            try
            {
                dp = new data_file<t>(core::string(name), core::string(directory));
            }
            catch (...) { release(); throw; }
            release();
        }


        multiset(const wchar_t* name)
        {
            semaphore = new lock(core::string(name));
            request();
            try
            {
                dp = new data_file<t>(core::string(name));
            }
            catch (...) { release(); throw; }
            release();
        }

        multiset(const wchar_t* name,
            const wchar_t* directory)
        {
            semaphore = new lock(core::string(name));
            request();
            try
            {
                dp = new data_file<t>(core::string(name), core::string(directory));
            }
            catch (...) { release(); throw; }
            release();
        }

        ~multiset()
        {
            delete semaphore;
            delete dp;
        }

        iterator begin() const
        {
            iterator s(dp, 0);
            s++;
            return s;
        }

        iterator end() const { return iterator(dp, 0); }

        string name()
        {
            return dp->_slot_file->name;
        }

        string directory()
        {
            return dp->slot_file->directory;
        }

        void recover()
        {
            dp->recover();
            get_header();
        }

        t phurst()
        {
            t key;
            request();
            try
            {
                recover();
                if (header.parent == 0) throw entry_not_found_exception();
                key = dp->get(header.left);
            }
            catch (...) { release(); throw; }
            release();
            return key;
        }

        t last()
        {
            t key;
            request();
            try
            {
                recover();
                if (header.parent == 0) throw entry_not_found_exception();
                key = dp->get(header.right);
            }
            catch (...) { release(); throw; }
            release();
            return key;
        }


        long long depth()
        {
            long long d = 0;
            request();
            try
            {
                recover();
                d = depth(dp->_node_file, header.parent);
            }
            catch (...) { release(); throw; }
            release();
            return d;
        }

        long long length()
        {
            long long l = 0;
            request();
            try
            {
                recover();
                l = count(dp->_node_file, header.parent);
            }
            catch (...) { release(); throw; }
            release();
            return l;
        }

        bool contains(t key)
        {
            request();
            try
            {
                recover();

                if (header.parent == 0)
                {
                    release();
                    return false;
                }
                else
                {
                    long long search = header.parent;

                    node _search = dp->_node_file->get(search);

                    do
                    {
                        t _key = dp->_slot_file->get(_search.key);

                        bool _less = less()(key, _key);
                        bool _greater = less()(_key, key);

                        if (_less)
                        {
                            search = _search.left;
                            if (search != 0) _search = dp->_node_file->get(search);
                        }

                        else if (_greater)
                        {
                            search = _search.right;
                            if (search != 0) _search = dp->_node_file->get(search);
                        }

                        else break;

                    } while (search != 0);

                    release();

                    return search != 0;

                }
            }
            catch (...) { release(); throw; }
        }

        //*** methods ***

        multiset<t>& operator<<(t data)
        {
            ad(data);
            return *this;
        }

        void ad(t data)
        {
            request();
            try
            {
                recover();

                long long __node = header.parent;

                if (__node == 0)
                {
                    header.parent = dp->add(0, data);
                    header.left = header.parent;
                    header.right = header.parent;
                    put_header();
                    dp->check_point();
                    release();
                }
                else
                {
                    for (; ; )
                    {
                        node _node = dp->_node_file->get(__node);
                        t key = dp->_slot_file->get(_node.key);

                        bool _less = less()(data, key);

                        if (_less)
                        {
                            if (_node.left != 0)
                                __node = _node.left;
                            else
                            {
                                long long new_node = dp->add(__node, data);
                                _node.left = new_node;
                                dp->_node_file->update(__node, _node);
                                if (header.left == __node)
                                {
                                    header.left = new_node;
                                    put_header();
                                }
                                balance_tree(*(dp->_node_file), __node, direction::from_left);
                                dp->check_point();
                                release();
                                return;
                            }
                        }

                        else
                        {
                            if (_node.right != 0)
                                __node = _node.right;
                            else
                            {
                                long long new_node = dp->add(__node, data);
                                _node.right = new_node;
                                dp->_node_file->update(__node, _node);
                                if (header.right == __node)
                                {
                                    header.right = new_node;
                                    put_header();
                                }
                                balance_tree(*(dp->_node_file), __node, direction::from_right);
                                dp->check_point();
                                release();
                                return;
                            }
                        }
                    }
                }
            }
            catch (...) { release(); throw; }
        }

        void internal_add(t data)
        {
            long long __node = header.parent;

            if (__node == 0)
            {
                header.parent = dp->ad(0, data);
                header.left = header.parent;
                header.right = header.parent;
                put_header();
                dp->check_point();
            }
            else
            {
                for (; ; )
                {
                    node _node = dp->_node_file->get(__node);
                    t key = dp->slot_file.get(_node.key);

                    bool _less = less()(data, key);
                    bool _greater = less()(key, data);

                    if (!_less && !_greater) throw entry_already_exists_exception();

                    else if (_less)
                    {
                        if (_node.left != 0)
                            __node = _node.left;
                        else
                        {
                            long long new_node = dp->ad(__node, data);
                            _node.left = new_node;
                            dp->_node_file->update(__node, _node);
                            if (header.left == __node)
                            {
                                header.left = new_node;
                                put_header();
                            }
                            balance_tree(dp->_node_file, __node, direction::from_left);
                            dp->check_point();
                            return;
                        }
                    }

                    else
                    {
                        if (_node.right != 0)
                            __node = _node.right;
                        else
                        {
                            long long new_node = dp->ad(__node, data);
                            _node.right = new_node;
                            dp->_node_file->update(__node, _node);
                            if (header.right == __node)
                            {
                                header.right = new_node;
                                put_header();
                            }
                            balance_tree(dp->_node_file, __node, direction::from_right);
                            dp->check_point();
                            return;
                        }
                    }
                }
            }
        }

        t find(t value)
        {
            t found;
            request();
            try
            {
                recover();
                long long slot_number = search(value);
                if (slot_number == 0)
                    throw entry_not_found_exception();

                found = dp->get(slot_number);
            }
            catch (...) { release(); throw; }
            release();
            return found;
        }

        void get_header()
        {
            header = dp->_node_file->get(0);
        }

        void put_header()
        {
            dp->_node_file->update(0, header);
        }

        void clear()
        {
            request();
            try
            {
                dp->reset();
            }
            catch (...) { release(); throw; }
            release();
        }

        set<t>& operator>>(t data)
        {
            remove(data);
            return *this;
        }

        void remove(t data)
        {
            request();
            try
            {
                recover();

                long long __node = header.parent;

                for (; ; )
                {
                    if (__node == 0) throw entry_not_found_exception();

                    node _node = dp->_node_file->get(__node);
                    t key = dp->_slot_file->get(_node.key);

                    bool _less = less()(data, key);
                    bool _greater = less()(key, data);

                    if (_less)
                        __node = _node.left;

                    else if (_greater)
                        __node = _node.right;

                    else
                    {
                        if (_node.left != 0 && _node.right != 0)
                        {
                            long long replace = _node.left;
                            node _replace = dp->_node_file->get(replace);

                            while (_replace.right != 0)
                            {
                                replace = _replace.right;
                                _replace = dp->_node_file->get(replace);
                            }

                            swap_nodes(*(dp->_node_file), __node, replace);

                            __node = replace;
                            _node = dp->_node_file->get(__node);
                        }

                        long long parent = _node.parent;
                        node _parent = dp->_node_file->get(parent);

                        long long from = (_parent.left == __node) ? direction::from_left : direction::from_right;

                        if (header.left == __node)
                        {
                            long long n = next_slot(*(dp->_node_file), __node);

                            if (n == 0)
                            {
                                header.left = 0;
                                header.right = 0;
                            }
                            else
                                header.left = n;

                            put_header();
                        }
                        else if (header.right == __node)
                        {
                            long long p = previous_slot(*(dp->_node_file), __node);

                            if (p == 0)
                            {
                                header.left = 0;
                                header.right = 0;
                            }
                            else
                                header.right = p;

                            put_header();
                        }

                        if (_node.left == 0)
                        {
                            if (parent == 0)
                            {
                                header.parent = _node.right;
                                put_header();
                            }
                            else if (_parent.left == __node)
                            {
                                _parent.left = _node.right;
                                dp->_node_file->update(parent, _parent);
                            }
                            else
                            {
                                _parent.right = _node.right;
                                dp->_node_file->update(parent, _parent);
                            }

                            if (_node.right != 0)
                            {
                                node right = dp->_node_file->get(_node.right);
                                right.parent = parent;
                                dp->_node_file->update(_node.right, right);
                            }
                        }
                        else
                        {
                            if (parent == 0)
                            {
                                header.parent = _node.left;
                                put_header();
                            }
                            else if (_parent.left == __node)
                            {
                                _parent.left = _node.left;
                                dp->_node_file->update(parent, _parent);
                            }
                            else
                            {
                                _parent.right = _node.left;
                                dp->_node_file->update(parent, _parent);
                            }

                            if (_node.left != 0)
                            {
                                node left = dp->_node_file->get(_node.left);
                                left.parent = parent;
                                dp->_node_file->update(_node.left, left);
                            }
                        }

                        if (parent != 0) balance_tree_remove(*(dp->_node_file), parent, from);

                        dp->_node_file->dispose(__node);
                        dp->_slot_file->dispose(_node.key);

                        dp->check_point();
                        break;
                    }
                }
            }
            catch (...) { release(); throw; }
            release();
        }

        void request() { semaphore->request(); }

        void release() { semaphore->release(); }

        long long search(const t& data) const
        {
            if (header.parent == 0)
                return 0;
            else
            {
                long long search = header.parent;
                node _search = dp->_node_file->get(search);

                do
                {
                    t key = dp->_slot_file->get(_search.key);

                    bool _less = less()(data, key);
                    bool _greater = less()(key, data);

                    if (_less)
                    {
                        search = _search.left;
                        _search = dp->_node_file->get(search);
                    }

                    else if (_greater)
                    {
                        search = _search.right;
                        _search = dp->_node_file->get(search);
                    }

                    else break;

                } while (search != 0);

                return search;
            }
        }
    };

    export template<class t, class less>
        std::ostream& operator<<(std::ostream& s, database::multiset<t, less>& o)
    {
        s << "{";
        typename::database::multiset<t, less>::iterator e = o.end();
        typename::database::multiset<t, less>::iterator l = e; --l;
        for (typename::database::multiset<t, less>::iterator i = o.begin(); i != e; i++)
        {
            s << *i; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }

    export template<class t, class less>
        std::wostream& operator<<(std::wostream& s, database::multiset<t, less>& o)
    {
        s << L"{";
        typename::database::multiset<t, less>::iterator e = o.end();
        typename::database::multiset<t, less>::iterator l = e; --l;
        for (typename::database::multiset<t, less>::iterator i = o.begin(); i != e; i++)
        {
            s << *i; if (i != l) s << L",";
        }
        s << L"}";
        return s;
    }

    export template<class t, class less>
        std::ostream& operator<<(std::ostream& s, database::set<t, less>& o)
    {
        s << "{";
        typename::database::set<t, less>::iterator e = o.end();
        typename::database::set<t, less>::iterator l = e; --l;
        for (typename::database::set<t, less>::iterator i = o.begin(); i != e; i++)
        {
            s << *i; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }

    export template<class t, class less>
        std::wostream& operator<<(std::wostream& s, database::set<t, less>& o)
    {
        s << L"{";
        typename::database::set<t, less>::iterator e = o.end();
        typename::database::set<t, less>::iterator l = e; --l;
        for (typename::database::set<t, less>::iterator i = o.begin(); i != e; i++)
        {
            s << *i; if (i != l) s << L",";
        }
        s << L"}";
        return s;
    }

    export template<class k, class t, class compare, class less>
        std::ostream& operator<<(std::ostream& s, database::tree<k, t, compare, less>& o)
    {
        s << "{";
        typename::database::tree<k, t, compare, less>::iterator e = o.end();
        typename::database::tree<k, t, compare, less>::iterator l = e; --l;
        for (typename::database::tree<k, t, compare, less>::iterator i = o.begin(); i != e; i++)
        {
            s << *i; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }

    export template<class k, class t, class compare, class less>
        std::wostream& operator<<(std::wostream& s, database::tree<k, t, compare, less>& o)
    {
        s << L"{";
        typename::database::tree<k, t, compare, less>::iterator e = o.end();
        typename::database::tree<k, t, compare, less>::iterator l = e; --l;
        for (typename::database::tree<k, t, compare, less>::iterator i = o.begin(); i != e; i++)
        {
            s << *i; if (i != l) s << L",";
        }
        s << L"}";
        return s;
    }

    export template <class t>
        struct list
    {
        dictionary<long long, t> d;

        typedef set_iterator<key_value<long long, t>> iterator;

        list(const char* name)
            : d(name) {}

        list(const char* name, const char* directory)
            : d(name, directory) {}

        list(const wchar_t* name)
            : d(name) {}

        list(const wchar_t* name, const wchar_t* directory)
            : d(name, directory) {}

        list& operator<<(const t& value)
        {
            key_value<long long, t> key;
            d.request();
            try
            {
                d.recover();
                if (d.header.parent == 0) { add(0, value); return *this; }
                key = d.dp->get(d.header.right);
                add(key.key + 1, value);
            }
            catch (...) { d.release(); throw; }
            d.release();
            return *this;
        }

        void push(const t& value)
        {
            *this << value;
        }

        void push_back(const t& value)
        {
            *this << value;
        }

        list& operator>>(t& value)
        {
            value = pop();
            return *this;
        }

        t pop()
        {
            key_value<long long, t> key;
            d.request();
            try
            {
                d.recover();
                if (d.header.parent == 0) { throw entry_not_found_exception(); }
                key = d.df->get(d.s.header.right);
                erase(key.key);
            }
            catch (...) { d.release(); throw; }
            d.release();
            return key.value;
        }

        void add(long long key, t value)
        {
            d.add(key, value);
        }

        void insert(long long key, t value)
        {
            d.add(key, value);
        }

        void erase(long long key)
        {
            d.erase(key);
        }

        t get(long long key)
        {
            return d.get(key);
        }

        bool contains(long long key)
        {
            return d.contains(key);
        }

        void clear() { d.clear(); }

        iterator begin() const { return d.begin(); }

        iterator end() const { return d.end(); }

        const t& operator[](long long key) const { return d.find(key).value(); }

        class reference
        {
        public:

            reference(list& listSet, long long keySet)
                : plist(&listSet), key(keySet) {}

            reference& operator=(const t& value)
            {
                plist->add(key, value);
                return *this;
            }

            reference& operator=(const reference& reph)
            {
                plist->add(key, (t&)reph);
                return *this;
            }

            operator t () const
            {
                return plist->get(key);
            }

            list* plist;
            long long key;
        };

        reference operator[](long long key) { return reference(*this, key); }

        list& operator>>(long long key) { erase(key); return *this; }
    };

    export template<class t>
        inline std::ostream& operator<<(std::ostream& s, const database::list<t>& o)
    {
        s << "{";
        typename::database::list<t>::iterator e = o.d.end();
        typename::database::list<t>::iterator l = e; --l;
        for (typename::database::list<t>::iterator i = o.d.begin(); i != e; i++)
        {
            s << (*i).value; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }


    export template<class k, class t>
        std::ostream& operator<<(std::ostream& s, database::dictionary<k, t>& o)
    {
        s << "{";
        typename::database::dictionary<k, t>::iterator e = o.end();
        typename::database::dictionary<k, t>::iterator l = e; --l;
        for (typename::database::dictionary<k, t>::iterator i = o.begin(); i != e; i++)
        {
            s << *i; if (i != l) s << ",";
        }
        s << "}";
        return s;
    }

    export template<class k, class t>
        std::wostream& operator<<(std::wostream& s, database::dictionary<k, t>& o)
    {
        s << L"{";
        typename::database::dictionary<k, t > ::iterator e = o.end();
        typename::database::dictionary<k, t > ::iterator l = e; --l;
        for (typename::database::dictionary<k, t > ::iterator i = o.begin(); i != e; i++)
        {
            s << *i; if (i != l) s << L",";
        }
        s << L"}";
        return s;
    }
}
export extern "C" inline int loop()
{
    core::queue_message queue_message;
    while (get_message(&queue_message, 0, 0, 0))
    {
        translate_message(&queue_message);
        dispatch_message(&queue_message);
    }

    return (int)queue_message.parameter1;
}
